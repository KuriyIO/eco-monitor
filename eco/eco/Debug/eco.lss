
AVRASM ver. 2.1.57  D:\diplom\eco\eco\eco.asm Wed Jun 15 09:35:44 2016

[builtin](2): Including file 'D:\dev\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m32def.inc'
D:\diplom\eco\eco\eco.asm(1): Including file 'D:\dev\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m32def.inc'
D:\diplom\eco\eco\eco.asm(18): Including file 'D:\diplom\eco\eco\DSEG.inc'
D:\diplom\eco\eco\eco.asm(21): Including file 'D:\diplom\eco\eco\int_table.inc'
D:\diplom\eco\eco\eco.asm(23): Including file 'D:\diplom\eco\eco\delay.inc'
D:\diplom\eco\eco\eco.asm(24): Including file 'D:\diplom\eco\eco\LCD.inc'
D:\diplom\eco\eco\eco.asm(25): Including file 'D:\diplom\eco\eco\menu.inc'
D:\diplom\eco\eco\eco.asm(26): Including file 'D:\diplom\eco\eco\I2C.inc'
D:\diplom\eco\eco\eco.asm(27): Including file 'D:\diplom\eco\eco\RTC.inc'
D:\diplom\eco\eco\eco.asm(28): Including file 'D:\diplom\eco\eco\TimeSet.inc'
D:\diplom\eco\eco\eco.asm(29): Including file 'D:\diplom\eco\eco\sound.inc'
D:\diplom\eco\eco\eco.asm(30): Including file 'D:\diplom\eco\eco\keyboard.inc'
D:\diplom\eco\eco\eco.asm(31): Including file 'D:\diplom\eco\eco\timers.inc'
D:\diplom\eco\eco\eco.asm(33): Including file 'D:\diplom\eco\eco\UART.inc'
D:\diplom\eco\eco\eco.asm(34): Including file 'D:\diplom\eco\eco\strings.inc'
D:\diplom\eco\eco\eco.asm(35): Including file 'D:\diplom\eco\eco\GSM.inc'
D:\diplom\eco\eco\eco.asm(36): Including file 'D:\diplom\eco\eco\Temp.inc'
D:\diplom\eco\eco\eco.asm(40): Including file 'D:\diplom\eco\eco\core_init.inc'
D:\diplom\eco\eco\eco.asm(123): Including file 'D:\diplom\eco\eco\EEPROM.inc'
                 
                 .include "m32def.inc" //include define for ATmega32 controller
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m32def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega32
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega32
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M32DEF_INC_
                 #define _M32DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega32
                 #pragma AVRPART ADMIN PART_NAME ATmega32
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x02
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	OCR0	= 0x3c
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	OCDR	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDTOE	= 4	; RW
                 .equ	WDDE	= WDTOE	; For compatibility
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF2	= 5	; External Interrupt Flag 2
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - General Interrupt Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	ISC2	= 6	; Interrupt Sense Control 2
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0 - Timer/Counter Control Register
                 .equ	CS00	= 0	; Clock Select 1
                 .equ	CS01	= 1	; Clock Select 1
                 .equ	CS02	= 2	; Clock Select 2
                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                 .equ	CTC0	= WGM01	; For compatibility
                 .equ	COM00	= 4	; Compare match Output Mode 0
                 .equ	COM01	= 5	; Compare Match Output Mode 1
                 .equ	WGM00	= 6	; Waveform Generation Mode
                 .equ	PWM0	= WGM00	; For compatibility
                 .equ	FOC0	= 7	; Force Output Compare
                 
                 ; TCNT0 - Timer/Counter Register
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0 - Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0	= 1	; Output Compare Flag 0
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Clear Timer/Counter2 on Compare Match
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Pulse Width Modulator Enable
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; When this bit is written to one,the Timer/Counter2 prescaler will be reset.The bit will be cleared by hardware after the operation is performed.Writing a zero to this bit will have no effect.This bit will always be read as zero if Timer/C                 ounter2 is clocked by the internal CPU clock.If this bit is written when Timer/Counter2 is operating in asynchronous mode,the bit will remain one until the prescaler has been reset.
                 .equ	ADFR	= ADATE	; For compatibility
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	ADTS0	= 5	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 6	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 7	; ADC Auto Trigger Source 2
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1&0
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PUD	= 2	; Pull-up Disable
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                 .equ	ASRE	= RWWSRE	; For compatibility
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	ASB	= RWWSB	; For compatibility
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler bits
                 .equ	TWPS1	= 1	; TWI Prescaler bits
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x085f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	OC2addr	= 0x0008	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x000a	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x000c	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x000e	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0010	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0012	; Timer/Counter1 Overflow
                 .equ	OC0addr	= 0x0014	; Timer/Counter0 Compare Match
                 .equ	OVF0addr	= 0x0016	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0018	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x001a	; USART, Rx Complete
                 .equ	UDREaddr	= 0x001c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x001e	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x0020	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0022	; EEPROM Ready
                 .equ	ACIaddr	= 0x0024	; Analog Comparator
                 .equ	TWIaddr	= 0x0026	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0028	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 42	; size in words
                 
                 #endif  /* _M32DEF_INC_ */
                 
                 
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m32def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega32
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega32
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M32DEF_INC_
                 
                 #endif  /* _M32DEF_INC_ */
                 
                 
                 
                  .macro dbg
                 sbi PORTD, 7
                 delay 82, 43, 77		//delay 1s
                 cbi PORTD, 7
                 delay 82, 43, 77		//delay 1s
                 .endm
                 
                  .equ freq=16000000	   //frequency of microcontoller
                  .def temp=r17		   //define r16 as temp
                  .def byte=r16		   //define r17 as byte (will be used for send byte to LCD)
                  .def menu_loc=r18
                  .equ XTAL = 16000000 //or 16000000	//microcontroller frequency
                 
                 //==========DATA SEGMENT=================================================
                 .include "DSEG.inc"
                 
                  * DSEG.inc
                  * Data segment
                  *  Created: 26.03.2016 0:38:52
                  *   Author: Hogs
                  */ 
                 
                 // In this segment we can to reserve some memory
                 // for strings for example...
                 .dseg
                 .org 0x0060							//starting from 0x0060 because 
                 									//before that adress we have reserved memory for registers
                 
000060           pressure_msg:			.byte 16	//Pressure string
000070           temperature_msg:		.byte 16	//Temperature message string
000080           time_msg:				.byte 16	//Time message string
000090           mc_msg:					.byte 16	//Memory Card option message string
0000a0           sms_msg:				.byte 16	//SMS option message string
0000b0           sound_msg:				.byte 16	//Sound option message string
0000c0           pressure_value:			.byte 16	//string which contain pressure value
0000d0           temperature_value:		.byte 16	//string which contain temperature value
0000e0           time_value:				.byte 16	//string which contain time value
0000f0           mc_value:				.byte 16	//string which contain memory card On/Off value
000100           sms_value:				.byte 16	//string which contain SMS On/Off value
000110           sound_value:			.byte 16	//string which contain sound On/Off value
000120           menu_location:			.byte 1		//current menu location
000121           tick_count:				.byte 1		//count of button activations
000122           last_btn:				.byte 1		//number of last pressed button
000123           sound_status:			.byte 1		//status of sound
000124           I2C_status:				.byte 1		//I2C status register
000125           I2C_buffer:				.byte 5		//I2C buffer
00012a           I2C_device:				.byte 1		//I2C device adress + R/W
00012b           I2C_data_pointer:		.byte 1		//pointer to clock's register
00012c           I2C_data_read:			.byte 1		//readed data
00012d           I2C_data_write:			.byte 1		//data which need to write
00012e           time_set_status:		.byte 1		//time set status register
00012f           time_set_value:			.byte 1		//contain a value which need to set
000130           time_set_ranges:		.byte 10	//contain a table with max values range
00013a           time_set_max_values:	.byte 5		//contain a max values of hh:mm dd/MM/yy
00013f           time_set_buffer:		.byte 2		//contain a active pair values
000141           time_set_blink_count:	.byte 1		//count of tick before blink
000142           UART_TX_buffer:			.byte 256	//UART Transmit buffer
000242           UART_TX_end:			.byte 1		//end of tx string
000243           UART_RX_buffer:			.byte 256	//UART Receive buffer
000343           UART_RX_end:			.byte 1		//end of rx string
000344           UART_TX_byte_p:			.byte 1		//pointer to Transmit buffer
000345           UART_RX_byte_p:			.byte 1		//pointer to Receive buffer
000346           UART_Status:			.byte 1		//UART Status register
000347           GSM_Status:				.byte 1		//GSM status register
000348           GSM_new_msg:			.byte 13	//check new message string
000355           GSM_read_SMS1:			.byte 9		//read SMS string part 1
00035e           GSM_read_SMS2:			.byte 3		//read SMS string part 2
000361           GSM_result:				.byte 3		// "OK" string
000364           GSM_write:				.byte 9		//send message string
00036d           GSM_write_msg:			.byte 2		//">" symbol
00036f           GSM_enter:				.byte 2		//send 0x0D
000371           GSM_end_msg:			.byte 2		//send 0x1A
000373           GSM_phone_start:		.byte 3		// ", string
000376           GSM_get_cmd:			.byte 11	//"device get" string
000381           GSM_set_cmd:			.byte 11	//"device set" string
00038c           GSM_info_parameter:		.byte 5		//"info" string
000391           GSM_time_parameter:		.byte 5		//"time" string
000396           GSM_temp_parameter:		.byte 5		//"temp" string
00039b           GSM_pressure_parameter:	.byte 9		//"pressure" string
0003a4           GSM_sound_parameter:	.byte 6		//"sound" string
0003aa           GSM_memory_parameter:	.byte 7		//"memory" string
0003b1           GSM_invalid_get:		.byte 84	//invalid get message
000405           GSM_invalid_set:		.byte 65	//invalid set message
000446           On_str:					.byte 4		//"On " string
00044a           Off_str:				.byte 4		//"Off" string
00044e           GSM_invalid_time_msg:	.byte 53	//invalid time set message
000483           GSM_invalid_OnOff:		.byte 69	//invalid On/Off set message
0004c8           GSM_ERROR:				.byte 6		//"ERROR" string
0004ce           GSM_CSQ:				.byte 8
0004d6           GSM_sms_index:			.byte 3		//index of message
0004d9           GSM_phone_number:		.byte 15	//phone number string
0004e8           end_of_string_phone:	.byte 1		//'\0' string
0004e9           MC_Settings:			.byte 1		//memory card settings (On/Off)
0004ea           Sound_Settings:			.byte 1		//sound settings (On/Off)
0004eb           Wire_temp:				.byte 2		//data from 1-Wire DS18B20
0004ed           temp_buffer:			.byte 10
                 
                 //- - - - - BMP parameters - - - - - - - 
                 
                 // Calibration coefficients
0004f7           AC1:		.byte 2
0004f9           AC2:		.byte 2
0004fb           AC3:		.byte 2
0004fd           AC4:		.byte 2
0004ff           AC5:		.byte 2
000501           AC6:		.byte 2
000503           B1:			.byte 2
000505           B2:			.byte 2
000507           MB:			.byte 2
000509           MC:			.byte 2
00050b           MD:			.byte 2
                 
                 // Temperature and pressure values
00050d           UT:			.byte 2
00050f           UP:			.byte 2
                 
                 // Calculation data
000511           X1:			.byte 4
000515           X2:			.byte 4
000519           B5:			.byte 4
00051d           T:			.byte 4
                 
000521           B6:			.byte 4
000525           X3:			.byte 4
000529           B3:			.byte 4
00052d           B4:			.byte 4
000531           B7:			.byte 4
000535           P:			.byte 4
                 //- - - - - - - - - - - - - - - - - - - -
                 
000539           //==========CODE SEGMENT=================================================
                 .cseg
                 .include "int_table.inc"	//interrupt vectors
                 
                  * Interrupt vectors table
                  */ 
                 
                  //=========INTERRUPT VECTORS TABLE=============================================
                  .org $000 //RESET
000000 940c 156a  jmp reset 
                  .org $002 //INT0 External Interrupt Request 0
000002 9518       reti
                  .org $004 //INT1 External Interrupt Request 1
000004 9518       reti
                  .org $006 //INT2 External Interrupt Request 2
000006 9518       reti
                  .org $008 //TIMER2 COMP Timer/Counter2 Compare Match
000008 9518       reti
                  .org $00A //TIMER2 OVF Timer/Counter2 Overflow
00000a 9518       reti
                  .org $00C //TIMER1 CAPT Timer/Counter1 Capture Event
00000c 9518       reti
                  .org $00E //TIMER1 COMPA Timer/Counter1 Compare Match A
00000e 940c 0ae7  jmp Keyboard_check_interrupt
                  .org $010 //TIMER1 COMPB Timer/Counter1 Compare Match B
000010 940c 0814  jmp Sound_play_and_pause
                  .org $012 //TIMER1 OVF Timer/Counter1 Overflow
000012 9518       reti
                  .org $014 //TIMER0 COMP Timer/Counter0 Compare Match
000014 940c 080d  jmp Sound_generation
                  .org $016 //TIMER0 OVF Timer/Counter0 Overflow
000016 9518       reti
                  .org $018 //SPI, STC Serial Transfer Complete
000018 9518       reti
                  .org $01A //USART, RXC USART, Rx Complete
00001a 940c 0b5e  jmp UART_receive
                  .org $01C //USART, UDRE USART Data Register Empty
00001c 940c 0b3b  jmp UART_transmit
                  .org $01E //USART, TXC USART, Tx Complete
00001e 9518       reti
                  .org $020 //ADC ADC Conversion Complete
000020 9518       reti
                  .org $022 //EE_RDY EEPROM Ready
000022 9518       reti
                  .org $024 //ANA_COMP Analog Comparator
000024 9518       reti
                  .org $026 //TWI Two-wire Serial Interface
000026 9518       reti
                  .org $028 //SPM_RDY Store Program Memory Ready
000028 9518       reti
                 //===============================================================================================
                 
                 //.include "math.inc"
                 .include "delay.inc"		//delay macro and proc
                 
                  * delay.inc
                  *
                  *  Created: 30.03.2016 0:23:08
                  *   Author: Hogs
                  */ 
                 
                 
                 //========= PROCEDURES ======================================
                 //------delay proc-------------------------------------------
                       
                  delay_proc:
                 
                 delay_proc_label: 
000029 959a      	dec  r25
00002a f7f1          brne delay_proc_label
00002b 958a          dec  r24
00002c f7e1          brne delay_proc_label
00002d 957a      	dec  r23
00002e f7d1          brne delay_proc_label
                 
00002f 9508       ret
                 
                 //======== MACRO ===========================================  
                 //----------delay macro-------------------------------------
                   
                  .macro delay
                  push r25
                  push r24
                  push r23
                 
                  ldi r25,@0
                  ldi r24,@1
                  ldi r23,@2
                 
                  call delay_proc
                 
                  pop r23
                  pop r24
                  pop r25
                  .endm
                 .include "LCD.inc"			//macro and procedures for HD44780 like displays
                 
                  * Macro and procedures
                  * for HD44780 like LCD 
                  * Sorry for bad english...
                  */ 
                 
                  .equ data = 0x04	   //create constant cmd = 0b00000100 
                  .equ cmd = 0		   //create constant data = 0
                  .equ RS = 2		   //RS - 2nd pin in port C
                  .equ E = 3			   //E - is strob line, is a 3rd pin in port C
                  .equ D4 = 4		   //LCD data pins in port C
                  .equ D5 = 5
                  .equ D6 = 6
                  .equ D7 = 7
                 
                  //========MACRO================================================================
                 
                 //------------------------------------------------------------------------
                  //      LCD clear
                  .macro LCD_clear
                  push temp
                  push byte
                  LCD_send_cmd 0x01	//clear display
                  delay 142,42,1 //delay 2ms
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      1st line
                  .macro first_line
                  push temp
                  push byte
                  LCD_send_cmd 0x80	//first line
                  delay 240,1,1 //delay 45us
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      2nd line
                  .macro second_line
                  push temp
                  push byte
                  LCD_send_cmd 0xC0	//second line
                  delay 240,1,1 //delay 45us
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      set port C as output for working with display
                  .macro LCD_port_init  
                  in temp, ddrc
                  ori temp, (0 | (1<<RS) | (1<<E) | (1<<D4) | (1<<D5) | (1<<D6) | (1<<D7))
                  out ddrc,temp
                  in temp,portc
                  andi temp, (~(0 | (1<<RS) | (1<<E) | (1<<D4) | (1<<D5) | (1<<D6) | (1<<D7)))
                  out portc,temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      send command to LCD
                  .macro LCD_send_cmd
                  push temp
                  push byte	
                  ldi temp,cmd
                  ldi byte,@0
                  call LCD_send_byte_proc
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      send symbol to LCD
                  .macro LCD_send_symbol	
                  push temp
                  push byte
                  ldi temp,4
                  ldi byte,@0
                  call LCD_send_byte_proc
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      print 16-symbol string from sram adress (if adress is const)
                  .macro LCD_print_str
                  push ZH
                  push ZL
                  push temp
                  push byte
                  push r19
                  ldi ZH,high(@0)	//load to high Z-byte high byte of adress
                  ldi ZL,low(@0)	//load to low Z-byte low byte of adress
                  ldi temp,data	//temp = 0x04 for send data to LCD
                 
                  ldi r19,17			//r19 is a counter
                  sram_read_loop:	//loop 16 times
                  ld byte,Z+			//read from SRAM and post-inc
                  call LCD_send_byte_proc	//print symbol to LCD
                  delay 240,1,1 //delay 45us
                  dec r19			//loop things...
                  brne sram_read_loop//go to sram_read_loop label if r19 is not 0
                 
                  pop r19
                  pop byte
                  pop temp
                  pop ZL
                  pop ZH
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      print 16-symbol string from sram adress (if adress is in register)
                  //					ADRESS MUST BE IN X REGISTER
                  .macro LCD_print_str_reg
                  push temp
                  push byte
                  push XL
                  push XH
                  push r19
                 
                  ldi temp,data	//temp = 0x04 for send data to LCD
                 
                  ldi r19,17			//r19 is a counter
                  sram_read_loop:	//loop 16 times
                  ld byte,X+			//read from SRAM and post-inc
                  call LCD_send_byte_proc	//print symbol to LCD
                  delay 240,1,1 //delay 45us
                  dec r19			//loop things...
                  brne sram_read_loop//go to sram_read_loop label if r19 is not 0
                 
                  pop r19
                  pop XH
                  pop XL
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                 //==============PROCEDURES=====================================================
                 
                 //------Send byte to LCD as 4-but mode------------------------------------
                 
                  LCD_send_byte_proc:
000030 94f8       cli
000031 930f       push byte //save symbol to stack
000032 7014       andi temp,0b0000_0100
000033 bb15       out portc,temp //setting RS line
                 
                  //======High half-byte send=======
000034 7f00       andi byte,0xF0 //clear low half-byte
                 				//example:
                 				//before ANDI byte was 0b01011111
                 				//after byte is 0b01010000
                 
000035 2b10       or temp,byte	//add high half-byte to temp register
                 				//example:
                 				//before: temp = 0b00000100, byte = 0b11110000
                 				//after: temp = 0b11110100
                 
000036 bb15       out portc,temp //out temp to port C
000037 95c8       lpm			//3 clocks delay
000038 9aab       sbi portc,E	//enable E signal
000039 95c8       lpm			//3 clocks delay
00003a 98ab       cbi portc,E	//disable E signal
00003b 939f
00003c 938f
00003d 937f
00003e ef90
00003f e081
000040 e071
000041 940e 0029
000043 917f
000044 918f
000045 919f       delay 240,1,1 //delay 45us
                  //======Low half-byte send========
000046 7014       andi temp,0b0000_0100
000047 910f       pop byte		//get symbol from stack
000048 9502       swap byte		//swap byte register
                 				//example:
                 				//before swap byte was: 0b01011010
                 				//after swap byte is:   0b10100101
000049 7f00       andi byte,0xF0 //clear high half-byte
                 				//example:
                 				//before andi: byte = 0b01011010
                 				//after: byte = 0b01010000
                 
00004a 2b10       or temp,byte	//add symbol's low half-byte 
00004b bb15       out portc,temp //out temp to port C
00004c 95c8       lpm			//3 clocks delay
00004d 9aab       sbi portc,E	//enable E
00004e 95c8       lpm			//3 clocks delay
00004f 98ab       cbi portc,E	//disable E
000050 95c8       lpm			//3 clocks delay
                  //=====Set port C as 0xFF=========
000051 ef00       ldi byte,0xF0
000052 bb05       out portc,byte	//out to port C 0b11110000
000053 9478       sei
000054 9508       ret
                 //------------------------------------------------------------------------
                 
                 //      LCD initialization
                  LCD_init:
000055 b314
000056 6f1c
000057 bb14
000058 b315
000059 7013
00005a bb15       LCD_port_init		//init port C as output
                 
00005b 939f
00005c 938f
00005d 937f
00005e ef92
00005f e08f
000060 e075
000061 940e 0029
000063 917f
000064 918f
000065 919f       delay 242,15,5		//50 ms delay
000066 e310       ldi temp,0x30
000067 bb15       out portc,temp		//send 0x30
000068 9aab       sbi portc,E
000069 95c8       lpm
00006a 98ab       cbi portc,E
00006b 939f
00006c 938f
00006d 937f
00006e ee95
00006f e18e
000070 e079
000071 940e 0029
000073 917f
000074 918f
000075 919f       delay 229,30,9		//100 ms delay
000076 9aab       sbi portc,E
000077 95c8       lpm				//send 0x30
000078 98ab       cbi portc,E
000079 939f
00007a 938f
00007b 937f
00007c ef92
00007d e08f
00007e e075
00007f 940e 0029
000081 917f
000082 918f
000083 919f       delay 242,15,5		//50 ms delay 
000084 9aab       sbi portc,E
000085 95c8       lpm				//send 0x30
000086 98ab       cbi portc,E
000087 939f
000088 938f
000089 937f
00008a ef92
00008b e08f
00008c e075
00008d 940e 0029
00008f 917f
000090 918f
000091 919f       delay 242,15,5		//50 ms delay
000092 e210       ldi temp,0x20
000093 bb15       out portc,temp
000094 9aab       sbi portc,E		//send 0x20
000095 95c8       lpm
000096 98ab       cbi portc,E
000097 939f
000098 938f
000099 937f
00009a ef90
00009b e081
00009c e071
00009d 940e 0029
00009f 917f
0000a0 918f
0000a1 919f       delay 240,1,1		//delay 45us
                 
0000a2 931f
0000a3 930f
0000a4 e010
0000a5 e208
0000a6 940e 0030
0000a8 910f
0000a9 911f       LCD_send_cmd 0x28	//init 4-bit mode 2 lines
0000aa 939f
0000ab 938f
0000ac 937f
0000ad ef90
0000ae e081
0000af e071
0000b0 940e 0029
0000b2 917f
0000b3 918f
0000b4 919f       delay 240,1,1 //delay 45us
0000b5 939f
0000b6 938f
0000b7 937f
0000b8 e89e
0000b9 e28a
0000ba e071
0000bb 940e 0029
0000bd 917f
0000be 918f
0000bf 919f       delay 142,42,1 //delay 2ms ?????????????????????????????
0000c0 931f
0000c1 930f
0000c2 e010
0000c3 e001
0000c4 940e 0030
0000c6 910f
0000c7 911f       LCD_send_cmd 0x01	//clear display
0000c8 939f
0000c9 938f
0000ca 937f
0000cb e89e
0000cc e28a
0000cd e071
0000ce 940e 0029
0000d0 917f
0000d1 918f
0000d2 919f       delay 142,42,1 //delay 2ms
0000d3 939f
0000d4 938f
0000d5 937f
0000d6 e89e
0000d7 e28a
0000d8 e071
0000d9 940e 0029
0000db 917f
0000dc 918f
0000dd 919f       delay 142,42,1 //delay 2ms ?????????????????????????????
0000de 931f
0000df 930f
0000e0 e010
0000e1 e00c
0000e2 940e 0030
0000e4 910f
0000e5 911f       LCD_send_cmd 0x0C	//display ON
0000e6 939f
0000e7 938f
0000e8 937f
0000e9 e89e
0000ea e28a
0000eb e071
0000ec 940e 0029
0000ee 917f
0000ef 918f
0000f0 919f       delay 142,42,1 //delay 2ms
0000f1 939f
0000f2 938f
0000f3 937f
0000f4 e89e
0000f5 e28a
0000f6 e071
0000f7 940e 0029
0000f9 917f
0000fa 918f
0000fb 919f       delay 142,42,1 //delay 2ms ?????????????????????????????
                 
0000fc d02d       rcall LCD_add_symbols
                 
0000fd 931f
0000fe 930f
0000ff 931f
000100 930f
000101 e010
000102 e800
000103 940e 0030
000105 910f
000106 911f
000107 939f
000108 938f
000109 937f
00010a ef90
00010b e081
00010c e071
00010d 940e 0029
00010f 917f
000110 918f
000111 919f
000112 910f
000113 911f       first_line	//set DDRAM as 0 (in start of first line)
000114 9508       ret
                 
                 //------------------------------------------------------------------------
                 
                 //-----------------Short init---------------------------------------------
                 LCD_Short_init:
                 
                  /*ldi temp,0x30
                  out portc,temp		//send 0x30
                  sbi portc,E
                  lpm
                  cbi portc,E
                  delay 229,30,9		//100 ms delay
                  sbi portc,E
                  lpm				//send 0x30
                  cbi portc,E
                  delay 242,15,5		//50 ms delay 
                  sbi portc,E
                  lpm				//send 0x30
                  cbi portc,E
                  delay 242,15,5		//50 ms delay
                  ldi temp,0x20
                  out portc,temp
                  sbi portc,E		//send 0x20
                  lpm
                  cbi portc,E
                  delay 240,1,1		//delay 45us
                 
                  LCD_send_cmd 0x28	//init 4-bit mode 2 lines
                  delay 240,1,1 //delay 45us
                  //delay 142,42,1 //delay 2ms ?????????????????????????????
                  //LCD_send_cmd 0x01	//clear display
                  //delay 142,42,1 //delay 2ms
                  //delay 142,42,1 //delay 2ms ?????????????????????????????*/
000115 931f
000116 930f
000117 e010
000118 e00c
000119 940e 0030
00011b 910f
00011c 911f       LCD_send_cmd 0x0C	//display ON
00011d 939f
00011e 938f
00011f 937f
000120 e89e
000121 e28a
000122 e071
000123 940e 0029
000125 917f
000126 918f
000127 919f       delay 142,42,1 //delay 2ms
                  //delay 142,42,1 //delay 2ms ?????????????????????????????
000128 d001       rcall LCD_add_symbols
                  //first_line	//set DDRAM as 0 (in start of first line)
000129 9508      ret
                 //------------------------------------------------------------------------
                 
                 //--------------- Add symbols --------------------------------------------
                 LCD_add_symbols:
00012a 931f
00012b 930f
00012c e010
00012d e400
00012e 940e 0030
000130 910f
000131 911f       LCD_send_cmd 0b0100_0000	//Set CGRAM adress as 0x00
000132 939f
000133 938f
000134 937f
000135 ef90
000136 e081
000137 e071
000138 940e 0029
00013a 917f
00013b 918f
00013c 919f       delay 240,1,1 //delay 45us
                 
00013d 931f
00013e 930f
00013f e014
000140 e000
000141 940e 0030
000143 910f
000144 911f       LCD_send_symbol 0b00000000			//Start sending bytes for draw a new symbol
000145 939f
000146 938f
000147 937f
000148 ef90
000149 e081
00014a e071
00014b 940e 0029
00014d 917f
00014e 918f
00014f 919f       delay 240,1,1 //delay 45us			//in this case i draw upper arrow
000150 931f
000151 930f
000152 e014
000153 e000
000154 940e 0030
000156 910f
000157 911f       LCD_send_symbol 0b00000000			//for do that i sending next bytes
000158 939f
000159 938f
00015a 937f
00015b ef90
00015c e081
00015d e071
00015e 940e 0029
000160 917f
000161 918f
000162 919f       delay 240,1,1 //delay 45us			//
000163 931f
000164 930f
000165 e014
000166 e000
000167 940e 0030
000169 910f
00016a 911f       LCD_send_symbol 0b00000000			//00000000
00016b 939f
00016c 938f
00016d 937f
00016e ef90
00016f e081
000170 e071
000171 940e 0029
000173 917f
000174 918f
000175 919f       delay 240,1,1 //delay 45us			//00000000
000176 931f
000177 930f
000178 e014
000179 e000
00017a 940e 0030
00017c 910f
00017d 911f       LCD_send_symbol 0b00000000			//00000000
00017e 939f
00017f 938f
000180 937f
000181 ef90
000182 e081
000183 e071
000184 940e 0029
000186 917f
000187 918f
000188 919f       delay 240,1,1 //delay 45us			//00000000
000189 931f
00018a 930f
00018b e014
00018c e004
00018d 940e 0030
00018f 910f
000190 911f       LCD_send_symbol 0b00000100			//00000100
000191 939f
000192 938f
000193 937f
000194 ef90
000195 e081
000196 e071
000197 940e 0029
000199 917f
00019a 918f
00019b 919f       delay 240,1,1 //delay 45us			//00001110
00019c 931f
00019d 930f
00019e e014
00019f e00e
0001a0 940e 0030
0001a2 910f
0001a3 911f       LCD_send_symbol 0b00001110			//00011111
0001a4 939f
0001a5 938f
0001a6 937f
0001a7 ef90
0001a8 e081
0001a9 e071
0001aa 940e 0029
0001ac 917f
0001ad 918f
0001ae 919f       delay 240,1,1 //delay 45us			//00000000
0001af 931f
0001b0 930f
0001b1 e014
0001b2 e10f
0001b3 940e 0030
0001b5 910f
0001b6 911f       LCD_send_symbol 0b00011111			//
0001b7 939f
0001b8 938f
0001b9 937f
0001ba ef90
0001bb e081
0001bc e071
0001bd 940e 0029
0001bf 917f
0001c0 918f
0001c1 919f       delay 240,1,1 //delay 45us			//
0001c2 931f
0001c3 930f
0001c4 e014
0001c5 e000
0001c6 940e 0030
0001c8 910f
0001c9 911f       LCD_send_symbol 0b00000000			//
0001ca 939f
0001cb 938f
0001cc 937f
0001cd ef90
0001ce e081
0001cf e071
0001d0 940e 0029
0001d2 917f
0001d3 918f
0001d4 919f       delay 240,1,1 //delay 45us			//
                 
0001d5 931f
0001d6 930f
0001d7 e014
0001d8 e000
0001d9 940e 0030
0001db 910f
0001dc 911f       LCD_send_symbol 0b00000000			//the same like previous but for draw down arrow
0001dd 939f
0001de 938f
0001df 937f
0001e0 ef90
0001e1 e081
0001e2 e071
0001e3 940e 0029
0001e5 917f
0001e6 918f
0001e7 919f       delay 240,1,1 //delay 45us
0001e8 931f
0001e9 930f
0001ea e014
0001eb e10f
0001ec 940e 0030
0001ee 910f
0001ef 911f       LCD_send_symbol 0b00011111
0001f0 939f
0001f1 938f
0001f2 937f
0001f3 ef90
0001f4 e081
0001f5 e071
0001f6 940e 0029
0001f8 917f
0001f9 918f
0001fa 919f       delay 240,1,1 //delay 45us
0001fb 931f
0001fc 930f
0001fd e014
0001fe e00e
0001ff 940e 0030
000201 910f
000202 911f       LCD_send_symbol 0b00001110
000203 939f
000204 938f
000205 937f
000206 ef90
000207 e081
000208 e071
000209 940e 0029
00020b 917f
00020c 918f
00020d 919f       delay 240,1,1 //delay 45us
00020e 931f
00020f 930f
000210 e014
000211 e004
000212 940e 0030
000214 910f
000215 911f       LCD_send_symbol 0b00000100
000216 939f
000217 938f
000218 937f
000219 ef90
00021a e081
00021b e071
00021c 940e 0029
00021e 917f
00021f 918f
000220 919f       delay 240,1,1 //delay 45us
000221 931f
000222 930f
000223 e014
000224 e000
000225 940e 0030
000227 910f
000228 911f       LCD_send_symbol 0b00000000
000229 939f
00022a 938f
00022b 937f
00022c ef90
00022d e081
00022e e071
00022f 940e 0029
000231 917f
000232 918f
000233 919f       delay 240,1,1 //delay 45us
000234 931f
000235 930f
000236 e014
000237 e000
000238 940e 0030
00023a 910f
00023b 911f       LCD_send_symbol 0b00000000
00023c 939f
00023d 938f
00023e 937f
00023f ef90
000240 e081
000241 e071
000242 940e 0029
000244 917f
000245 918f
000246 919f       delay 240,1,1 //delay 45us
000247 931f
000248 930f
000249 e014
00024a e000
00024b 940e 0030
00024d 910f
00024e 911f       LCD_send_symbol 0b00000000
00024f 939f
000250 938f
000251 937f
000252 ef90
000253 e081
000254 e071
000255 940e 0029
000257 917f
000258 918f
000259 919f       delay 240,1,1 //delay 45us
00025a 931f
00025b 930f
00025c e014
00025d e000
00025e 940e 0030
000260 910f
000261 911f       LCD_send_symbol 0b00000000
000262 939f
000263 938f
000264 937f
000265 ef90
000266 e081
000267 e071
000268 940e 0029
00026a 917f
00026b 918f
00026c 919f       delay 240,1,1 //delay 45us
                 
00026d 931f
00026e 930f
00026f e014
000270 e000
000271 940e 0030
000273 910f
000274 911f       LCD_send_symbol 0b00000000			//
000275 939f
000276 938f
000277 937f
000278 ef90
000279 e081
00027a e071
00027b 940e 0029
00027d 917f
00027e 918f
00027f 919f       delay 240,1,1 //delay 45us			//
000280 931f
000281 930f
000282 e014
000283 e000
000284 940e 0030
000286 910f
000287 911f       LCD_send_symbol 0b00000000			//
000288 939f
000289 938f
00028a 937f
00028b ef90
00028c e081
00028d e071
00028e 940e 0029
000290 917f
000291 918f
000292 919f       delay 240,1,1 //delay 45us			//
000293 931f
000294 930f
000295 e014
000296 e000
000297 940e 0030
000299 910f
00029a 911f       LCD_send_symbol 0b00000000 		//
00029b 939f
00029c 938f
00029d 937f
00029e ef90
00029f e081
0002a0 e071
0002a1 940e 0029
0002a3 917f
0002a4 918f
0002a5 919f       delay 240,1,1 //delay 45us			//
0002a6 931f
0002a7 930f
0002a8 e014
0002a9 e000
0002aa 940e 0030
0002ac 910f
0002ad 911f       LCD_send_symbol 0b00000000			//
0002ae 939f
0002af 938f
0002b0 937f
0002b1 ef90
0002b2 e081
0002b3 e071
0002b4 940e 0029
0002b6 917f
0002b7 918f
0002b8 919f       delay 240,1,1 //delay 45us			//
0002b9 931f
0002ba 930f
0002bb e014
0002bc e000
0002bd 940e 0030
0002bf 910f
0002c0 911f       LCD_send_symbol 0b00000000			//
0002c1 939f
0002c2 938f
0002c3 937f
0002c4 ef90
0002c5 e081
0002c6 e071
0002c7 940e 0029
0002c9 917f
0002ca 918f
0002cb 919f       delay 240,1,1 //delay 45us			//
0002cc 931f
0002cd 930f
0002ce e014
0002cf e000
0002d0 940e 0030
0002d2 910f
0002d3 911f       LCD_send_symbol 0b00000000			//
0002d4 939f
0002d5 938f
0002d6 937f
0002d7 ef90
0002d8 e081
0002d9 e071
0002da 940e 0029
0002dc 917f
0002dd 918f
0002de 919f       delay 240,1,1 //delay 45us			//
0002df 931f
0002e0 930f
0002e1 e014
0002e2 e000
0002e3 940e 0030
0002e5 910f
0002e6 911f       LCD_send_symbol 0b00000000			//
0002e7 939f
0002e8 938f
0002e9 937f
0002ea ef90
0002eb e081
0002ec e071
0002ed 940e 0029
0002ef 917f
0002f0 918f
0002f1 919f       delay 240,1,1 //delay 45us			//
0002f2 931f
0002f3 930f
0002f4 e014
0002f5 e000
0002f6 940e 0030
0002f8 910f
0002f9 911f       LCD_send_symbol 0b00000000			//
0002fa 939f
0002fb 938f
0002fc 937f
0002fd ef90
0002fe e081
0002ff e071
000300 940e 0029
000302 917f
000303 918f
000304 919f       delay 240,1,1 //delay 45us			//
                 
000305 931f
000306 930f
000307 e014
000308 e00c
000309 940e 0030
00030b 910f
00030c 911f       LCD_send_symbol 0b00001100			//
00030d 939f
00030e 938f
00030f 937f
000310 ef90
000311 e081
000312 e071
000313 940e 0029
000315 917f
000316 918f
000317 919f       delay 240,1,1 //delay 45us			//
000318 931f
000319 930f
00031a e014
00031b e102
00031c 940e 0030
00031e 910f
00031f 911f       LCD_send_symbol 0b00010010			//
000320 939f
000321 938f
000322 937f
000323 ef90
000324 e081
000325 e071
000326 940e 0029
000328 917f
000329 918f
00032a 919f       delay 240,1,1 //delay 45us			//
00032b 931f
00032c 930f
00032d e014
00032e e102
00032f 940e 0030
000331 910f
000332 911f       LCD_send_symbol 0b00010010			//
000333 939f
000334 938f
000335 937f
000336 ef90
000337 e081
000338 e071
000339 940e 0029
00033b 917f
00033c 918f
00033d 919f       delay 240,1,1 //delay 45us			//
00033e 931f
00033f 930f
000340 e014
000341 e00c
000342 940e 0030
000344 910f
000345 911f       LCD_send_symbol 0b00001100			//
000346 939f
000347 938f
000348 937f
000349 ef90
00034a e081
00034b e071
00034c 940e 0029
00034e 917f
00034f 918f
000350 919f       delay 240,1,1 //delay 45us			//
000351 931f
000352 930f
000353 e014
000354 e000
000355 940e 0030
000357 910f
000358 911f       LCD_send_symbol 0b00000000			//
000359 939f
00035a 938f
00035b 937f
00035c ef90
00035d e081
00035e e071
00035f 940e 0029
000361 917f
000362 918f
000363 919f       delay 240,1,1 //delay 45us			//
000364 931f
000365 930f
000366 e014
000367 e000
000368 940e 0030
00036a 910f
00036b 911f       LCD_send_symbol 0b00000000			//
00036c 939f
00036d 938f
00036e 937f
00036f ef90
000370 e081
000371 e071
000372 940e 0029
000374 917f
000375 918f
000376 919f       delay 240,1,1 //delay 45us			//
000377 931f
000378 930f
000379 e014
00037a e000
00037b 940e 0030
00037d 910f
00037e 911f       LCD_send_symbol 0b00000000			//
00037f 939f
000380 938f
000381 937f
000382 ef90
000383 e081
000384 e071
000385 940e 0029
000387 917f
000388 918f
000389 919f       delay 240,1,1 //delay 45us			//
00038a 931f
00038b 930f
00038c e014
00038d e000
00038e 940e 0030
000390 910f
000391 911f       LCD_send_symbol 0b00000000			//
000392 939f
000393 938f
000394 937f
000395 ef90
000396 e081
000397 e071
000398 940e 0029
00039a 917f
00039b 918f
00039c 919f       delay 240,1,1 //delay 45us			//
00039d 9508       ret
                 //------------------------------------------------------------------------
                 .include "menu.inc"			//macro for menu uses
                 
                  * menu.inc
                  *
                  *  Created: 26.10.2015 0:27:02
                  *   Author: Hogs
                  */ 
                 
                  //========MACRO==========================================
                 
                  //--------Init menu page--------------------
                  .macro menu_init
                 
                  load_strings_to_SRAM		//save strings from eeprom to ram
                 
                  ldi YH,high(menu_location) //set current menu page as 0 (first page)
                  ldi YL,low(menu_location)	//
                  ldi temp,0
                  st Y,temp
                 
                  LCD_print_str pressure_msg		//print first menu page
                  second_line
                  LCD_print_str pressure_msg+96
                  .endm
                  //------------------------------------------
                  //--------Menu refresh page----------------
                  .macro menu_refresh
                 
                  push menu_loc			//Save all register which will be used
                  push XH				//
                  push XL				//
                  push temp
                  push YH
                  push YL
                 
                  call LCD_Short_init
                 
                  ldi YH,high(menu_location)		//load to Y register adress of
                  ldi YL,low(menu_location)		//current menu page
                  ld menu_loc,Y					//read from SRAM current menu page
                  
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain first string
                  mov XH,r1					//of menu message
                  ldi temp,0x60				//
                  add XL,temp				//adress = ((page - 1)*16)+96
                  clr temp					//
                  adc XH,temp				//
                 
                  first_line					//set first line for print
                  LCD_print_str_reg			//print message from adress (in X register)
                 
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain second string
                  mov XH,r1					//of menu message
                  ldi temp,0xC0				//
                  add XL,temp				//adress = ((page - 1) * 16)+192
                  clr temp					//
                  adc XH,temp				//
                 
                  second_line				//set second line for print
                  LCD_print_str_reg			//print second string
                 		
                  pop YL					//return all of used registers
                  pop YH					//to their place
                  pop temp
                  pop XL
                  pop XH
                  pop menu_loc
                 
                  .endm
                 
                  //--------Menu previous page----------------
                  .macro menu_prev
                 
                  push menu_loc			//Save all register which will be used
                  push XH				//
                  push XL				//
                  push temp
                  push YH
                  push YL
                 
                  ldi YH,high(menu_location)		//load to Y register adress of
                  ldi YL,low(menu_location)		//current menu page
                  ld menu_loc,Y					//read from SRAM current menu page
                 
                  ldi temp,0					//if current page is first
                  cpse menu_loc,temp			//then going out of procedure
                  rjmp PC+2					//else - continue
                  rjmp return_menu_prev		//
                 
                  dec menu_loc				//decrease page because menu moving up
                  
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain first string
                  mov XH,r1					//of menu message
                  ldi temp,0x60				//
                  add XL,temp				//adress = ((page - 1)*16)+96
                  clr temp					//
                  adc XH,temp				//
                 
                  first_line					//set first line for print
                  LCD_print_str_reg			//print message from adress (in X register)
                 
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain second string
                  mov XH,r1					//of menu message
                  ldi temp,0xC0				//
                  add XL,temp				//adress = ((page - 1) * 16)+192
                  clr temp					//
                  adc XH,temp				//
                 
                  second_line				//set second line for print
                  LCD_print_str_reg			//print second string
                 
                  ldi YH,high(menu_location)	//
                  ldi YL,low(menu_location)	//Save current page status to SRAM
                  st Y,menu_loc				//
                 
                  return_menu_prev:			
                  pop YL					//return all of used registers
                  pop YH					//to their place
                  pop temp
                  pop XL
                  pop XH
                  pop menu_loc
                 
                  .endm
                  //------------------------------------------
                 
                  //--------Menu next page--------------------
                  .macro menu_next
                 
                  push menu_loc		//save to stack
                  push XH			//all of used registers
                  push XL
                  push temp
                  push YH
                  push YL
                 
                  ldi YH,high(menu_location)	//
                  ldi YL,low(menu_location)	//read number of current page from SRAM
                  ld menu_loc,Y				//
                 
                  ldi temp,5					//if this page is last
                  cpse menu_loc,temp			//then go to return of procedure
                  rjmp PC+2					//else - continue
                  rjmp return_menu_next		//
                 
                  inc menu_loc		//increase page because moving down
                  
                  ldi temp,16			//counting of first string adress
                  mul temp,menu_loc		//and move it to X register
                  mov XL,r0				//
                  mov XH,r1				//adress = ((page + 1) * 16)+96
                  ldi temp,0x60
                  add XL,temp
                  clr temp
                  adc XH,temp
                 
                  first_line			//
                  LCD_print_str_reg	//printing first line
                 
                  ldi temp,16		//counting of second string adress
                  mul temp,menu_loc	//and move it to X register
                  mov XL,r0			//
                  mov XH,r1			//adress = ((page + 1) * 16)+192
                  ldi temp,0xC0
                  add XL,temp
                  clr temp
                  adc XH,temp
                 
                  second_line		//
                  LCD_print_str_reg	//printing second line
                 
                  ldi YH,high(menu_location)	//
                  ldi YL,low(menu_location)	//save new current page to SRAM
                  st Y,menu_loc				//
                 
                  return_menu_next:
                  pop YL				//return all of used registers
                  pop YH				//
                  pop temp
                  pop XL
                  pop XH
                  pop menu_loc
                 
                  .endm
                  //------------------------------------------
                 
                  //      Read from EEPROM and write it in SRAM
                  .macro load_strings_to_SRAM
                  cli
                  clr YH		 //load to YH register 0
                  ldi YL,0x60 //load to YL 0x60 coz 0x0060 - sram start
                  clr ZL		 //clear Z register
                  clr ZH
                  
                  ldi r19,193			//r19 is a counter
                 
                  EE_read_loop:			//loop 96 times
                  call EEPROM_read_byte //read byte from EEPROM
                  st Y+,byte				//Store byte to SRAM and post-Inc adress
                  inc ZL					//increment Z register after reading byte
                 
                  dec r19				//loop things...
                  brne EE_read_loop		//go to EE_read_loop label if r19 is not 0
                  sei
                  .endm
                 
                 //--------------------------------------------
                 
                  //=========PROCEDURES=====================================
                  //------Read Byte form EEPROM-----------------------
                 
                  EEPROM_read_byte:
                  ; Wait for completion of previous write
00039e 99e1       sbic EECR,EEWE
00039f cffe       rjmp EEPROM_read_byte
                 
0003a0 94f8       cli //disable all interrupts
                 
                  ; Set up address (Z register) in address register
0003a1 bbff       out EEARH, ZH
0003a2 bbee       out EEARL, ZL
                  ; Start eeprom read by writing EERE
0003a3 9ae0       sbi EECR,EERE
                  ; Read data from data register
0003a4 b30d       in byte,EEDR
                 
0003a5 9478       sei //enable interrupts
0003a6 9508       ret
                 .include "I2C.inc"
                 
                  * I2C.inc
                  *
                  *  Created: 09.06.2016 16:02:41
                  *   Author: Hogs
                  */ 
                 
                 
                  //=========== MACRO =====================================
                 
                  //------- i2c init --------------------------------
                  .macro I2C_Init
                  ldi temp,60
                  out TWBR,temp		//set SCL frequency as 100KHz
                  .endm
                 
                  //-------------------------------------------------
                  //------- Write single byte -----------------------
                 
                  // example: i2c_write_sbyte SLA, pointer, data
                  .macro i2c_write_sbyte
                  push r16
                  push r17
                  push r19
                 
                   ldi  r18, 11
                     ldi  r19, 99
                 L1: dec  r19
                     brne L1
                     dec  r18
                     brne L1
                 
                  mov r18, @2
                  clr r19
                  ldi byte, @0
                  ldi temp, @1 
                 
                     
                 
                  call i2c_write
                 
                  
                 
                 
                  pop r19
                  pop r17
                  pop r16
                  .endm
                  //-------------------------------------------------
                 
                  //------- Write multiple bytes --------------------
                  .macro i2c_write_mbyte
                  push r16
                  push r17
                  push r19
                  push XH
                  push XL
                 
                   ldi  r18, 11
                     ldi  r19, 99
                 L1: dec  r19
                     brne L1
                     dec  r18
                     brne L1
                 
                  ldi byte, @0
                  ldi temp, @1
                  ldi XH, high(@2)
                  ldi XL, low (@2)
                  ldi r19, @3
                  ld X+, r18
                  dec r19
                 
                 
                  call i2c_write
                 
                     
                 
                 
                  pop XL
                  pop XH
                  pop r19
                  pop r17
                  pop r16
                  .endm
                  //-------------------------------------------------
                 
                  //------- Read single byte ------------------------
                  .macro i2c_read_sbyte
                  push r16
                  push r17
                  push r19
                 
                     ldi  r18, 11
                     ldi  r19, 99
                 L1: dec  r19
                     brne L1
                     dec  r18
                     brne L1
                 
                  clr r19
                  ldi byte, @0
                  ldi temp, @1
                 
                  call i2c_read
                 
                  
                 
                 
                  pop r19
                  pop r17
                  pop r16
                  .endm
                  //-------------------------------------------------
                 
                  //------- Read multiple bytes ---------------------
                  .macro i2c_read_mbyte
                  push r16
                  push r17
                  push r18
                  push r19
                  push XH
                  push XL
                 
                     ldi  r18, 11
                     ldi  r19, 99
                 L1: dec  r19
                     brne L1
                     dec  r18
                     brne L1
                 
                  ldi byte, @0
                  ldi temp, @1
                  ldi XH, high(@2)
                  ldi XL, low (@2)
                  ldi r19, @3
                 
                  call i2c_read
                 
                 
                 
                 
                  pop XL
                  pop XH
                  pop r19
                  pop r18
                  pop r17
                  pop r16
                  .endm
                  //-------------------------------------------------
                 
                  //=========== PROCEDURES ================================
                 
                  //------- Write byte proc -------------------------
                 
                  // input:
                  // SLA(device id) - r16 (byte)
                  // data pointer - r17 (temp)
                  // data (if single byte) - r18 (data)
                  // count of bytes(if multiple) - r19
                  // buffer pointer(if multiple) - X
                  //
                  // no output
                 
                  i2c_write:
                 
0003a7 931f       push temp
                  /* Send Start */
0003a8 ea14       ldi temp, ((1<<TWSTA)|(1<<TWINT)|(1<<TWEN))
0003a9 bf16       out TWCR,temp
                 
0003aa b716       in temp, TWCR
0003ab ff17       sbrs temp, TWINT
0003ac cffd       rjmp PC-2
                 
                  /* Send device id + W */
0003ad b111       in temp, TWSR
0003ae 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
0003af 3018       cpi temp,0x08
0003b0 f521       brne i2c_write_err		//restart on error
                 
0003b1 7f0e       cbr byte, 1			//set W bit
0003b2 b903       out TWDR,byte			//load to TWDR SLA+W(device id + write)
0003b3 e814       ldi temp, ((1<<TWINT)|(1<<TWEN))	//send SLA+W(device id + write)
0003b4 bf16       out TWCR,temp
                 
0003b5 b716       in temp, TWCR
0003b6 ff17       sbrs temp, TWINT
0003b7 cffd       rjmp PC-2
                 
                  /* Write pointer */
0003b8 b111       in temp, TWSR
0003b9 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
0003ba 3118       cpi temp,0x18
0003bb f4c9       brne i2c_write_err		//restart on error
                 
0003bc 911f       pop temp
0003bd b913       out TWDR,temp
0003be e814       ldi temp, ((1<<TWINT)|(1<<TWEN))
0003bf bf16       out TWCR,temp
                 
0003c0 b716       in temp, TWCR
0003c1 ff17       sbrs temp, TWINT
0003c2 cffd       rjmp PC-2
                 
                  /* Write data byte(s) */
                  i2c_write_b:
0003c3 b111       in temp, TWSR
0003c4 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
0003c5 3218       cpi temp,0x28
0003c6 f471       brne i2c_write_err		//restart on error
                 
0003c7 b923       out TWDR, r18
0003c8 e814       ldi temp, ((1<<TWINT)|(1<<TWEN))
0003c9 bf16       out TWCR,temp
                 
0003ca b716       in temp, TWCR
0003cb ff17       sbrs temp, TWINT
0003cc cffd       rjmp PC-2
                 
0003cd 2333       tst r19
0003ce f019       breq i2c_write_stop
                 
0003cf 912d       ld r18, X+
0003d0 953a       dec r19
0003d1 cff1       rjmp i2c_write_b
                 
                  /* Write stop */
                  i2c_write_stop:
0003d2 e914       ldi temp, ((1<<TWSTO)|(1<<TWINT)|(1<<TWEN))	//generating stop
0003d3 bf16       out TWCR,temp
                 
0003d4 9508       ret
                 
                  /* Restart On Error */
                  i2c_write_err:
0003d5 e914       ldi temp, ((1<<TWSTO)|(1<<TWINT)|(1<<TWEN))	//generating stop
0003d6 bf16       out TWCR,temp
                 
0003d7 cfd0       rjmp i2c_write+1
                  //---------------------------------------------------
                 
                  //--------- Read byte proc --------------------------
                  // input:
                  // SLA(device id) - r16 (byte)
                  // data pointer(if single) - r17 (temp)
                  // count of bytes(if multiple) - r19
                  // buffer pointer(if multiple) - X
                  //
                  // output:
                  // data(if single) - r18 (data)
                 
                  i2c_read:
                 
0003d8 931f       push temp
                 
                  /* Send Start */
0003d9 ea14       ldi temp, ((1<<TWSTA)|(1<<TWINT)|(1<<TWEN))
0003da bf16       out TWCR,temp
                 
0003db b716       in temp, TWCR
0003dc ff17       sbrs temp, TWINT
0003dd cffd       rjmp PC-2
                 
                  /* Send SLA+W */
0003de b111       in temp, TWSR
0003df 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
0003e0 3018       cpi temp,0x08
0003e1 f009       breq PC+2
0003e2 c040       rjmp i2c_read_err		//restart on error
                 
0003e3 7f0e       cbr byte, 1			//set W bit
0003e4 b903       out TWDR,byte			//load to TWDR SLA+W(device id + write)
0003e5 e814       ldi temp, ((1<<TWINT)|(1<<TWEN))	//send SLA+W(device id + write)
0003e6 bf16       out TWCR,temp
                 
0003e7 b716       in temp, TWCR
0003e8 ff17       sbrs temp, TWINT
0003e9 cffd       rjmp PC-2 
                 
                  /* Write pointer */
0003ea b111       in temp, TWSR
0003eb 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
0003ec 3118       cpi temp,0x18
0003ed f5a9       brne i2c_read_err		//restart on error
                 
0003ee 911f       pop temp
0003ef b913       out TWDR,temp
0003f0 e814       ldi temp, ((1<<TWINT)|(1<<TWEN))
0003f1 bf16       out TWCR,temp
                 
0003f2 b716       in temp, TWCR
0003f3 ff17       sbrs temp, TWINT
0003f4 cffd       rjmp PC-2
                 
                  /* Write restart */
0003f5 b111       in temp, TWSR
0003f6 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
0003f7 3218       cpi temp,0x28
0003f8 f551       brne i2c_read_err		//restart on error
                 
0003f9 ea14       ldi temp, ((1<<TWSTA)|(1<<TWINT)|(1<<TWEN))	//generating start
0003fa bf16       out TWCR,temp
                 
0003fb b716       in temp, TWCR
0003fc ff17       sbrs temp, TWINT
0003fd cffd       rjmp PC-2
                 
                  /* Write SLA+R */
0003fe b111       in temp, TWSR
0003ff 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
000400 3110       cpi temp,0x10
000401 f509       brne i2c_read_err		//restart on error
                 
000402 6001       sbr byte, 1			//set R bit
000403 b903       out TWDR,byte			//load to TWDR SLA+R(device id + read)
000404 e814       ldi temp, ((1<<TWINT)|(1<<TWEN))
000405 bf16       out TWCR,temp
                 
000406 b716       in temp, TWCR
000407 ff17       sbrs temp, TWINT
000408 cffd       rjmp PC-2
                 
                  /* Read data byte(s) */
000409 e400       ldi byte, 0x40 
                  i2c_read_b:
00040a b111       in temp, TWSR
00040b 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))
00040c 1710       cp temp, byte
00040d f4a9       brne i2c_read_err		//restart on error
                 
00040e 3032       cpi r19,2
00040f f410       brsh PC+3
000410 e814       ldi temp, ((1<<TWINT)|(1<<TWEN))
000411 c001       rjmp PC+2
000412 ec14       ldi temp, ((1<<TWEA)|(1<<TWINT)|(1<<TWEN))
                 
000413 bf16       out TWCR,temp 
                 
000414 b716       in temp, TWCR
000415 ff17       sbrs temp, TWINT
000416 cffd       rjmp PC-2
                 
000417 b123       in r18,TWDR			//read data
000418 2711       clr temp
000419 b913       out TWDR,temp			//clear TWDR
                 
00041a 2333       tst r19
00041b f021       breq i2c_read_stop
                 
00041c 932d       st X+, r18
00041d e500       ldi byte, 0x50 
00041e 953a       dec r19
00041f cfea       rjmp i2c_read_b
                 
                  /* Send stop */
                  i2c_read_stop:
000420 e914       ldi temp, ((1<<TWSTO)|(1<<TWINT)|(1<<TWEN))	//generating stop
000421 bf16       out TWCR,temp
                 
000422 9508       ret
                 
                  /* Restart On Error */
                  i2c_read_err:
000423 e914       ldi temp, ((1<<TWSTO)|(1<<TWINT)|(1<<TWEN))	//generating stop
000424 bf16       out TWCR,temp
                 
000425 cfb3       rjmp i2c_read+1
                  //---------------------------------------------------
                 .include "RTC.inc"
                 
                  * RTC.inc
                  *
                  *  Created: 10.06.2016 0:54:10
                  *   Author: Hogs
                  */ 
                 
                  .equ RTCid = 0b11010000	//Clock device id
                  .equ CH = 7				//Clock Halt bit
                  .equ Hrs = 6				//Hours 12/24 bit
                 
                  //========= MACRO ===============================
                 
                  //------Correct settings---------------
                  //   That macro check clock's setting
                  //   and if some settings was wrong
                  //   then set it correct
                 
                  .macro I2C_Check_Clock_Settings
                  push temp
                  push r18
                  push YH
                  push YL
                 
                  i2c_read_sbyte RTCid, 0
                  
                  sbrs r18,7				//skip next command if clock is Off
                  rjmp RTC_check_hours
                 
                  andi r18, ~(1<<CH)		//set clock halt as 0(enable clock)
                  i2c_write_sbyte RTCid, 0, r18
                  
                  RTC_check_hours:
                  i2c_read_sbyte RTCid, 2
                  
                  sbrs temp,6			//skip next command if 24-hour mode is not set
                  rjmp RTC_check_return
                 
                  andi r18, ~(1<<Hrs)	//set Hours as 0(24-hours)
                  i2c_write_sbyte RTCid, 0, r18
                 
                  RTC_check_return:
                  pop YL
                  pop YH
                  pop r18
                  pop temp
                  .endm
                 
                  //----------------------------------
                 
                  //------Refresh time-----------
                  .macro Refresh_time
                  call I2C_Clock_Get_Time
                  call Time_to_string
                  .endm
                  //-----------------------------
                 
                  //===============================================
                 
                  //========= PROCEDURES ==========================
                 
                  //------- Get new time -------------
                  I2C_Clock_Get_Time:
000426 932f       push r18
                 
                  //- - - - READ HOURS - - - - - 
000427 930f
000428 931f
000429 933f
00042a e02b
00042b e633
00042c 953a
00042d f7f1
00042e 952a
00042f f7e1
000430 2733
000431 ed00
000432 e012
000433 940e 03d8
000435 913f
000436 911f
000437 910f       i2c_read_sbyte RTCid, 2		//read hours value
000438 9320 0125  sts I2C_buffer,r18				//store to I2C_buffer[0]
                  
                  //- - - - READ MINUTES - - - -
00043a 930f
00043b 931f
00043c 933f
00043d e02b
00043e e633
00043f 953a
000440 f7f1
000441 952a
000442 f7e1
000443 2733
000444 ed00
000445 e011
000446 940e 03d8
000448 913f
000449 911f
00044a 910f       i2c_read_sbyte RTCid, 1		//read minutes value
00044b 9320 0126  sts I2C_buffer+1,r18			//store to I2C_buffer[1]
                 
                  //- - - - READ DATE - - - - -
00044d 930f
00044e 931f
00044f 933f
000450 e02b
000451 e633
000452 953a
000453 f7f1
000454 952a
000455 f7e1
000456 2733
000457 ed00
000458 e014
000459 940e 03d8
00045b 913f
00045c 911f
00045d 910f       i2c_read_sbyte RTCid, 4		//read date value
00045e 9320 0127  sts I2C_buffer+2,r18			//store to I2C_buffer[2]
                 
                  //- - - - READ MONTH- - - - - -
000460 930f
000461 931f
000462 933f
000463 e02b
000464 e633
000465 953a
000466 f7f1
000467 952a
000468 f7e1
000469 2733
00046a ed00
00046b e015
00046c 940e 03d8
00046e 913f
00046f 911f
000470 910f       i2c_read_sbyte RTCid, 5		//read month value
000471 9320 0128  sts I2C_buffer+3,r18			//store to I2C_buffer[3]
                 
                  //- - - - READ YEARS - - - - -
000473 930f
000474 931f
000475 933f
000476 e02b
000477 e633
000478 953a
000479 f7f1
00047a 952a
00047b f7e1
00047c 2733
00047d ed00
00047e e016
00047f 940e 03d8
000481 913f
000482 911f
000483 910f       i2c_read_sbyte RTCid, 6		//read year value
000484 9320 0129  sts I2C_buffer+4,r18			//store to I2C_buffer[4]
                 
                  //- - - - - - - - - - - - - -
000486 912f       pop r18
000487 9508       ret
                  //-----------------------------------------
                 
                  //--------- Convert BCD time to string --------------
                  Time_to_string:
000488 932f       push r18
000489 933f       push r19
00048a 931f       push temp
00048b 93df       push YH
00048c 93cf       push YL
00048d 93bf       push XH
00048e 93af       push XL
                 
00048f e0d1       ldi YH,high(time_set_status)
000490 e2ce       ldi YL,low(time_set_status)
000491 8118       ld temp,Y
000492 fd17       sbrc temp,time_set_S		//if time set mode on then return
000493 c014       rjmp return_time_to_string
                 
000494 e330       ldi r19,48
000495 2722       clr r18
                 
000496 e0d0       ldi YH,high(time_value)
000497 eec0       ldi YL,low(time_value)
                 
000498 e0b1       ldi XH,high(I2C_buffer)
000499 e2a5       ldi XL,low(I2C_buffer)
                 
                  Time_to_string_loop:
                 
00049a 911d       ld temp,X+
                 
00049b 931f       push temp
00049c 9512       swap temp
00049d 701f       andi temp,0x0F	//clear high half-byte
00049e 0f13       add temp,r19	//temp += 48
00049f 9319       st Y+,temp
                 
0004a0 911f       pop temp
0004a1 701f       andi temp,0x0F	//clear high half-byte
0004a2 0f13       add temp,r19	//temp += 48
0004a3 9319       st Y+,temp
                 
0004a4 9621       adiw YH:YL,1
                 
0004a5 9523       inc r18
0004a6 3025       cpi r18,5
0004a7 f791       brne Time_to_string_loop
                 
                  return_time_to_string:
0004a8 91af       pop XL
0004a9 91bf       pop XH
0004aa 91cf       pop YL
0004ab 91df       pop YH
0004ac 911f       pop temp
0004ad 913f       pop r19
0004ae 912f       pop r18
0004af 9508       ret
                  //--------------------------------------------
                 
                  //-------load I2C_buffer from time value-----------------------
                  String_to_time:
0004b0 932f       push r18
0004b1 933f       push r19
0004b2 931f       push temp
0004b3 93df       push YH
0004b4 93cf       push YL
0004b5 93bf       push XH
0004b6 93af       push XL
                 
0004b7 2722       clr r18
                 
0004b8 e0d0       ldi YH,high(time_value)
0004b9 eec0       ldi YL,low(time_value)
                 
0004ba e0b1       ldi XH,high(I2C_buffer)
0004bb e2a5       ldi XL,low(I2C_buffer)
                 
                  String_to_time_loop:
                 
0004bc 9119       ld temp,Y+
0004bd 5310       subi temp,48
0004be 9512       swap temp
                 
0004bf 9139       ld r19,Y+
0004c0 5330       subi r19,48
0004c1 2b13       or temp,r19
                 
0004c2 931d       st X+,temp
                 
0004c3 9621       adiw YH:YL,1
                 
0004c4 9523       inc r18
0004c5 3025       cpi r18,5
0004c6 f7a9       brne String_to_time_loop
                 
0004c7 91af       pop XL
0004c8 91bf       pop XH
0004c9 91cf       pop YL
0004ca 91df       pop YH
0004cb 911f       pop temp
0004cc 913f       pop r19
0004cd 912f       pop r18
0004ce 9508       ret
                  //----------------------------------------------
                 
                  I2C_Clock_Set_New_Time:
0004cf 932f       push r18
                 
                  //- - - - WRITE HOURS- - - - - -
0004d0 9110 0125  lds temp, I2C_buffer
0004d2 930f
0004d3 931f
0004d4 933f
0004d5 e02b
0004d6 e633
0004d7 953a
0004d8 f7f1
0004d9 952a
0004da f7e1
0004db 2f21
0004dc 2733
0004dd ed00
0004de e012
0004df 940e 03a7
0004e1 913f
0004e2 911f
0004e3 910f       i2c_write_sbyte RTCid, 2, temp				//write hours
                 
                  //- - - - WRITE MINUTES - - - - -
0004e4 9110 0126  lds temp, I2C_buffer+1
0004e6 930f
0004e7 931f
0004e8 933f
0004e9 e02b
0004ea e633
0004eb 953a
0004ec f7f1
0004ed 952a
0004ee f7e1
0004ef 2f21
0004f0 2733
0004f1 ed00
0004f2 e011
0004f3 940e 03a7
0004f5 913f
0004f6 911f
0004f7 910f       i2c_write_sbyte RTCid, 1, temp				//write minutes
                 
                  //- - - - WRITE DATE - - - - - -
0004f8 9110 0127  lds temp, I2C_buffer+2
0004fa 930f
0004fb 931f
0004fc 933f
0004fd e02b
0004fe e633
0004ff 953a
000500 f7f1
000501 952a
000502 f7e1
000503 2f21
000504 2733
000505 ed00
000506 e014
000507 940e 03a7
000509 913f
00050a 911f
00050b 910f       i2c_write_sbyte RTCid, 4, temp				//write date
                 
                  //- - - - WRITE MONTH- - - - - - 
00050c 9110 0128  lds temp, I2C_buffer+3
00050e 930f
00050f 931f
000510 933f
000511 e02b
000512 e633
000513 953a
000514 f7f1
000515 952a
000516 f7e1
000517 2f21
000518 2733
000519 ed00
00051a e015
00051b 940e 03a7
00051d 913f
00051e 911f
00051f 910f       i2c_write_sbyte RTCid, 5, temp				//write month
                 
                  //- - - - WRITE YEARS - - - - - 
000520 9110 0129  lds temp, I2C_buffer+4
000522 930f
000523 931f
000524 933f
000525 e02b
000526 e633
000527 953a
000528 f7f1
000529 952a
00052a f7e1
00052b 2f21
00052c 2733
00052d ed00
00052e e016
00052f 940e 03a7
000531 913f
000532 911f
000533 910f       i2c_write_sbyte RTCid, 6, temp				//write date
                 
                  //- - - - - - - - - - - - - - - 
000534 912f       pop r18
000535 9508       ret
                  //-----------------------------------------
                 
                  //===============================================
                 .include "TimeSet.inc"		//time set procedures and macro
                 
                  * TimeSet.inc
                  *
                  *  Created: 17.11.2015 1:07:04
                  *   Author: Hogs
                  */ 
                  .equ time_set_S = 7		//time set status flag
                  .equ time_set_F = 6		//time set first number flag
                  .equ time_set_B = 5		//time set blink flag
                 
                  //======PROCEDURES==========================================
                  //-----------------------------------------------------
                  time_set_blink:
000536 931f       push temp
000537 93df       push YH
000538 93cf       push YL
000539 930f       push r16
                 
00053a e0d1       ldi YH,high(time_set_status)		//read time_set status
00053b e2ce       ldi YL,low(time_set_status)
00053c 8108       ld r16,Y
                 
00053d ff07       sbrs r16,time_set_S				//if time set mode is off
00053e c023       rjmp return_time_set_blink			//then return
                 
                 									//continue if time set mode is On
                 
00053f e0d1       ldi YH,high(time_set_blink_count)	//time_set_blink_count is a counter
000540 e4c1       ldi YL,low(time_set_blink_count)	//how much timer was ticked before
000541 8118       ld temp,Y							//pair visible On/Off
                 
000542 301a       cpi temp,10						//if timer ticked 10 times or more - continue
000543 f0f0       brlo return_time_set_blink			//else - return
                 
000544 e0d1       ldi YH,high(time_set_blink_count)
000545 e4c1       ldi YL,low(time_set_blink_count)
000546 2711       clr temp							//clear time_set_blink_counter
000547 8318       st Y,temp
                 
000548 ff05       sbrs r16,time_set_B			//check blink flag
000549 c009       rjmp blink_pair				//if blink flag is 0 then pair is visible,
                 								//if blink flag is 1 then pair is "  "
                 
00054a e0d1       ldi YH,high(time_set_status)
00054b e2ce       ldi YL,low(time_set_status)
00054c 7d0f       andi r16, ~(1<<time_set_B)			//set blink flag as 0
00054d 8308       st Y,r16
                 
00054e d0b1       rcall time_set_get_pair_adress		//get to Y register adress of symbols for current pair
00054f e210       ldi temp, ' '				//set current pair as "  " so it is like invisible
000550 9319       st Y+,temp
000551 8318       st Y,temp
                 
000552 c00f       rjmp return_time_set_blink	//return
                 
                  blink_pair:
                 
000553 e0d1       ldi YH,high(time_set_status)
000554 e2ce       ldi YL,low(time_set_status)
000555 6200       ori r16, (1<<time_set_B)		//set blink flag as 1
000556 8308       st Y,r16
                 
000557 93ff       push ZH
000558 93ef       push ZL
000559 d0a6       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
00055a e0f1       ldi ZH,high(time_set_buffer)	
00055b e3ef       ldi ZL,low(time_set_buffer)
00055c 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
00055d 9319       st Y+,temp
00055e 8110       ld temp,Z
00055f 8318       st Y,temp
000560 91ef       pop ZL
000561 91ff       pop ZH
                 
                 
                  return_time_set_blink:
000562 932f
000563 93bf
000564 93af
000565 931f
000566 93df
000567 93cf
000568 940e 0115
00056a e0d1
00056b e2c0
00056c 8128
00056d e110
00056e 9f12
00056f 2da0
000570 2db1
000571 e610
000572 0fa1
000573 2711
000574 1fb1
000575 931f
000576 930f
000577 931f
000578 930f
000579 e010
00057a e800
00057b 940e 0030
00057d 910f
00057e 911f
00057f 939f
000580 938f
000581 937f
000582 ef90
000583 e081
000584 e071
000585 940e 0029
000587 917f
000588 918f
000589 919f
00058a 910f
00058b 911f
00058c 931f
00058d 930f
00058e 93af
00058f 93bf
000590 933f
000591 e014
000592 e131
000593 910d
000594 940e 0030
000596 939f
000597 938f
000598 937f
000599 ef90
00059a e081
00059b e071
00059c 940e 0029
00059e 917f
00059f 918f
0005a0 919f
0005a1 953a
0005a2 f781
0005a3 913f
0005a4 91bf
0005a5 91af
0005a6 910f
0005a7 911f
0005a8 e110
0005a9 9f12
0005aa 2da0
0005ab 2db1
0005ac ec10
0005ad 0fa1
0005ae 2711
0005af 1fb1
0005b0 931f
0005b1 930f
0005b2 931f
0005b3 930f
0005b4 e010
0005b5 ec00
0005b6 940e 0030
0005b8 910f
0005b9 911f
0005ba 939f
0005bb 938f
0005bc 937f
0005bd ef90
0005be e081
0005bf e071
0005c0 940e 0029
0005c2 917f
0005c3 918f
0005c4 919f
0005c5 910f
0005c6 911f
0005c7 931f
0005c8 930f
0005c9 93af
0005ca 93bf
0005cb 933f
0005cc e014
0005cd e131
0005ce 910d
0005cf 940e 0030
0005d1 939f
0005d2 938f
0005d3 937f
0005d4 ef90
0005d5 e081
0005d6 e071
0005d7 940e 0029
0005d9 917f
0005da 918f
0005db 919f
0005dc 953a
0005dd f781
0005de 913f
0005df 91bf
0005e0 91af
0005e1 910f
0005e2 911f
0005e3 91cf
0005e4 91df
0005e5 911f
0005e6 91af
0005e7 91bf
0005e8 912f       menu_refresh		//refresh menu
                 
0005e9 910f       pop r16
0005ea 91cf       pop YL
0005eb 91df       pop YH
0005ec 911f       pop temp
0005ed 9508       ret
                  //-----------------------------------------------------
                  time_set_set_buffer:
0005ee 93df       push YH
0005ef 93cf       push YL
0005f0 93ff       push ZH
0005f1 93ef       push ZL
0005f2 931f       push temp
                 
0005f3 e0f1       ldi ZH,high(time_set_buffer)
0005f4 e3ef       ldi ZL,low(time_set_buffer)
                 
0005f5 d00a       rcall time_set_get_pair_adress
0005f6 9119       ld temp,Y+
0005f7 9311       st Z+,temp
0005f8 8118       ld temp,Y
0005f9 8310       st Z,temp
                 
0005fa 911f       pop temp
0005fb 91ef       pop ZL
0005fc 91ff       pop ZH
0005fd 91cf       pop YL
0005fe 91df       pop YH
0005ff 9508       ret
                 
                  //-----------------------------------------------------
                  time_set_get_pair_adress:
000600 931f       push temp
000601 930f       push r16
                 
000602 e0d1       ldi YH,high(time_set_status)
000603 e2ce       ldi YL,low(time_set_status)
000604 8118       ld temp,Y
                 
000605 711f       andi temp,0b0001_1111		//clear flags
000606 2f01       mov r16,temp	
000607 0f10       add temp,r16				//temp = pair*2
000608 0f10       add temp,r16				//temp = pair*2 + pair
                 
000609 e0d0       ldi YH,high(time_value)
00060a eec0       ldi YL,low(time_value)
                 
00060b 0fc1       add YL,temp
00060c 2700       clr r16
00060d 1fd0       adc YH,r16
                 
00060e 910f       pop r16
00060f 911f       pop temp
000610 9508       ret
                  //---------------------------------------------
                  time_set_next_pair:
000611 93df       push YH
000612 93cf       push YL
000613 931f       push temp
                 
000614 93ff       push ZH
000615 93ef       push ZL
000616 dfe9       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
000617 e0f1       ldi ZH,high(time_set_buffer)	
000618 e3ef       ldi ZL,low(time_set_buffer)
000619 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
00061a 9319       st Y+,temp
00061b 8110       ld temp,Z
00061c 8318       st Y,temp
00061d 91ef       pop ZL
00061e 91ff       pop ZH
                 
00061f e0d1       ldi YH,high(time_set_status)
000620 e2ce       ldi YL,low(time_set_status)
000621 8118       ld temp,Y
                 
000622 7b1f       andi temp,~(1<<time_set_F)
                 
000623 931f       push temp
                  
000624 711f       andi temp,0b0001_1111
000625 3014       cpi temp,4
000626 f418       brsh time_set_next_pair_clear
                 
000627 911f       pop temp
000628 9513       inc temp
000629 c002       rjmp time_set_next_pair_return
                 
                  time_set_next_pair_clear:
00062a 911f       pop temp
00062b 7e10       andi temp,0b1110_0000
                 
                  time_set_next_pair_return:
00062c 8318       st Y,temp
00062d dfc0       rcall time_set_set_buffer
                 
00062e 911f       pop temp
00062f 91cf       pop YL
000630 91df       pop YH
000631 9508       ret
                  //-------Time set mode toggle--------------------
                  time_set_start:
                  
000632 e0d1       ldi YH,high(time_set_status)
000633 e2ce       ldi YL,low(time_set_status)
000634 8118       ld temp,Y
                 
000635 ff17       sbrs temp,time_set_S
000636 c016       rjmp enable_time_set
                 
                 
000637 93ff       push ZH
000638 93ef       push ZL
000639 dfc6       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
00063a e0f1       ldi ZH,high(time_set_buffer)	
00063b e3ef       ldi ZL,low(time_set_buffer)
00063c 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
00063d 9319       st Y+,temp
00063e 8110       ld temp,Z
00063f 8318       st Y,temp
000640 91ef       pop ZL
000641 91ff       pop ZH
                 
000642 e0d1       ldi YH,high(time_set_status)
000643 e2ce       ldi YL,low(time_set_status)
000644 e010       ldi temp, 0x00
000645 8318       st Y,temp
000646 de69       rcall String_to_time
000647 de87       rcall I2C_Clock_Set_New_Time
000648 940e 0426
00064a 940e 0488  Refresh_time
                 
00064c c003       rjmp return_time_set_start
                 
                  enable_time_set:
                 
00064d dfa0       rcall time_set_set_buffer	//save values of current pair to buffer
00064e e810       ldi temp,(1<<time_set_S)
00064f 8318       st Y,temp
                 
                  return_time_set_start:
000650 932f
000651 93bf
000652 93af
000653 931f
000654 93df
000655 93cf
000656 940e 0115
000658 e0d1
000659 e2c0
00065a 8128
00065b e110
00065c 9f12
00065d 2da0
00065e 2db1
00065f e610
000660 0fa1
000661 2711
000662 1fb1
000663 931f
000664 930f
000665 931f
000666 930f
000667 e010
000668 e800
000669 940e 0030
00066b 910f
00066c 911f
00066d 939f
00066e 938f
00066f 937f
000670 ef90
000671 e081
000672 e071
000673 940e 0029
000675 917f
000676 918f
000677 919f
000678 910f
000679 911f
00067a 931f
00067b 930f
00067c 93af
00067d 93bf
00067e 933f
00067f e014
000680 e131
000681 910d
000682 940e 0030
000684 939f
000685 938f
000686 937f
000687 ef90
000688 e081
000689 e071
00068a 940e 0029
00068c 917f
00068d 918f
00068e 919f
00068f 953a
000690 f781
000691 913f
000692 91bf
000693 91af
000694 910f
000695 911f
000696 e110
000697 9f12
000698 2da0
000699 2db1
00069a ec10
00069b 0fa1
00069c 2711
00069d 1fb1
00069e 931f
00069f 930f
0006a0 931f
0006a1 930f
0006a2 e010
0006a3 ec00
0006a4 940e 0030
0006a6 910f
0006a7 911f
0006a8 939f
0006a9 938f
0006aa 937f
0006ab ef90
0006ac e081
0006ad e071
0006ae 940e 0029
0006b0 917f
0006b1 918f
0006b2 919f
0006b3 910f
0006b4 911f
0006b5 931f
0006b6 930f
0006b7 93af
0006b8 93bf
0006b9 933f
0006ba e014
0006bb e131
0006bc 910d
0006bd 940e 0030
0006bf 939f
0006c0 938f
0006c1 937f
0006c2 ef90
0006c3 e081
0006c4 e071
0006c5 940e 0029
0006c7 917f
0006c8 918f
0006c9 919f
0006ca 953a
0006cb f781
0006cc 913f
0006cd 91bf
0006ce 91af
0006cf 910f
0006d0 911f
0006d1 91cf
0006d2 91df
0006d3 911f
0006d4 91af
0006d5 91bf
0006d6 912f       menu_refresh
                 
0006d7 9508       ret
                 
                  //-----------------------------------------
                  time_set_set_next_pair:
                  
0006d8 e0d1       ldi YH,high(time_set_status)
0006d9 e2ce       ldi YL,low(time_set_status)
0006da 8118       ld temp,Y
                 
0006db ff17       sbrs temp,time_set_S
0006dc c001       rjmp return_time_set_set_next_pair
                 
0006dd df33       rcall time_set_next_pair
                 
                  return_time_set_set_next_pair:
0006de 932f
0006df 93bf
0006e0 93af
0006e1 931f
0006e2 93df
0006e3 93cf
0006e4 940e 0115
0006e6 e0d1
0006e7 e2c0
0006e8 8128
0006e9 e110
0006ea 9f12
0006eb 2da0
0006ec 2db1
0006ed e610
0006ee 0fa1
0006ef 2711
0006f0 1fb1
0006f1 931f
0006f2 930f
0006f3 931f
0006f4 930f
0006f5 e010
0006f6 e800
0006f7 940e 0030
0006f9 910f
0006fa 911f
0006fb 939f
0006fc 938f
0006fd 937f
0006fe ef90
0006ff e081
000700 e071
000701 940e 0029
000703 917f
000704 918f
000705 919f
000706 910f
000707 911f
000708 931f
000709 930f
00070a 93af
00070b 93bf
00070c 933f
00070d e014
00070e e131
00070f 910d
000710 940e 0030
000712 939f
000713 938f
000714 937f
000715 ef90
000716 e081
000717 e071
000718 940e 0029
00071a 917f
00071b 918f
00071c 919f
00071d 953a
00071e f781
00071f 913f
000720 91bf
000721 91af
000722 910f
000723 911f
000724 e110
000725 9f12
000726 2da0
000727 2db1
000728 ec10
000729 0fa1
00072a 2711
00072b 1fb1
00072c 931f
00072d 930f
00072e 931f
00072f 930f
000730 e010
000731 ec00
000732 940e 0030
000734 910f
000735 911f
000736 939f
000737 938f
000738 937f
000739 ef90
00073a e081
00073b e071
00073c 940e 0029
00073e 917f
00073f 918f
000740 919f
000741 910f
000742 911f
000743 931f
000744 930f
000745 93af
000746 93bf
000747 933f
000748 e014
000749 e131
00074a 910d
00074b 940e 0030
00074d 939f
00074e 938f
00074f 937f
000750 ef90
000751 e081
000752 e071
000753 940e 0029
000755 917f
000756 918f
000757 919f
000758 953a
000759 f781
00075a 913f
00075b 91bf
00075c 91af
00075d 910f
00075e 911f
00075f 91cf
000760 91df
000761 911f
000762 91af
000763 91bf
000764 912f       menu_refresh
                 
000765 9508       ret
                  //-----------------------------------------
                  time_set:
000766 931f       push temp
000767 93df       push YH
000768 93cf       push YL
000769 930f       push r16
                 
00076a 93ff       push ZH
00076b 93ef       push ZL
00076c de93       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
00076d e0f1       ldi ZH,high(time_set_buffer)	
00076e e3ef       ldi ZL,low(time_set_buffer)
00076f 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
000770 9319       st Y+,temp
000771 8110       ld temp,Z
000772 8318       st Y,temp
000773 91ef       pop ZL
000774 91ff       pop ZH
                 
000775 e0d1       ldi YH,high(time_set_status)
000776 e2ce       ldi YL,low(time_set_status)
000777 8118       ld temp,Y						//read time_set_status to temp
                 
000778 ff17       sbrs temp,time_set_S	//return if time set status is off(0)
000779 c05d       rjmp return_time_set	//if time set status is 1 then continue
                 
                  //time set mode is on
00077a fd16       sbrc temp,time_set_F			//skip if number is second
00077b c01d       rjmp time_set_second_number	//continue if number is first
                 
                  //number is first
                 
00077c 8108       ld r16,Y
00077d 710f       andi r16, ~((1<<time_set_S)|(1<<time_set_F)|(1<<time_set_B))	//now r16 is a number of pair
00077e e0d1       ldi YH,high(time_set_ranges)
00077f e3c0       ldi YL,low(time_set_ranges)	//load to Y adress of max ranges
000780 0f00       add r16,r16
000781 0fc0       add YL,r16						//now Y is max ranges for current pair
000782 2700       clr r16		//clear r16, for next operation
000783 1fd0       adc YH,r16
000784 8108       ld r16,Y		//now r16 = max range for first number of this pair
                 
000785 2f12       mov temp,r18		//temp = ASCII code of number
000786 5310       subi temp,48		//now temp = number
000787 1710       cp temp,r16	//if number > max range, then continue
000788 f039       breq time_set_first_lower_first	//if number = max range, then go to label
000789 f030       brlo time_set_first_lower_first	//if number < max range, then go to label
                 
                  //if number is higher than max range
00078a de75       rcall time_set_get_pair_adress
00078b e300       ldi r16,'0'
00078c 9309       st Y+,r16						//pair will seems like that, example for hours
00078d 2f12       mov temp,r18					//if u try to set high hours higher than 2
00078e 8318       st Y,temp						//then pair will be 02, and time_set will switch on next pair
00078f c01e       rjmp time_set_check_max_value
                 
                  //if number is ok(lower than max range)
                  time_set_first_lower_first:
                 
000790 de6f       rcall time_set_get_pair_adress
000791 2f12       mov temp,r18					//if nubmer is ok then first number will be like pressed
000792 8318       st Y,temp						//and time_set_F flag will be set as 1, for set second number
000793 e0d1       ldi YH,high(time_set_status)
000794 e2ce       ldi YL,low(time_set_status)
000795 8118       ld temp,Y
000796 6410       ori temp,(1<<time_set_F)
000797 8318       st Y,temp
000798 c03e       rjmp return_time_set
                 
                 
                  //if setting second number
                  time_set_second_number:
                 
000799 8108       ld r16,Y
00079a 710f       andi r16, ~((1<<time_set_S)|(1<<time_set_F)|(1<<time_set_B))	//now r16 = pair
00079b e0d1       ldi YH,high(time_set_ranges)
00079c e3c0       ldi YL,low(time_set_ranges)
00079d 0f00       add r16,r16
00079e 9503       inc r16
00079f 0fc0       add YL,r16
0007a0 2700       clr r16
0007a1 1fd0       adc YH,r16
0007a2 8108       ld r16,Y		//now r16 = max range for first number of this pair
                 
0007a3 2f12       mov temp,r18		//temp = ASCII code of number
0007a4 5310       subi temp,48		//now temp = number
                 
0007a5 1710       cp temp,r16		//if nubmer > max range, then continue
0007a6 f011       breq time_set_first_lower_second //if number is ok then go to label
0007a7 f008       brlo time_set_first_lower_second //if number is ok then go to label
                 
0007a8 2f10       mov temp,r16
                 
                  time_set_first_lower_second:
0007a9 e300       ldi r16,48				//
0007aa 0f10       add temp,r16			// temp = ASCII code of number
0007ab de54       rcall time_set_get_pair_adress	//get to Y pair adress
0007ac 9621       adiw YH:YL,1
0007ad 8318       st Y,temp				//store second number to RAM
                  
                 
                  time_set_check_max_value:
                  //check for max value
0007ae de51       rcall time_set_get_pair_adress		//load to Y adress of pair
0007af 9119       ld temp,Y+			//temp = first number(ASCII)
0007b0 5310       subi temp,48		//temp = first number
0007b1 e00a       ldi r16,10
0007b2 9f10       mul temp,r16
0007b3 2d00       mov r16,r0			//r16 = first number * 10
0007b4 8118       ld temp,Y			//temp = second number(ASCII)
0007b5 5310       subi temp,48		//temp = second number
0007b6 0f01       add r16,temp		//r16 is value of pair
                 
0007b7 e0d1       ldi YH,high(time_set_status)
0007b8 e2ce       ldi YL,low(time_set_status)
0007b9 8118       ld temp,Y
0007ba 711f       andi temp, 0b0001_1111		//temp = number of pair
0007bb e0d1       ldi YH,high(time_set_max_values)
0007bc e3ca       ldi YL,low(time_set_max_values)
0007bd 0fc1       add YL,temp
0007be 2711       clr temp
0007bf 1fd1       adc YH,temp
0007c0 8118       ld temp,Y					//temp = max value for current pair
                 
0007c1 1701       cp r16,temp				//if current value of pair > max value for this pair, then continue
0007c2 f091       breq time_set_value_is_ok	//
0007c3 f088       brlo time_set_value_is_ok	//else - all is ok, return
                 
0007c4 2700       clr r16				//r16, is a counter for first number
                  time_set_div_label:
0007c5 9503       inc r16
0007c6 501a       subi temp,10
0007c7 f7ea       brpl time_set_div_label
0007c8 950a       dec r16				//now r16 contain first number
0007c9 930f       push r16				//and temp contain second
0007ca e00a       ldi r16,10
0007cb 0f10       add temp,r16
0007cc 910f       pop r16
                 
0007cd 932f       push r18
0007ce e320       ldi r18,48				//convert numbers to ASCII symbols
0007cf 0f02       add r16,r18
0007d0 0f12       add temp,r18
0007d1 912f       pop r18
                 
0007d2 de2d       rcall time_set_get_pair_adress
0007d3 9309       st Y+,r16				//save max value in time_value string
0007d4 8318       st Y,temp
                 
                  time_set_value_is_ok:
0007d5 de18       rcall time_set_set_buffer	//save values of current pair to buffer
0007d6 de3a       rcall time_set_next_pair	//set next pair
                  
                  return_time_set:
0007d7 de16       rcall time_set_set_buffer	//save values of current pair to buffer
                 
0007d8 910f       pop r16
0007d9 91cf       pop YL
0007da 91df       pop YH
0007db 911f       pop temp
0007dc 9508       ret
                  //========MACRO============================================
                 
                  //------INIT-------------------------------
                  .macro time_set_init
                  ldi YH,high(time_set_ranges)
                  ldi YL,low(time_set_ranges)
                 
                  ldi temp,2
                  st Y+,temp		//max hours high 2
                  ldi temp,9
                  st Y+,temp		//max hours low 9
                 
                  ldi temp,6
                  st Y+,temp		//max minutes high 6
                  ldi temp,9
                  st Y+,temp		//max minutes low 9
                 
                  ldi temp,3
                  st Y+,temp		//max date high 3
                  ldi temp,9
                  st Y+,temp		//max date low 9
                 
                  ldi temp,1
                  st Y+,temp		//max month high 1
                  ldi temp,9
                  st Y+,temp		//max month low 9
                 
                  st Y+,temp		//max year high 9
                  st Y+,temp		//max year low 9
                 
                  ldi YH,high(time_set_max_values)
                  ldi YL,low(time_set_max_values)
                 
                  ldi temp,24
                  st Y+,temp
                 
                  ldi temp,60
                  st Y+,temp
                 
                  ldi temp,31
                  st Y+,temp
                 
                  ldi temp,12
                  st Y+,temp
                 
                  ldi temp,99
                  st Y+,temp
                 
                  .endm
                  
                 .include "sound.inc"		//macro and procedures for buzzer sound
                 
                  * sound.inc
                  *
                  *  Created: 10.11.2015 23:44:51
                  *   Author: Hogs
                  */ 
                 
                  .equ BUZZER = 6				//6 - is number of pin for buzzer
                  .equ sound_general_status = 0	//number of sound_status bit, 
                 								//for get general sound status (sound_on/sound_off)
                  .equ sound_freq = 23			//frequency of sound
                 
                  //=======Sound macro=======================================
                  //-------Sound test---------------------------
                  .macro sound_test
                  ldi YH, high(menu_location)
                  ldi YL, low(menu_location)
                  ld temp, Y			//load current menu page to temp
                  cpi temp,5			//if current page is sound
                  brne @0			//then continue, else return
                  ldi YH,high(sound_status)	//
                  ldi YL,low(sound_status)	//read sound status from RAM
                  ld temp,Y
                 
                  sbrc temp,sound_general_status	//if sound is generally off then set sound on
                  rjmp sound_off					//else set sound off
                 
                  rcall sound_alarm_enable
                  rjmp @0
                 
                  sound_off:
                  rcall sound_alarm_disable
                  .endm
                  //-------Sound Init---------------------------
                  .macro sound_init
                  in temp, ddrd
                  ori temp, (0 | (1<<BUZZER))	//set buzzer pin as output
                  out ddrd,temp
                  in temp, portd
                  andi temp, ~(1<<BUZZER)	//set buzzer pin as 0
                  out portd, temp
                 
                 								//setting timer0
                  clr temp
                  out TCNT0,temp		//set counter as 0
                  ldi temp,sound_freq
                  out OCR0,temp		//set sound frequency
                  in temp, TIMSK
                  ori temp, (1<<OCIE0)	//
                  out TIMSK, temp	//enable On match timer 0 interrupt
                  .endm
                  //-------Timer0 enable---------------------------
                  .macro Timer0_enable
                  push temp
                  ldi temp, 0 | (1<<WGM01) | (1<<CS02)
                  out TCCR0, temp //set timer in CTC mode with 256 prescaler (enable)
                  pop temp
                  .endm
                  //-------Timer0 disable---------------------------
                  .macro Timer0_disable
                  push temp
                  clr temp
                  out TCCR0, temp //disable timer0
                  pop temp
                  .endm
                   //-------Timer 0 toggle--------------------------
                  .macro Timer0_toggle
                  push temp
                 
                  in temp, TCCR0			//if TCCR0 is empty
                  cpi temp,0				//then set timer on
                  breq set_timer_on		//else set timer off
                 
                  Timer0_disable
                  rjmp end_timer_toggle	//disable timer
                 
                  set_timer_on:
                  Timer0_enable
                 
                  end_timer_toggle:
                  pop temp
                  .endm
                  //=======PROCEDURES=======================================================
                  //-------Sound Alarm enable----------------------
                  sound_alarm_enable:
0007dd 931f       push temp
0007de 93df       push YH
0007df 93cf       push YL
                 
0007e0 e0d1       ldi YH,high(sound_status)	//
0007e1 e2c3       ldi YL,low(sound_status)	//set sound status in RAM
                  
0007e2 e011       ldi temp, 0 | (1<<sound_general_status)
0007e3 8318       st Y,temp	//set general sound status and pause status
                 
0007e4 b719       in temp, TIMSK
0007e5 6018       ori temp, (1<<OCIE1B)	//set OCIE1B as 1
0007e6 bf19       out TIMSK, temp	//enable interrupt(every 0.5sec)
                 
0007e7 931f
0007e8 e01c
0007e9 bf13
0007ea 911f       Timer0_enable		//enable timer0
                 
0007eb 91cf       pop YL
0007ec 91df       pop YH
0007ed 911f       pop temp
0007ee 9508       ret
                  //-------Sound Alarm disable---------------------
                  sound_alarm_disable:
0007ef 931f       push temp
0007f0 93df       push YH
0007f1 93cf       push YL
                  
0007f2 e0d1       ldi YH,high(sound_status)	//
0007f3 e2c3       ldi YL,low(sound_status)	//set sound status in RAM
                 
0007f4 e010       ldi temp, 0
0007f5 8318       st Y,temp			//set general sound status as 0 (alarm disable:)
                 
0007f6 b719       in temp, TIMSK
0007f7 7f17       andi temp, ~(1<<OCIE1B)	//set OCIE1B as 0
0007f8 bf19       out TIMSK, temp	//disable interrupt
                 
0007f9 931f
0007fa 2711
0007fb bf13
0007fc 911f       Timer0_disable		//stop sound generation
                 
0007fd 27cc       clr YL
0007fe 27dd       clr YH
0007ff 94f8       cli
000800 bddd       out TCNT1H,YH	//clear counter of timer1
000801 bdcc       out TCNT1L,YL
000802 9478       sei
                 
000803 e00c       ldi r16,0x0C			//set A as standart value	
000804 e315       ldi r17,0x35
000805 94f8       cli
000806 bd0b       out OCR1AH,r16			//set A as 3125
000807 bd1a       out OCR1AL,r17			//that mean timer tick is every 0.05sec
000808 9478       sei
                 
000809 91cf       pop YL
00080a 91df       pop YH
00080b 911f       pop temp
00080c 9508       ret
                  //-----------------------------------------------
                 
                  //=======Sound interrupts==================================
                 
                  //-------Sound generation interrupt-----------
                  Sound_generation:
00080d 9478       sei
00080e 9b86       sbis pind, BUZZER
00080f c002       rjmp Buzzer_set_1
000810 9896       cbi portd, BUZZER	//if buzzer pin is 1, then set it as 0
000811 9518       reti
                  Buzzer_set_1:
000812 9a96       sbi portd, BUZZER	//if buzzer pin is 0, then set is as 1
                  
000813 9518       reti
                 
                  //--------Sound play/pause interrupt----------
                  Sound_play_and_pause:
000814 9478       sei
000815 931f       push temp
000816 93df       push YH
000817 93cf       push YL
                  
                 
000818 e0dc       ldi YH,0x0C
000819 e3c5       ldi YL,0x35
00081a 94f8       cli
00081b bddb       out OCR1AH,YH	//set timer1 A as 3125
00081c bdca       out OCR1AL,YL	//for correct work with keyboard
00081d 9478       sei
                 
00081e 931f
00081f b713
000820 3010
000821 f029
000822 931f
000823 2711
000824 bf13
000825 911f
000826 c004
000827 931f
000828 e01c
000829 bf13
00082a 911f
00082b 911f       Timer0_toggle
                 
00082c 27cc       clr YL
00082d 27dd       clr YH
00082e 94f8       cli
00082f bddd       out TCNT1H,YH	//clear counter of timer1
000830 bdcc       out TCNT1L,YL
000831 9478       sei
                 
                  
000832 91cf       pop YL
000833 91df       pop YH
000834 911f       pop temp
000835 9518       reti
                  //--------------------------------------------
                 .include "keyboard.inc"		//macro and procedures for 3x4 keyboard
                 
                  * keyboard.inc
                  * macro and procedures for 3x4 keyboard
                  * Sorry for bad english
                  */ 
                 
                  .equ KBD_A = 2
                  .equ KBD_B = 3
                  .equ KBD_C = 4
                  .equ KBD_D = 5
                  .equ KBD_1 = 0
                  .equ KBD_2 = 1
                  .equ KBD_3 = 2
                  .equ count_of_ticks = 10	//count of ticks for prevent false activation macro
                 
                  //=======MACRO==========================================
                  //-------Preventing false activation----------------------------
                  .macro Anti_false_activation
                  
                  ldi YH,high(tick_count)
                  ldi YL,low(tick_count)
                  ld temp,Y+						//load to temp count of ticks
                  ld r16,Y						//load to r16 number of last pressed button
                 
                  cpi r16,@0							//compare block
                  brne end_of_activation_macro		//example on C language:
                  cpi temp,count_of_ticks			//	if(last_btn == @0)
                  brsh end_of_activation_macro		//	{
                 									//		if(tick > count_of_ticks)
                 									//		{
                 									//			tick = 0;
                 									//			do_something...
                 									//		}
                 									//		else
                 									//		{
                 									//			return of On_(button)_Click
                 									//		}
                 									//	}
                 									//	else
                 									//	{
                 									//		tick = 0;
                 									//		do_something...
                 									//	}
                 									//	last_btn=@0
                 
                  rjmp @1							//return of On_(some_btn)_Click
                 
                  end_of_activation_macro:			//label to end of macro for continue
                 
                  ldi temp,0							//saving to RAM
                  ldi r16,@0
                  ldi YH,high(tick_count)
                  ldi YL,low(tick_count)
                  st Y+,temp
                  st Y,r16
                 
                  .endm
                  //-------Initialization ports for working with keyboard---------
                  .macro keyboard_init
                  in temp,ddrb
                  andi temp, (~(0 | (1<<KBD_1) | (1<<KBD_2) | (1<<KBD_3)))
                  out ddrb,temp			//set KBD_1 KBD_2 KBD_3 as input
                 
                  in temp,portb
                  ori temp, (0 | (1<<KBD_1) | (1<<KBD_2) | (1<<KBD_3))
                  out portb,temp			//enable pull-ups for KBD_1 KBD_2 KBD_3
                 
                  in temp,ddrd
                  ori temp, (0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D))
                  out ddrd,temp			//set KBD_A KBD_B KBD_C KBD_D as output
                  .endm
                  //-------Check buttons------------------------------------------
                  .macro keyboard_check
                 
                 	push temp
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_A)))//set KBD_A as 0, and KBD_B,C,D as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_asterisk_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_2_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_3_Click
                 
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_B)))//set KBD_B as 0, and KBD_A,C,D as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_1_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_5_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_6_Click
                 
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_C)))//set KBD_C as 0, and KBD_A,B,D as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_4_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_8_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_9_Click
                 
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_D)))//set KBD_D as 0, and KBD_A,B,C as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_7_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_0_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_grid_Click
                 
                 	pop temp
                  .endm
                 
                  //=======PROCEDURES=====================================
                  //-------On 1 click-----------------------------
                  On_1_click:
000836 931f       push temp
000837 93df       push YH
000838 93cf       push YL
000839 930f       push r16
                 
00083a e0d1
00083b e2c1
00083c 9119
00083d 8108
00083e 3301
00083f f419
000840 301a
000841 f408
000842 c00f
000843 e010
000844 e301
000845 e0d1
000846 e2c1
000847 9319
000848 8308       Anti_false_activation '1', return_On_1_Click
                 
000849 e0d1       ldi YH,high(time_set_status)
00084a e2ce       ldi YL,low(time_set_status)
00084b 8118       ld temp,Y
00084c ff17       sbrs temp,time_set_S
00084d c004       rjmp return_On_1_Click
                 
00084e 932f       push r18
00084f e321       ldi r18,'1'
000850 df15       rcall time_set
000851 912f       pop r18
                 
                  return_On_1_Click:
000852 910f       pop r16
000853 91cf       pop YL
000854 91df       pop YH
000855 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_3		//wait until button is turned off
                  rjmp PC-1*/
000856 9508       ret
                  //-------On 2 click-----------------------------
                  On_2_click:
000857 931f       push temp
000858 93df       push YH
000859 93cf       push YL
00085a 930f       push r16
                 
00085b e0d1
00085c e2c1
00085d 9119
00085e 8108
00085f 3302
000860 f419
000861 301a
000862 f408
000863 c09d
000864 e010
000865 e302
000866 e0d1
000867 e2c1
000868 9319
000869 8308       Anti_false_activation '2', return_On_2_Click
                 
00086a e0d1       ldi YH,high(time_set_status)
00086b e2ce       ldi YL,low(time_set_status)
00086c 8118       ld temp,Y
00086d ff17       sbrs temp,time_set_S		//if time set mode on then skip menu navigation
00086e c005       rjmp menu_On_2_Click_label
                 
00086f 932f       push r18
000870 e322       ldi r18,'2'
000871 def4       rcall time_set
000872 912f       pop r18
000873 c08d       rjmp return_On_2_Click
                 
                  menu_On_2_Click_label:
000874 932f
000875 93bf
000876 93af
000877 931f
000878 93df
000879 93cf
00087a e0d1
00087b e2c0
00087c 8128
00087d e010
00087e 1321
00087f c001
000880 c07a
000881 952a
000882 e110
000883 9f12
000884 2da0
000885 2db1
000886 e610
000887 0fa1
000888 2711
000889 1fb1
00088a 931f
00088b 930f
00088c 931f
00088d 930f
00088e e010
00088f e800
000890 940e 0030
000892 910f
000893 911f
000894 939f
000895 938f
000896 937f
000897 ef90
000898 e081
000899 e071
00089a 940e 0029
00089c 917f
00089d 918f
00089e 919f
00089f 910f
0008a0 911f
0008a1 931f
0008a2 930f
0008a3 93af
0008a4 93bf
0008a5 933f
0008a6 e014
0008a7 e131
0008a8 910d
0008a9 940e 0030
0008ab 939f
0008ac 938f
0008ad 937f
0008ae ef90
0008af e081
0008b0 e071
0008b1 940e 0029
0008b3 917f
0008b4 918f
0008b5 919f
0008b6 953a
0008b7 f781
0008b8 913f
0008b9 91bf
0008ba 91af
0008bb 910f
0008bc 911f
0008bd e110
0008be 9f12
0008bf 2da0
0008c0 2db1
0008c1 ec10
0008c2 0fa1
0008c3 2711
0008c4 1fb1
0008c5 931f
0008c6 930f
0008c7 931f
0008c8 930f
0008c9 e010
0008ca ec00
0008cb 940e 0030
0008cd 910f
0008ce 911f
0008cf 939f
0008d0 938f
0008d1 937f
0008d2 ef90
0008d3 e081
0008d4 e071
0008d5 940e 0029
0008d7 917f
0008d8 918f
0008d9 919f
0008da 910f
0008db 911f
0008dc 931f
0008dd 930f
0008de 93af
0008df 93bf
0008e0 933f
0008e1 e014
0008e2 e131
0008e3 910d
0008e4 940e 0030
0008e6 939f
0008e7 938f
0008e8 937f
0008e9 ef90
0008ea e081
0008eb e071
0008ec 940e 0029
0008ee 917f
0008ef 918f
0008f0 919f
0008f1 953a
0008f2 f781
0008f3 913f
0008f4 91bf
0008f5 91af
0008f6 910f
0008f7 911f
0008f8 e0d1
0008f9 e2c0
0008fa 8328
0008fb 91cf
0008fc 91df
0008fd 911f
0008fe 91af
0008ff 91bf
000900 912f       menu_prev
                 
                  return_On_2_Click:
000901 910f       pop r16
000902 91cf       pop YL
000903 91df       pop YH
000904 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_2		//wait until button is turned off
                  rjmp PC-1*/
000905 9508       ret
                  //-------On 3 click-----------------------------
                  On_3_click:
000906 931f       push temp
000907 93df       push YH
000908 93cf       push YL
000909 930f       push r16
                 
00090a e0d1
00090b e2c1
00090c 9119
00090d 8108
00090e 3303
00090f f419
000910 301a
000911 f408
000912 c00f
000913 e010
000914 e303
000915 e0d1
000916 e2c1
000917 9319
000918 8308       Anti_false_activation '3', return_On_3_Click
                  
000919 e0d1       ldi YH,high(time_set_status)
00091a e2ce       ldi YL,low(time_set_status)
00091b 8118       ld temp,Y
00091c ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
00091d c004       rjmp return_On_3_Click
                 
00091e 932f       push r18
00091f e323       ldi r18,'3'
000920 de45       rcall time_set
000921 912f       pop r18
                 
                  return_On_3_Click:
000922 910f       pop r16
000923 91cf       pop YL
000924 91df       pop YH
000925 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_1		//wait until button is turned off
                  rjmp PC-1*/
000926 9508       ret
                  //-------On 4 click-----------------------------
                  On_4_click:
000927 931f       push temp
000928 93df       push YH
000929 93cf       push YL
00092a 930f       push r16
                 
00092b e0d1
00092c e2c1
00092d 9119
00092e 8108
00092f 3304
000930 f419
000931 301a
000932 f408
000933 c00f
000934 e010
000935 e304
000936 e0d1
000937 e2c1
000938 9319
000939 8308       Anti_false_activation '4', return_On_4_Click
                 
00093a e0d1       ldi YH,high(time_set_status)
00093b e2ce       ldi YL,low(time_set_status)
00093c 8118       ld temp,Y
00093d ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
00093e c004       rjmp return_On_4_Click
                 
00093f 932f       push r18
000940 e324       ldi r18,'4'
000941 de24       rcall time_set
000942 912f       pop r18
                 
                  return_On_4_Click:
000943 910f       pop r16
000944 91cf       pop YL
000945 91df       pop YH
000946 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_3		//wait until button is turned off
                  rjmp PC-1*/
000947 9508       ret
                  //-------On 5 click-----------------------------
                  On_5_click:
000948 931f       push temp
000949 93df       push YH
00094a 93cf       push YL
00094b 930f       push r16
                 
00094c e0d1
00094d e2c1
00094e 9119
00094f 8108
000950 3305
000951 f419
000952 301a
000953 f408
000954 c01d
000955 e010
000956 e305
000957 e0d1
000958 e2c1
000959 9319
00095a 8308       Anti_false_activation '5', return_On_5_Click
                  
00095b e0d1       ldi YH,high(time_set_status)
00095c e2ce       ldi YL,low(time_set_status)
00095d 8118       ld temp,Y
00095e ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
00095f c005       rjmp sound_On_5_Click_label
                 
000960 932f       push r18
000961 e325       ldi r18,'5'
000962 de03       rcall time_set
000963 912f       pop r18
000964 c00d       rjmp return_On_5_Click
                 
                  sound_On_5_Click_label:
000965 e0d1
000966 e2c0
000967 8118
000968 3015
000969 f441
00096a e0d1
00096b e2c3
00096c 8118
00096d fd10
00096e c002
00096f de6d
000970 c001
000971 de7d       sound_test return_On_5_Click
                 
                  return_On_5_Click:
000972 910f       pop r16
000973 91cf       pop YL
000974 91df       pop YH
000975 911f       pop temp
                  
                  /*sei
                  sbis pinb,KBD_2		//wait until button is turned off
                  rjmp PC-1*/
000976 9508       ret
                  //-------On 6 click-----------------------------
                  On_6_click:
000977 931f       push temp
000978 93df       push YH
000979 93cf       push YL
00097a 930f       push r16
                 
00097b e0d1
00097c e2c1
00097d 9119
00097e 8108
00097f 3306
000980 f419
000981 301a
000982 f408
000983 c00f
000984 e010
000985 e306
000986 e0d1
000987 e2c1
000988 9319
000989 8308       Anti_false_activation '6', return_On_6_Click
                 
00098a e0d1       ldi YH,high(time_set_status)
00098b e2ce       ldi YL,low(time_set_status)
00098c 8118       ld temp,Y
00098d ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
00098e c004       rjmp return_On_6_Click
                 
00098f 932f       push r18
000990 e326       ldi r18,'6'
000991 ddd4       rcall time_set
000992 912f       pop r18
                 
                  return_On_6_Click:
000993 910f       pop r16
000994 91cf       pop YL
000995 91df       pop YH
000996 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_1		//wait until button is turned off
                  rjmp PC-1*/
000997 9508       ret
                  //-------On 7 click-----------------------------
                  On_7_click:
000998 931f       push temp
000999 93df       push YH
00099a 93cf       push YL
00099b 930f       push r16
                 
00099c e0d1
00099d e2c1
00099e 9119
00099f 8108
0009a0 3307
0009a1 f419
0009a2 301a
0009a3 f408
0009a4 c00f
0009a5 e010
0009a6 e307
0009a7 e0d1
0009a8 e2c1
0009a9 9319
0009aa 8308       Anti_false_activation '7', return_On_7_Click
                 
0009ab e0d1       ldi YH,high(time_set_status)
0009ac e2ce       ldi YL,low(time_set_status)
0009ad 8118       ld temp,Y
0009ae ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
0009af c004       rjmp return_On_7_Click
                 
0009b0 932f       push r18
0009b1 e327       ldi r18,'7'
0009b2 ddb3       rcall time_set
0009b3 912f       pop r18
                 
                  return_On_7_Click:
0009b4 910f       pop r16
0009b5 91cf       pop YL
0009b6 91df       pop YH
0009b7 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_3		//wait until button is turned off
                  rjmp PC-1*/
0009b8 9508       ret
                  //-------On 8 click-----------------------------
                  On_8_click:
0009b9 931f       push temp
0009ba 93df       push YH
0009bb 93cf       push YL
0009bc 930f       push r16
                 
0009bd e0d1
0009be e2c1
0009bf 9119
0009c0 8108
0009c1 3308
0009c2 f419
0009c3 301a
0009c4 f408
0009c5 c09d
0009c6 e010
0009c7 e308
0009c8 e0d1
0009c9 e2c1
0009ca 9319
0009cb 8308       Anti_false_activation '8', return_On_8_Click
                  
0009cc e0d1       ldi YH,high(time_set_status)
0009cd e2ce       ldi YL,low(time_set_status)
0009ce 8118       ld temp,Y
0009cf ff17       sbrs temp,time_set_S		//if time set mode on then skip menu navigation
0009d0 c005       rjmp menu_On_8_Click_label
                 
0009d1 932f       push r18
0009d2 e328       ldi r18,'8'
0009d3 dd92       rcall time_set
0009d4 912f       pop r18
0009d5 c08d       rjmp return_On_8_Click
                 
                  menu_On_8_Click_label:
0009d6 932f
0009d7 93bf
0009d8 93af
0009d9 931f
0009da 93df
0009db 93cf
0009dc e0d1
0009dd e2c0
0009de 8128
0009df e015
0009e0 1321
0009e1 c001
0009e2 c07a
0009e3 9523
0009e4 e110
0009e5 9f12
0009e6 2da0
0009e7 2db1
0009e8 e610
0009e9 0fa1
0009ea 2711
0009eb 1fb1
0009ec 931f
0009ed 930f
0009ee 931f
0009ef 930f
0009f0 e010
0009f1 e800
0009f2 940e 0030
0009f4 910f
0009f5 911f
0009f6 939f
0009f7 938f
0009f8 937f
0009f9 ef90
0009fa e081
0009fb e071
0009fc 940e 0029
0009fe 917f
0009ff 918f
000a00 919f
000a01 910f
000a02 911f
000a03 931f
000a04 930f
000a05 93af
000a06 93bf
000a07 933f
000a08 e014
000a09 e131
000a0a 910d
000a0b 940e 0030
000a0d 939f
000a0e 938f
000a0f 937f
000a10 ef90
000a11 e081
000a12 e071
000a13 940e 0029
000a15 917f
000a16 918f
000a17 919f
000a18 953a
000a19 f781
000a1a 913f
000a1b 91bf
000a1c 91af
000a1d 910f
000a1e 911f
000a1f e110
000a20 9f12
000a21 2da0
000a22 2db1
000a23 ec10
000a24 0fa1
000a25 2711
000a26 1fb1
000a27 931f
000a28 930f
000a29 931f
000a2a 930f
000a2b e010
000a2c ec00
000a2d 940e 0030
000a2f 910f
000a30 911f
000a31 939f
000a32 938f
000a33 937f
000a34 ef90
000a35 e081
000a36 e071
000a37 940e 0029
000a39 917f
000a3a 918f
000a3b 919f
000a3c 910f
000a3d 911f
000a3e 931f
000a3f 930f
000a40 93af
000a41 93bf
000a42 933f
000a43 e014
000a44 e131
000a45 910d
000a46 940e 0030
000a48 939f
000a49 938f
000a4a 937f
000a4b ef90
000a4c e081
000a4d e071
000a4e 940e 0029
000a50 917f
000a51 918f
000a52 919f
000a53 953a
000a54 f781
000a55 913f
000a56 91bf
000a57 91af
000a58 910f
000a59 911f
000a5a e0d1
000a5b e2c0
000a5c 8328
000a5d 91cf
000a5e 91df
000a5f 911f
000a60 91af
000a61 91bf
000a62 912f       menu_next
                 
                  return_On_8_Click:
000a63 910f       pop r16
000a64 91cf       pop YL
000a65 91df       pop YH
000a66 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_2		//wait until button is turned off
                  rjmp PC-1*/
000a67 9508       ret
                  //-------On 9 click-----------------------------
                  On_9_click:
000a68 931f       push temp
000a69 93df       push YH
000a6a 93cf       push YL
000a6b 930f       push r16
                 
000a6c e0d1
000a6d e2c1
000a6e 9119
000a6f 8108
000a70 3309
000a71 f419
000a72 301a
000a73 f408
000a74 c00f
000a75 e010
000a76 e309
000a77 e0d1
000a78 e2c1
000a79 9319
000a7a 8308       Anti_false_activation '9', return_On_9_Click
                 
000a7b e0d1       ldi YH,high(time_set_status)
000a7c e2ce       ldi YL,low(time_set_status)
000a7d 8118       ld temp,Y
000a7e ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
000a7f c004       rjmp return_On_9_Click
                 
000a80 932f       push r18
000a81 e329       ldi r18,'9'
000a82 dce3       rcall time_set
000a83 912f       pop r18
                 
                  return_On_9_Click:
000a84 910f       pop r16
000a85 91cf       pop YL
000a86 91df       pop YH
000a87 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_1		//wait until button is turned off
                  rjmp PC-1*/
000a88 9508       ret
                  //-------On * click-----------------------------
                  On_asterisk_click:
000a89 931f       push temp
000a8a 93df       push YH
000a8b 93cf       push YL
000a8c 930f       push r16
                 
000a8d e0d1
000a8e e2c1
000a8f 9119
000a90 8108
000a91 320a
000a92 f419
000a93 301a
000a94 f408
000a95 c00d
000a96 e010
000a97 e20a
000a98 e0d1
000a99 e2c1
000a9a 9319
000a9b 8308       Anti_false_activation '*', return_On_asterisk_Click
                 
000a9c e0d1       ldi YH,high(menu_location)	//
000a9d e2c0       ldi YL,low(menu_location)	//read number of current page from SRAM
000a9e 8128       ld menu_loc,Y				//
000a9f 3022       cpi menu_loc,2
000aa0 f409       brne PC+2
000aa1 940e 0632  call time_set_start
                 
                  return_On_asterisk_Click:
000aa3 910f       pop r16
000aa4 91cf       pop YL
000aa5 91df       pop YH
000aa6 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_3		//wait until button is turned off
                  rjmp PC-1*/
000aa7 9508       ret
                  //-------On 0 click-----------------------------
                  On_0_click:
000aa8 931f       push temp
000aa9 93df       push YH
000aaa 93cf       push YL
000aab 930f       push r16
                 
000aac e0d1
000aad e2c1
000aae 9119
000aaf 8108
000ab0 3300
000ab1 f419
000ab2 301a
000ab3 f408
000ab4 c00f
000ab5 e010
000ab6 e300
000ab7 e0d1
000ab8 e2c1
000ab9 9319
000aba 8308       Anti_false_activation '0', return_On_0_Click
                 
000abb e0d1       ldi YH,high(time_set_status)
000abc e2ce       ldi YL,low(time_set_status)
000abd 8118       ld temp,Y
000abe ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
000abf c004       rjmp return_On_0_Click
                 
000ac0 932f       push r18
000ac1 e320       ldi r18,'0'
000ac2 dca3       rcall time_set
000ac3 912f       pop r18
                 
                  return_On_0_Click:
000ac4 910f       pop r16
000ac5 91cf       pop YL
000ac6 91df       pop YH
000ac7 911f       pop temp
                 
                  /*sei
                  sbis pinb,KBD_2		//wait until button is turned off
                  rjmp PC-1*/
000ac8 9508       ret
                  //-------On # click-----------------------------
                  On_grid_click:
000ac9 931f       push temp
000aca 93df       push YH
000acb 93cf       push YL
000acc 930f       push r16
                 
000acd e0d1
000ace e2c1
000acf 9119
000ad0 8108
000ad1 3203
000ad2 f419
000ad3 301a
000ad4 f408
000ad5 c00c
000ad6 e010
000ad7 e203
000ad8 e0d1
000ad9 e2c1
000ada 9319
000adb 8308       Anti_false_activation '#', return_On_grid_Click
                  
000adc e0d1       ldi YH,high(menu_location)	//
000add e2c0       ldi YL,low(menu_location)	//read number of current page from SRAM
000ade 8128       ld menu_loc,Y				//
000adf 3022       cpi menu_loc,2
000ae0 f409       brne PC+2
000ae1 dbf6       rcall time_set_set_next_pair
                  
                  return_On_grid_Click:
000ae2 910f       pop r16
000ae3 91cf       pop YL
000ae4 91df       pop YH
000ae5 911f       pop temp
                  
                  /*sei
                  sbis pinb,KBD_1	//wait until button is turned off
                  rjmp PC-1*/
000ae6 9508       ret
                  //----------------------------------------------
                 //================================================================
                 .include "timers.inc"		//macro and procedures for timer(s)
                 
                  * timers.inc
                  *
                  *  Created: 05.11.2015 0:04:38
                  *   Author: Hogs
                  */ 
                 
                  //==============TIMER 0 (8bit)==============================================
                 
                 		//Timer 0 is reserved for sound generation
                 		//you can see how it works in sound.inc
                 		//all code which using timer 0 is there
                 
                  //==========================================================================
                 
                  //==============TIMER 2 (8bit)==============================================
                 
                 		//Timer 2 is reserved for software UART
                 		//you can see how it works in softUART.inc
                 		//all code which using timer 0 is there
                 
                  //==========================================================================
                 
                  //==============TIMER 1 (16-bit)============================================
                 
                  //======MACRO========================
                  //------Timer 1 Init-----------
                  .macro Timer1_Init
                  cli
                  ldi temp, 0 | (1<<OCIE1A) //enable A Match Interrupt and Overflow Interrupt
                  out TIMSK,temp 
                  clr temp
                  out TCCR1A,temp		//Normal Timer Mode
                  ldi temp,0 | (1<<CS12)
                  out TCCR1B,temp		//Set prescaler 1/256
                  ldi r16,0x0C			
                  ldi r17,0x35
                  out OCR1AH,r16			//set A as 3125
                  out OCR1AL,r17			//that mean timer tick is every 0.05sec
                  ldi r16,0x7A			
                  ldi r17,0x12
                  out OCR1BH,r16			//set B as 32500
                  out OCR1BL,r17			//that mean timer tick is every 0.5sec
                  clr temp
                  out TCNT1H,temp		//set current timer/counter as 0
                  out TCNT1L,temp
                  sei
                  .endm
                  //-----------------------------
                  //======INTERRUPTS AND PROC==========
                  //------On Match A Interrupt------
                  Keyboard_check_interrupt:
000ae7 9478       sei
000ae8 931f       push temp
000ae9 93df       push YH
000aea 93cf       push YL
                  
                 
000aeb e0d1       ldi YH,high(time_set_blink_count)
000aec e4c1       ldi YL,low(time_set_blink_count)
000aed 8118       ld temp,Y
000aee 9513       inc temp
000aef 8318       st Y,temp
                 
000af0 940e 0536  call time_set_blink
                 
000af2 931f
000af3 b310
000af4 631c
000af5 7f1b
000af6 bb12
000af7 9bb2
000af8 df90
000af9 9bb1
000afa dd5c
000afb 9bb0
000afc de09
000afd b310
000afe 631c
000aff 7f17
000b00 bb12
000b01 9bb2
000b02 dd33
000b03 9bb1
000b04 de43
000b05 9bb0
000b06 de70
000b07 b310
000b08 631c
000b09 7e1f
000b0a bb12
000b0b 9bb2
000b0c de1a
000b0d 9bb1
000b0e deaa
000b0f 9bb0
000b10 df57
000b11 b310
000b12 631c
000b13 7d1f
000b14 bb12
000b15 9bb2
000b16 de81
000b17 9bb1
000b18 df8f
000b19 9bb0
000b1a dfae
000b1b 911f       keyboard_check
                 
000b1c e0d1       ldi YH,high(sound_status)	//
000b1d e2c3       ldi YL,low(sound_status)	//get sound status in RAM
000b1e 8118       ld temp,Y					
000b1f ff10       sbrs temp, sound_general_status	//if sound is off then 
000b20 c00b       rjmp skip_A_addition				//OCIE1B interrupt will never happen
                 									//for prevent uncorrect timer work
                 									//I skip (OCR1A += 3125) if sound is off
                 
000b21 b5ca       in YL, OCR1AL
000b22 b5db       in YH, OCR1AH
000b23 e315       ldi temp,0x35
000b24 0fc1       add YL,temp		//OCR1A += 3125
000b25 e01c       ldi temp, 0x0C		//this need for correct work with keyboard
000b26 1fd1       adc YH,temp		//if sound enable
000b27 94f8       cli
000b28 bddb       out OCR1AH,YH
000b29 bdca       out OCR1AL,YL
000b2a 9478       sei
000b2b c006       rjmp continue_A_add	//jump over TCNT1 clear, because if sound is on
                 						//TCNT1 must be cleared in OCIE1B interrupt
                 
                  skip_A_addition:
                 
000b2c 27cc       clr YL
000b2d 27dd       clr YH
000b2e 94f8       cli
000b2f bddd       out TCNT1H,YH	//clear counter of timer1
000b30 bdcc       out TCNT1L,YL
000b31 9478       sei
                 
                  continue_A_add:
000b32 e0d1       ldi YH,high(tick_count)
000b33 e2c1       ldi YL,low(tick_count)
000b34 8118       ld temp,Y				//tick_count++
000b35 9513       inc temp
000b36 8318       st Y,temp	
                 
                  
000b37 91cf       pop YL
000b38 91df       pop YH
000b39 911f       pop temp
000b3a 9518       reti
                  //--------------------------------
                 //.include "softUART.inc"		//software UART
                 .include "UART.inc"
                 
                  * UART.inc
                  *
                  *  Created: 26.03.2016 0:01:18
                  *   Author: Hogs
                  */ 
                 
                 .equ baudrate = 9600
                 .equ bauddivider = XTAL / (16 * baudrate) - 1
                 
                 .equ TX_bs = 0	//0 is TX busy flag in UART_Status register
                 .equ RX_bs = 0	//0 is RX busy flag in UART_Status register
                 
                 //==========MACRO=========================
                 //-------- UART init ---------------------
                 .macro UART_init
                 /* Set baudrate */
                 ldi temp, low(bauddivider)
                 out UBRRL, temp
                 ldi temp, high(bauddivider)
                 out UBRRH, temp
                 
                 /* Set interrupts */
                 ldi temp, (1<<RXEN)|(1<<TXEN)
                 out UCSRB, temp	//RX and TX lines - enable, interrupts disable
                 
                 /* Set else */
                 clr temp
                 out UCSRA, temp
                 
                 ldi temp, (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0)
                 out UCSRC, temp
                 
                 .endm
                 //----------------------------------------
                 
                 //------- Clear TX buffer ----------------
                 .macro UART_clear_TX_buffer
                 push YH
                 push YL
                 push temp
                 push byte
                 
                 /* Clear buffer pointer */
                 clr temp	//temp = 0
                 sts UART_TX_byte_p, temp
                 
                 /* Clear buffer */
                 ldi YH, high(UART_TX_buffer)
                 ldi YL, low(UART_TX_buffer)	//load buffer adress
                 
                 clr temp	//temp = 0
                 clr byte	//byte = 0
                 
                 UART_clear_TX_loop:
                 st Y+, byte	//store 0
                 dec temp
                 brne UART_clear_TX_loop
                 
                 pop byte
                 pop temp
                 pop YL
                 pop YH
                 .endm
                 //----------------------------------------
                 
                 //------- Clear RX buffer ----------------
                 .macro UART_clear_RX_buffer
                 push YH
                 push YL
                 push temp
                 push byte
                 
                 /* Clear buffer pointer */
                 clr temp	//temp = 0
                 sts UART_RX_byte_p, temp
                 
                 /* Clear buffer */
                 ldi YH, high(UART_RX_buffer)
                 ldi YL, low(UART_RX_buffer)	//load buffer adress
                 
                 clr temp	//temp = 0
                 clr byte	//byte = 0
                 
                 UART_clear_RX_loop:
                 st Y+, byte	//store 0
                 dec temp
                 brne UART_clear_RX_loop
                 
                 pop byte
                 pop temp
                 pop YL
                 pop YH
                 .endm
                 //----------------------------------------
                 
                 //------ Start transmit ------------------
                 .macro UART_start_transmit
                 push YH
                 push YL
                 push byte
                 push temp
                 
                 /* Set TX_bs flag */
                 ldi YH, high(UART_Status)
                 ldi YL, low(UART_Status)
                 ld temp, Y
                 ori temp, (1<<TX_bs)
                 st Y, temp
                 
                 /* Set buffer pointer */
                 ldi YH, high(UART_TX_byte_p)
                 ldi YL, low(UART_TX_byte_p)
                 ldi temp, 1
                 st Y, temp	//set pointer as 1
                 
                 /* Load first byte */
                 ldi YH, high(UART_TX_buffer)
                 ldi YL, low(UART_TX_buffer)
                 ld byte, Y
                 
                 /* Send first byte and enable interrupts */
                 in temp, UCSRB
                 ori temp, (1<<UDRIE)|(1<<TXCIE)
                 out UDR, byte
                 out UCSRB, temp
                 
                 pop temp
                 pop byte
                 pop YL
                 pop YH
                 .endm
                 //----------------------------------------
                 
                 //------ Start receive ------------------
                 .macro UART_start_receive
                 push YH
                 push YL
                 push temp
                 
                 /* Set RX_bs flag */
                 ldi YH, high(UART_Status)
                 ldi YL, low(UART_Status)
                 ld temp, Y
                 ori temp, (1<<RX_bs)
                 st Y, temp
                 
                 /* Enable interrupts */
                 in temp, UCSRB
                 ori temp, (1<<RXCIE)
                 out UCSRB, temp
                 
                 pop temp
                 pop YL
                 pop YH
                 .endm
                 //----------------------------------------
                 
                 //------ Stop receive ------------------
                 .macro UART_stop_receive
                 push YH
                 push YL
                 push temp
                 
                 /* Disable interrupts */
                 in temp, UCSRB
                 andi temp, ~(1<<RXCIE)
                 out UCSRB, temp
                 
                 /* Clear RX_bs flag */
                 ldi YH, high(UART_Status)
                 ldi YL, low(UART_Status)
                 ld temp, Y
                 andi temp, ~(1<<RX_bs)
                 st Y, temp
                 
                 pop temp
                 pop YL
                 pop YH
                 .endm
                 //----------------------------------------
                 //========================================
                 
                 //=============INTERRUPTS=================
                 //-------- UDR empty interrupt -----------
                 UART_transmit:
000b3b 93df      push YH
000b3c 93cf      push YL
000b3d 931f      push temp
000b3e 930f      push byte
                 
                 /* read buffer pointer */
000b3f e0d3      ldi YH, high(UART_TX_byte_p)
000b40 e4c4      ldi YL, low(UART_TX_byte_p)
000b41 8118      ld temp, Y
                 
                 /* read byte from buffer */
000b42 e0d1      ldi YH, high(UART_TX_buffer)
000b43 e4c2      ldi YL, low(UART_TX_buffer)	//load buffer adress
                 
000b44 0fc1      add YL,temp
000b45 2711      clr temp		//add offset
000b46 1fd1      adc YH,temp
                 
000b47 8108      ld byte, Y
                 
                 /* check for end */
000b48 3000      cpi byte, 0
000b49 f039      breq UART_stop_transmit	//return if end of string
                 
000b4a b90c      out UDR, byte	//send byte
                 
                 /* inc pointer */
000b4b e0d3      ldi YH, high(UART_TX_byte_p)
000b4c e4c4      ldi YL, low(UART_TX_byte_p)
000b4d 8118      ld temp, Y
000b4e 9513      inc temp
000b4f 8318      st Y, temp
000b50 c008      rjmp UART_return_transmit
                 
                 /* Stop transmit */
                 UART_stop_transmit:
                 
                 /* Disable interrupts */
000b51 b11a      in temp, UCSRB
000b52 791f      andi temp, ~((1<<UDRIE)|(1<<TXCIE))
000b53 b91a      out UCSRB, temp
                 
                 /* Clear TX_bs flag */
000b54 e0d3      ldi YH, high(UART_Status)
000b55 e4c6      ldi YL, low(UART_Status)
000b56 8118      ld temp, Y
000b57 7f1e      andi temp, ~(1<<TX_bs)
000b58 8318      st Y, temp
                 
                 /* return */
                 UART_return_transmit:
                 
000b59 910f      pop byte
000b5a 911f      pop temp
000b5b 91cf      pop YL
000b5c 91df      pop YH
000b5d 9518      reti
                 //----------------------------------------
                 
                 //------- End transmit (TX interrupt) ----
                 /*UART_end_transmit:
                 push YH
                 push YL
                 push temp
                 
                 // Disable interrupts
                 in temp, UCSRB
                 andi temp, ~((1<<UDRIE)|(1<<TXCIE))
                 out UCSRB, temp
                 
                 // Clear TX_bs flag
                 ldi YH, high(UART_Status)
                 ldi YL, low(UART_Status)
                 ld temp, Y
                 andi temp, ~(1<<TX_bs)
                 st Y, temp
                 
                 pop temp
                 pop YL
                 pop YH
                 reti*/
                 //----------------------------------------
                 
                 //------- Receive (RX interrupt) ---------
                 UART_receive:
000b5e 93df      push YH
000b5f 93cf      push YL
000b60 931f      push temp
000b61 930f      push byte
                 
000b62 b10c      in byte, UDR	//read received byte
                 
                 /* read buffer pointer */
000b63 e0d3      ldi YH, high(UART_RX_byte_p)
000b64 e4c5      ldi YL, low(UART_RX_byte_p)
000b65 8118      ld temp, Y
                 
                 /* Store byte to buffer */
000b66 e0d2      ldi YH, high(UART_RX_buffer)
000b67 e4c3      ldi YL, low(UART_RX_buffer)	//load buffer adress
                 
000b68 0fc1      add YL, temp
000b69 2711      clr temp		//add offset
000b6a 1fd1      adc YH, temp
                 
000b6b 8308      st Y, byte	//store byte
                 
                 /* inc pointer */
000b6c e0d3      ldi YH, high(UART_RX_byte_p)
000b6d e4c5      ldi YL, low(UART_RX_byte_p)
000b6e 8118      ld temp, Y
000b6f 9513      inc temp
000b70 8318      st Y, temp
                 
                 /* return */
000b71 910f      pop byte
000b72 911f      pop temp
000b73 91cf      pop YL
000b74 91df      pop YH
000b75 9518      reti
                 //----------------------------------------
                 .include "strings.inc"
                 
                  * strings.inc
                  *
                  *  Created: 27.03.2016 4:27:29
                  *   Author: Hogs
                  */ 
                 
                  .def counter = r19
                  //===== PROCEDURES =======================
                  //------ Search ---------------
                  str_search_proc:
                  // input X (string where need to search)
                  // input Y (substring)
                  // output R17(0 or 1) 1 is string found, 0 is string not found
                  // output R16(byte pointer to first symbol)
000b76 933f       push counter
000b77 93bf       push XH
000b78 93af       push XL
000b79 930f       push byte
                 
000b7a 2733       clr counter
000b7b 2711       clr temp
                 
                  str_search_loop:
000b7c 910c       ld byte, X
000b7d 3000       cpi byte, 0
000b7e f069       breq str_search_return_false
                 
000b7f d012       rcall str_cmp_proc
000b80 3010       cpi temp, 0
000b81 f419       brne str_search_return_true
                 
000b82 9533       inc counter
000b83 9611       adiw XH:XL, 1
000b84 cff7       rjmp str_search_loop
                 
                  str_search_return_true:
000b85 910f       pop byte
000b86 91af       pop XL
000b87 91bf       pop XH
000b88 2f03       mov r16, counter
000b89 913f       pop counter
000b8a e011       ldi r17, 1
000b8b 9508       ret
                 
                  str_search_return_false:
000b8c 910f       pop byte
000b8d 91af       pop XL
000b8e 91bf       pop XH
000b8f 913f       pop counter
000b90 2711       clr r17
000b91 9508       ret
                  //-----------------------------
                 
                  //----- String compare --------
                  str_cmp_proc:
                  //input Y - first (shorter) string
                  //input X - second (longer) string
                  //output r17 - result (0 - false, 1 - true)
000b92 93bf       push XH
000b93 93af       push XL
000b94 93df       push YH
000b95 93cf       push YL
000b96 930f       push byte
                 
                  str_cmp_loop:
000b97 8108       ld byte, Y
000b98 3000       cpi byte, 0
000b99 f069       breq str_cmp_return_true
                 
000b9a 911c       ld temp, X
000b9b 1701       cp byte, temp
000b9c f419       brne str_cmp_return_false
                 
000b9d 9611       adiw XH:XL, 1
000b9e 9621       adiw YH:YL, 1
000b9f cff7       rjmp str_cmp_loop
                 
                  str_cmp_return_false:
000ba0 910f       pop byte
000ba1 91cf       pop YL
000ba2 91df       pop YH
000ba3 91af       pop XL
000ba4 91bf       pop XH
000ba5 2711       clr temp
000ba6 9508       ret
                  str_cmp_return_true:
000ba7 910f       pop byte
000ba8 91cf       pop YL
000ba9 91df       pop YH
000baa 91af       pop XL
000bab 91bf       pop XH
000bac e011       ldi temp, 1
000bad 9508       ret
                  //-----------------------------
                 
                  //-------- str len ------------
                  str_len_proc:
                  //input X - adress of string
                  //output r17 - length
000bae 930f       push byte
000baf 93bf       push XH
000bb0 93af       push XL
000bb1 2711       clr temp
                 
                  str_len_loop:
000bb2 910d       ld byte, X+
000bb3 3000       cpi byte, 0
000bb4 f011       breq str_len_return
                 
000bb5 9513       inc temp
000bb6 cffb       rjmp str_len_loop
                 
                  str_len_return:
000bb7 91af       pop XL
000bb8 91bf       pop XH
000bb9 910f       pop byte
000bba 9508       ret
                  //-----------------------------
                 
                  //-------- str concat ---------
                  str_concat_proc:
                  //input X - string 1
                  //input Y - string 2
                  //no output
                  //result is: str1 = str1+str2
000bbb 931f       push temp
000bbc 93bf       push XH
000bbd 93af       push XL
000bbe 93df       push YH
000bbf 93cf       push YL
                 
000bc0 dfed       rcall str_len_proc
000bc1 0fa1       add XL, temp
000bc2 2711       clr temp			//set X as end of first string
000bc3 1fb1       adc XH, temp
                 
                 
                  str_concat_loop:
000bc4 9119       ld temp, Y+
000bc5 1710       cp temp, byte
000bc6 f011       breq str_concat_return
                 
000bc7 931d       st X+, temp
000bc8 cffb       rjmp str_concat_loop
                 
                  str_concat_return:
000bc9 91cf       pop YL
000bca 91df       pop YH
000bcb 91af       pop XL
000bcc 91bf       pop XH
000bcd 911f       pop temp
000bce 9508       ret
                  //---------------------------
                 
                  //------ Clear string -------
                  str_clr_proc:
                  //input X - string what need to clear
                  //no output
                 
000bcf 931f       push temp
000bd0 93bf       push XH
000bd1 93af       push XL
                 
                  str_clr_loop:
000bd2 911d       ld temp, X+
000bd3 3010       cpi temp, 0
000bd4 f019       breq str_clr_return
                 
000bd5 2711       clr temp
000bd6 931c       st X, temp
000bd7 cffa       rjmp str_clr_loop
                 
                  str_clr_return:
000bd8 91af       pop XL
000bd9 91bf       pop XH
000bda 911f       pop temp
000bdb 9508       ret
                  //---------------------------
                 
                  //------ String copy --------
                  str_cpy_proc:
                  //input X - string which need to copy
                  //input Y - string where need to paste
                  //input r16 - end of string symbol
                  //no output
000bdc 93bf       push XH
000bdd 93af       push XL
000bde 93df       push YH
000bdf 93cf       push YL
000be0 931f       push temp
                 
                  str_cpy_loop:
000be1 911d       ld temp, X+
000be2 1710       cp temp, byte
000be3 f011       breq str_cpy_return
                 
000be4 9319       st Y+, temp
000be5 cffb       rjmp str_cpy_loop
                 
                  str_cpy_return:
000be6 911f       pop temp
000be7 91cf       pop YL
000be8 91df       pop YH
000be9 91af       pop XL
000bea 91bf       pop XH
000beb 9508       ret
                  //---------------------------
                 
                  //------ String copy (using length) ---
                  str_cpy_proc_len:
                  //input X - string which need to copy
                  //input Y - string where need to paste
                  //input r16 - count of symbols
                  //no output
000bec 93bf       push XH
000bed 93af       push XL
000bee 93df       push YH
000bef 93cf       push YL
000bf0 931f       push temp
                 
                  str_cpy_len_loop:
000bf1 911d       ld temp, X+
000bf2 950a       dec byte
000bf3 f011       breq str_cpy_len_return
                 
000bf4 9319       st Y+, temp
000bf5 cffb       rjmp str_cpy_len_loop
                 
                  str_cpy_len_return:
000bf6 911f       pop temp
000bf7 91cf       pop YL
000bf8 91df       pop YH
000bf9 91af       pop XL
000bfa 91bf       pop XH
000bfb 9508       ret
                  //---------------------------
                  //========================================
                 
                  //======= MACRO ==========================
                  //----- String search --------------------
                  .macro str_search
                  // input @0 (string where need to search)
                  // input @1 (substring)
                  // output R17(0 or 1) 1 is string found, 0 is string not found
                  // output R16(byte pointer to first symbol)
                  push XH
                  push XL
                  push YH
                  push YL
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  ldi YH, high(@1)
                  ldi YL, low(@1)
                  call str_search_proc
                 
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //----- String Compare -------------------
                  .macro str_cmp
                  push XH
                  push XL
                  push YH
                  push YL
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  ldi YH, high(@1)
                  ldi YL, low(@1)
                  rcall str_cmp_proc
                 
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //----- String length --------------------
                  .macro str_len
                  //input - @0 adress of string
                  //output - r17 - length
                  push XH
                  push XL
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  rcall str_len_proc
                 
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //----- String concatenation -------------
                  .macro str_concat
                  //input @0 - adress of first string
                  //input @1 - adress of second string
                  //no output
                  //result is: str1 = str1+str2
                  
                  push XH
                  push XL
                  push YH
                  push YL
                  push byte
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  ldi YH, high(@1)
                  ldi YL, low(@1)
                  clr byte
                 
                  call str_concat_proc
                 
                  pop byte
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //----- Extended string concatenation -------------
                  .macro str_concat_ex
                  //input @0 - adress of first string
                  //input @1 - adress of second string
                  //no output
                  //result is: str1 = str1+str2
                  
                  push XH
                  push XL
                  push YH
                  push YL
                  push byte
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  ldi YH, high(@1)
                  ldi YL, low(@1)
                  ldi byte, @2
                 
                  call str_concat_proc
                 
                  pop byte
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //------ Clear string --------------------
                  .macro str_clr
                  //input @0 - string adress what need to clear
                  //no output
                  push XH
                  push XL
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  rcall str_clr_proc
                 
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //------ string copy ---------------------
                  .macro str_cpy
                  //input @0 - string which need to copy
                  //input @1 - string where need to paste
                  //no output
                  push XH
                  push XL
                  push YH
                  push YL
                  push byte
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  ldi YH, high(@1)
                  ldi YL, low(@1)
                  clr byte
                  call str_cpy_proc
                 
                  pop byte
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //------ extended string copy ------------
                  .macro str_cpy_ex
                  //input @0 - string which need to copy
                  //input @1 - string where need to paste
                  //input @2 - end of string symbol
                  //no output
                  push XH
                  push XL
                  push YH
                  push YL
                  push byte
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  ldi YH, high(@1)
                  ldi YL, low(@1)
                  ldi byte, @2
                  rcall str_cpy_proc
                 
                  pop byte
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                  //----------------------------------------
                 
                  //------ (using length) string copy ------------
                  .macro str_cpy_len
                  //input @0 - string which need to copy
                  //input @1 - string where need to paste
                  //input @2 - count of symbols
                  //no output
                  push XH
                  push XL
                  push YH
                  push YL
                  push byte
                 
                  ldi XH, high(@0)
                  ldi XL, low(@0)
                  ldi YH, high(@1)
                  ldi YL, low(@1)
                  ldi byte, @2
                  rcall str_cpy_proc_len
                 
                  pop byte
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                 .include "GSM.inc"
                 
                  * GSM.inc
                  *
                  *  Created: 30.03.2016 0:25:56
                  *   Author: Hogs
                  */ 
                 
                  .equ GS = 3		//get/set flag in GSM_Status register (1 - get, 0 - set)
                 
                  //======= MACRO ================================
                  //------- Copy index to RAM --------------------
                  .macro GSM_copy_index
                 
                  ldi XH, high(UART_RX_buffer)
                  ldi XL, low(UART_RX_buffer)
                  add XL, byte
                  push byte
                  clr byte
                  adc XH, byte
                  pop byte
                  adiw XH:XL, 12
                  ldi YH, high(GSM_sms_index)
                  ldi YL, low(GSM_sms_index)
                  ldi byte, 0x0D
                  rcall str_cpy_proc
                 
                  .endm
                  //----------------------------------------------
                 
                  //------- Copy phone number to RAM -------------
                  .macro GSM_copy_phone_number
                 
                  ldi XH, high(UART_RX_buffer)
                  ldi XL, low(UART_RX_buffer)
                  add XL, byte
                  push byte
                  clr byte
                  adc XH, byte
                  pop byte
                  adiw XH:XL, 2
                  ldi YH, high(GSM_phone_number)
                  ldi YL, low(GSM_phone_number)
                  ldi byte, ','
                  rcall str_cpy_proc
                 
                  .endm
                  //----------------------------------------------
                 
                  //------- Set New Time -------------------------
                  .macro GSM_set_new_time
                 
                  push XH
                  push XL
                  push YH
                  push YL
                  push temp
                  push byte
                 
                  push XH
                  push XL
                  push YH
                  push YL
                  push byte
                 
                  mov XH, YH
                  mov XL, YL
                  ldi YH, high(time_value)
                  ldi YL, low(time_value)
                  ldi byte, 14
                  rcall str_cpy_proc_len
                 
                  pop byte
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                 
                  ldi XH, high(I2C_buffer)
                  ldi XL, low(I2C_buffer)
                  
                  ldi temp, 5
                  GSM_set_new_time_loop:
                  push temp
                 
                  ld temp, Y+
                  subi temp, 48
                  swap temp
                 
                  ld byte, Y+
                  subi byte, 48
                 
                  or temp, byte
                  st X+, temp
                 
                  adiw YH:YL, 1
                 
                  pop temp
                  dec temp
                  brne GSM_set_new_time_loop
                 
                  call I2C_Clock_Set_New_Time
                 
                  pop byte
                  pop temp
                  pop YL
                  pop YH
                  pop XL
                  pop XH
                  .endm
                  //--------------------------------------------
                 
                  //--------- GSM init -------------------------
                  .macro GSM_init
                 
                  call GSM_init_strings
                 
                  UART_clear_TX_buffer	//Clear TX buffer
                  UART_start_receive
                 
                  str_concat UART_TX_buffer, GSM_CSQ
                  UART_start_transmit
                  
                  delay 255,255,255
                  //??????????????????????????????????????????????????//
                  delay 255,255,255
                  delay 255,255,255
                  str_search UART_RX_buffer, GSM_result
                  cpi temp, 1
                  brne dbg_1
                  dbg
                  dbg_1:
                 
                  //?????????????????????????????????????????????????????????
                  UART_clear_RX_buffer
                  UART_clear_TX_buffer
                 
                  UART_start_receive
                  .endm
                  //--------------------------------------------
                 
                  //------- main -------------------------------
                  //.macro GSM_main
                  GSM_main:
000bfc 93df
000bfd 93cf
000bfe 931f
000bff e0d3
000c00 e4c6
000c01 8118
000c02 6011
000c03 8318
000c04 b11a
000c05 6810
000c06 b91a
000c07 911f
000c08 91cf
000c09 91df       UART_start_receive
                 
                  /*UART_clear_TX_buffer
                  str_concat UART_TX_buffer, GSM_CSQ
                  UART_start_transmit
                  
                  delay 255,255,255
                  delay 255,255,255
                  delay 255,255,255
                  UART_clear_TX_buffer
                 
                  str_search UART_RX_buffer, GSM_result
                  cpi temp, 1
                  brne dbg_1
                  dbg
                  dbg_1:*/
                  /* check for new SMS */ 
                 
                  
000c0a 93bf
000c0b 93af
000c0c 93df
000c0d 93cf
000c0e e0b2
000c0f e4a3
000c10 e0d3
000c11 e4c8
000c12 940e 0b76
000c14 91cf
000c15 91df
000c16 91af
000c17 91bf       str_search UART_RX_buffer, GSM_new_msg
000c18 3010       cpi temp, 0
000c19 f409       brne PC+2 
000c1a 940c 13e9  jmp GSM_return	//if no new SMS found return
                 
000c1c 9a97
000c1d 939f
000c1e 938f
000c1f 937f
000c20 e592
000c21 e28b
000c22 e47d
000c23 940e 0029
000c25 917f
000c26 918f
000c27 919f
000c28 9897
000c29 939f
000c2a 938f
000c2b 937f
000c2c e592
000c2d e28b
000c2e e47d
000c2f 940e 0029
000c31 917f
000c32 918f
000c33 919f       dbg
                 
000c34 e0b2
000c35 e4a3
000c36 0fa0
000c37 930f
000c38 2700
000c39 1fb0
000c3a 910f
000c3b 961c
000c3c e0d4
000c3d edc6
000c3e e00d
000c3f df9c       GSM_copy_index		//copy index to RAM
                 
                  /* read message */
                  GSM_restart:
000c40 93df
000c41 93cf
000c42 931f
000c43 930f
000c44 2711
000c45 9310 0345
000c47 e0d2
000c48 e4c3
000c49 2711
000c4a 2700
000c4b 9309
000c4c 951a
000c4d f7e9
000c4e 910f
000c4f 911f
000c50 91cf
000c51 91df       UART_clear_RX_buffer
000c52 93df
000c53 93cf
000c54 931f
000c55 930f
000c56 2711
000c57 9310 0344
000c59 e0d1
000c5a e4c2
000c5b 2711
000c5c 2700
000c5d 9309
000c5e 951a
000c5f f7e9
000c60 910f
000c61 911f
000c62 91cf
000c63 91df       UART_clear_TX_buffer	//Clear TX buffer
                 
000c64 93bf
000c65 93af
000c66 93df
000c67 93cf
000c68 930f
000c69 e0b1
000c6a e4a2
000c6b e0d3
000c6c e5c5
000c6d 2700
000c6e 940e 0bbb
000c70 910f
000c71 91cf
000c72 91df
000c73 91af
000c74 91bf       str_concat UART_TX_buffer, GSM_read_SMS1
000c75 93bf
000c76 93af
000c77 93df
000c78 93cf
000c79 930f
000c7a e0b1
000c7b e4a2
000c7c e0d4
000c7d edc6
000c7e 2700
000c7f 940e 0bbb
000c81 910f
000c82 91cf
000c83 91df
000c84 91af
000c85 91bf       str_concat UART_TX_buffer, GSM_sms_index	//prepare TX buffer
000c86 93bf
000c87 93af
000c88 93df
000c89 93cf
000c8a 930f
000c8b e0b1
000c8c e4a2
000c8d e0d3
000c8e e5ce
000c8f 2700
000c90 940e 0bbb
000c92 910f
000c93 91cf
000c94 91df
000c95 91af
000c96 91bf       str_concat UART_TX_buffer, GSM_read_SMS2
000c97 93bf
000c98 93af
000c99 93df
000c9a 93cf
000c9b 930f
000c9c e0b1
000c9d e4a2
000c9e e0d3
000c9f e6cf
000ca0 2700
000ca1 940e 0bbb
000ca3 910f
000ca4 91cf
000ca5 91df
000ca6 91af
000ca7 91bf       str_concat UART_TX_buffer, GSM_enter
                 
                  //dbg
                 
000ca8 93df
000ca9 93cf
000caa 930f
000cab 931f
000cac e0d3
000cad e4c6
000cae 8118
000caf 6011
000cb0 8318
000cb1 e0d3
000cb2 e4c4
000cb3 e011
000cb4 8318
000cb5 e0d1
000cb6 e4c2
000cb7 8108
000cb8 b11a
000cb9 6610
000cba b90c
000cbb b91a
000cbc 911f
000cbd 910f
000cbe 91cf
000cbf 91df       UART_start_transmit 
000cc0 93df
000cc1 93cf
000cc2 931f
000cc3 e0d3
000cc4 e4c6
000cc5 8118
000cc6 6011
000cc7 8318
000cc8 b11a
000cc9 6810
000cca b91a
000ccb 911f
000ccc 91cf
000ccd 91df       UART_start_receive
                 
                  //dbg
                 
                  /* wait for operation result */
000cce 939f
000ccf 938f
000cd0 937f
000cd1 ef9f
000cd2 ef8f
000cd3 ef7f
000cd4 940e 0029
000cd6 917f
000cd7 918f
000cd8 919f       delay 255,255,255		//long delay
000cd9 939f
000cda 938f
000cdb 937f
000cdc ef9f
000cdd ef8f
000cde ef7f
000cdf 940e 0029
000ce1 917f
000ce2 918f
000ce3 919f       delay 255,255,255
000ce4 939f
000ce5 938f
000ce6 937f
000ce7 ef9f
000ce8 ef8f
000ce9 ef7f
000cea 940e 0029
000cec 917f
000ced 918f
000cee 919f       delay 255,255,255
000cef 939f
000cf0 938f
000cf1 937f
000cf2 ef9f
000cf3 ef8f
000cf4 ef7f
000cf5 940e 0029
000cf7 917f
000cf8 918f
000cf9 919f       delay 255,255,255
000cfa 939f
000cfb 938f
000cfc 937f
000cfd ef9f
000cfe ef8f
000cff ef7f
000d00 940e 0029
000d02 917f
000d03 918f
000d04 919f       delay 255,255,255
000d05 939f
000d06 938f
000d07 937f
000d08 ef9f
000d09 ef8f
000d0a ef7f
000d0b 940e 0029
000d0d 917f
000d0e 918f
000d0f 919f       delay 255,255,255		//about 6 sec on 16MHz or 12sec on 8MHz
                  //UART_stop_receive
000d10 93bf
000d11 93af
000d12 93df
000d13 93cf
000d14 e0b2
000d15 e4a3
000d16 e0d3
000d17 e6c1
000d18 940e 0b76
000d1a 91cf
000d1b 91df
000d1c 91af
000d1d 91bf       str_search UART_RX_buffer, GSM_result
000d1e 3010       cpi temp, 0
000d1f f409       brne PC+2
000d20 cf1f       rjmp GSM_restart		//if no OK result then restart
                 
                  
000d21 93bf
000d22 93af
000d23 93df
000d24 93cf
000d25 e0b2
000d26 e4a3
000d27 e0d3
000d28 e7c3
000d29 940e 0b76
000d2b 91cf
000d2c 91df
000d2d 91af
000d2e 91bf       str_search UART_RX_buffer, GSM_phone_start
000d2f 3010       cpi temp, 0
000d30 f409       brne PC+2
000d31 cf0e       rjmp GSM_restart	//if no new SMS found restart
                  
000d32 e0b2
000d33 e4a3
000d34 0fa0
000d35 930f
000d36 2700
000d37 1fb0
000d38 910f
000d39 9612
000d3a e0d4
000d3b edc9
000d3c e20c
000d3d de9e       GSM_copy_phone_number
                 
                  /* check for commands */
000d3e 93bf
000d3f 93af
000d40 93df
000d41 93cf
000d42 e0b2
000d43 e4a3
000d44 e0d3
000d45 e7c6
000d46 940e 0b76
000d48 91cf
000d49 91df
000d4a 91af
000d4b 91bf       str_search UART_RX_buffer, GSM_get_cmd
000d4c 3010       cpi temp, 0
000d4d f499       brne GSM_get_parameter
                 
000d4e 93bf
000d4f 93af
000d50 93df
000d51 93cf
000d52 e0b2
000d53 e4a3
000d54 e0d3
000d55 e8c1
000d56 940e 0b76
000d58 91cf
000d59 91df
000d5a 91af
000d5b 91bf       str_search UART_RX_buffer, GSM_set_cmd
000d5c 3010       cpi temp, 0
000d5d f009       breq PC+2
000d5e c08a       rjmp GSM_set_parameter
000d5f 940c 13e9  jmp GSM_return
                 
                  GSM_get_parameter:
000d61 e0d3       ldi YH, high(GSM_Status)
000d62 e4c7       ldi YL, low(GSM_Status)
000d63 e018       ldi temp, 1<<GS									//set GS flag as 1 (get)
000d64 8318       st Y, temp
                  
000d65 93bf
000d66 93af
000d67 93df
000d68 93cf
000d69 e0b2
000d6a e4a3
000d6b e0d3
000d6c e8cc
000d6d 940e 0b76
000d6f 91cf
000d70 91df
000d71 91af
000d72 91bf       str_search UART_RX_buffer, GSM_info_parameter		//search for "info" parameter
000d73 3010       cpi temp, 0
000d74 f031       breq GSM_search_time_get_parameter
                 
000d75 e0d3       ldi YH, high(GSM_Status)
000d76 e4c7       ldi YL, low(GSM_Status)
000d77 8118       ld temp, Y
000d78 6011       ori temp, 1
000d79 8318       st Y, temp
000d7a c17a       rjmp GSM_send_SMS_command
                 
                  GSM_search_time_get_parameter:
000d7b 93bf
000d7c 93af
000d7d 93df
000d7e 93cf
000d7f e0b2
000d80 e4a3
000d81 e0d3
000d82 e9c1
000d83 940e 0b76
000d85 91cf
000d86 91df
000d87 91af
000d88 91bf       str_search UART_RX_buffer, GSM_time_parameter		//search for "time" parameter
000d89 3010       cpi temp, 0
000d8a f031       breq GSM_search_temp_get_parameter
                 
000d8b e0d3       ldi YH, high(GSM_Status)
000d8c e4c7       ldi YL, low(GSM_Status)
000d8d 8118       ld temp, Y
000d8e 6012       ori temp, 2
000d8f 8318       st Y, temp
000d90 c164       rjmp GSM_send_SMS_command
                 
                  GSM_search_temp_get_parameter:
000d91 93bf
000d92 93af
000d93 93df
000d94 93cf
000d95 e0b2
000d96 e4a3
000d97 e0d3
000d98 e9c6
000d99 940e 0b76
000d9b 91cf
000d9c 91df
000d9d 91af
000d9e 91bf       str_search UART_RX_buffer, GSM_temp_parameter		//search for "temp" parameter
000d9f 3010       cpi temp, 0
000da0 f031       breq GSM_search_pressure_get_parameter
                 
000da1 e0d3       ldi YH, high(GSM_Status)
000da2 e4c7       ldi YL, low(GSM_Status)
000da3 8118       ld temp, Y
000da4 6013       ori temp, 3
000da5 8318       st Y, temp
000da6 c14e       rjmp GSM_send_SMS_command
                 
                  GSM_search_pressure_get_parameter:
000da7 93bf
000da8 93af
000da9 93df
000daa 93cf
000dab e0b2
000dac e4a3
000dad e0d3
000dae e9cb
000daf 940e 0b76
000db1 91cf
000db2 91df
000db3 91af
000db4 91bf       str_search UART_RX_buffer, GSM_pressure_parameter	//search for "pressure" parameter
000db5 3010       cpi temp, 0
000db6 f031       breq GSM_search_sound_get_parameter
                 
000db7 e0d3       ldi YH, high(GSM_Status)
000db8 e4c7       ldi YL, low(GSM_Status)
000db9 8118       ld temp, Y
000dba 6014       ori temp, 4
000dbb 8318       st Y, temp
000dbc c138       rjmp GSM_send_SMS_command
                 
                  GSM_search_sound_get_parameter:
000dbd 93bf
000dbe 93af
000dbf 93df
000dc0 93cf
000dc1 e0b2
000dc2 e4a3
000dc3 e0d3
000dc4 eac4
000dc5 940e 0b76
000dc7 91cf
000dc8 91df
000dc9 91af
000dca 91bf       str_search UART_RX_buffer, GSM_sound_parameter		//search for "sound" parameter
000dcb 3010       cpi temp, 0
000dcc f031       breq GSM_search_memory_get_parameter
                 
000dcd e0d3       ldi YH, high(GSM_Status)
000dce e4c7       ldi YL, low(GSM_Status)
000dcf 8118       ld temp, Y
000dd0 6015       ori temp, 5
000dd1 8318       st Y, temp
000dd2 c122       rjmp GSM_send_SMS_command
                 
                  GSM_search_memory_get_parameter:
000dd3 93bf
000dd4 93af
000dd5 93df
000dd6 93cf
000dd7 e0b2
000dd8 e4a3
000dd9 e0d3
000dda eaca
000ddb 940e 0b76
000ddd 91cf
000dde 91df
000ddf 91af
000de0 91bf       str_search UART_RX_buffer, GSM_memory_parameter	//search for "memory" parameter
000de1 3010       cpi temp, 0
000de2 f029       breq GSM_search_unsupported_get_parameter
                 
000de3 e0d3       ldi YH, high(GSM_Status)
000de4 e4c7       ldi YL, low(GSM_Status)
000de5 8118       ld temp, Y
000de6 6016       ori temp, 6
000de7 8318       st Y, temp
                 
                  GSM_search_unsupported_get_parameter:				//unsupported parameter
000de8 c10c       rjmp GSM_send_SMS_command
                 
                 
                  GSM_set_parameter:
000de9 e0d3       ldi YH, high(GSM_Status)
000dea e4c7       ldi YL, low(GSM_Status)
000deb 2711       clr temp
000dec 8318       st Y, temp
                 
000ded 93bf
000dee 93af
000def 93df
000df0 93cf
000df1 e0b2
000df2 e4a3
000df3 e0d3
000df4 e9c1
000df5 940e 0b76
000df7 91cf
000df8 91df
000df9 91af
000dfa 91bf       str_search UART_RX_buffer, GSM_time_parameter		//search for "time" parameter
000dfb 3010       cpi temp, 0
000dfc f409       brne PC+2
000dfd c046       rjmp GSM_search_sound_set_parameter
                 
000dfe 931f       push temp
000dff e015       ldi temp, 5
000e00 0f01       add byte, temp
000e01 911f       pop temp
000e02 e0d2       ldi YH, high(UART_RX_buffer)
000e03 e4c3       ldi YL, low(UART_RX_buffer)
000e04 0fc0       add YL, byte
000e05 2700       clr byte
000e06 1fd0       adc YH, byte
                 
000e07 940e 142b  call GSM_time_validate
000e09 3010       cpi temp, 0
000e0a f199       breq GSM_set_time_error
                 
000e0b 93bf
000e0c 93af
000e0d 93df
000e0e 93cf
000e0f 931f
000e10 930f
000e11 93bf
000e12 93af
000e13 93df
000e14 93cf
000e15 930f
000e16 2fbd
000e17 2fac
000e18 e0d0
000e19 eec0
000e1a e00e
000e1b ddd0
000e1c 910f
000e1d 91cf
000e1e 91df
000e1f 91af
000e20 91bf
000e21 e0b1
000e22 e2a5
000e23 e015
000e24 931f
000e25 9119
000e26 5310
000e27 9512
000e28 9109
000e29 5300
000e2a 2b10
000e2b 931d
000e2c 9621
000e2d 911f
000e2e 951a
000e2f f7a1
000e30 940e 04cf
000e32 910f
000e33 911f
000e34 91cf
000e35 91df
000e36 91af
000e37 91bf       GSM_set_new_time
                 
000e38 e0d3       ldi YH, high(GSM_Status)
000e39 e4c7       ldi YL, low(GSM_Status)
000e3a 8118       ld temp, Y
000e3b 6012       ori temp, 2
000e3c 8318       st Y, temp
000e3d c0b7       rjmp GSM_send_SMS_command
                 
                  GSM_set_time_error:
000e3e e0d3       ldi YH, high(GSM_Status)
000e3f e4c7       ldi YL, low(GSM_Status)
000e40 8118       ld temp, Y
000e41 6110       ori temp, 0b0001_0000
000e42 8318       st Y, temp
000e43 c0b1       rjmp GSM_send_SMS_command
                 
                  GSM_search_sound_set_parameter:
000e44 93bf
000e45 93af
000e46 93df
000e47 93cf
000e48 e0b2
000e49 e4a3
000e4a e0d3
000e4b eac4
000e4c 940e 0b76
000e4e 91cf
000e4f 91df
000e50 91af
000e51 91bf       str_search UART_RX_buffer, GSM_sound_parameter		//search for "sound" parameter
000e52 3010       cpi temp, 0
000e53 f409       brne PC+2
000e54 c048       rjmp GSM_search_memory_set_parameter
                 
000e55 931f       push temp
000e56 e016       ldi temp, 6
000e57 0f01       add byte, temp
000e58 911f       pop temp
000e59 e0d2       ldi YH, high(UART_RX_buffer)
000e5a e4c3       ldi YL, low(UART_RX_buffer)
000e5b 0fc0       add YL, byte
000e5c 2700       clr byte
000e5d 1fd0       adc YH, byte
                 
000e5e 940e 1472  call GSM_OnOff_Validate
000e60 3010       cpi temp, 0
000e61 f1a9       breq GSM_set_sound_error
                 
000e62 9621       adiw YH:YL, 1
000e63 8118       ld temp, Y
000e64 3416       cpi temp, 'F'
000e65 f0b1       breq GSM_set_sound_off
                 
000e66 e0d4       ldi YH,high(Sound_Settings)
000e67 eeca       ldi YL,low(Sound_Settings) 
000e68 e011       ldi temp, 1
000e69 8318       st Y, temp
000e6a 93bf
000e6b 93af
000e6c 93df
000e6d 93cf
000e6e 930f
000e6f e0b4
000e70 e4a6
000e71 e0d1
000e72 e1c0
000e73 2700
000e74 940e 0bdc
000e76 910f
000e77 91cf
000e78 91df
000e79 91af
000e7a 91bf       str_cpy On_str, sound_value
000e7b c015       rjmp GSM_set_sound_return
                 
                  GSM_set_sound_off:
000e7c e0d4       ldi YH,high(Sound_Settings)
000e7d eeca       ldi YL,low(Sound_Settings) 
000e7e e010       ldi temp, 0
000e7f 8318       st Y, temp
000e80 93bf
000e81 93af
000e82 93df
000e83 93cf
000e84 930f
000e85 e0b4
000e86 e4aa
000e87 e0d1
000e88 e1c0
000e89 2700
000e8a 940e 0bdc
000e8c 910f
000e8d 91cf
000e8e 91df
000e8f 91af
000e90 91bf       str_cpy Off_str, sound_value
                 
                  GSM_set_sound_return:
000e91 e0d3       ldi YH, high(GSM_Status)
000e92 e4c7       ldi YL, low(GSM_Status)
000e93 8118       ld temp, Y
000e94 6015       ori temp, 5
000e95 8318       st Y, temp
000e96 c05e       rjmp GSM_send_SMS_command
                 
                  GSM_set_sound_error:
000e97 e0d3       ldi YH, high(GSM_Status)
000e98 e4c7       ldi YL, low(GSM_Status)
000e99 8118       ld temp, Y
000e9a 6210       ori temp, 0b0010_0000
000e9b 8318       st Y, temp
000e9c c058       rjmp GSM_send_SMS_command
                 
                  GSM_search_memory_set_parameter:
000e9d 93bf
000e9e 93af
000e9f 93df
000ea0 93cf
000ea1 e0b2
000ea2 e4a3
000ea3 e0d3
000ea4 eaca
000ea5 940e 0b76
000ea7 91cf
000ea8 91df
000ea9 91af
000eaa 91bf       str_search UART_RX_buffer, GSM_memory_parameter	//search for "memory" parameter
000eab 3010       cpi temp, 0
000eac f409       brne PC+2
000ead c047       rjmp GSM_search_unsupported_set_parameter
                 
000eae 931f       push temp
000eaf e017       ldi temp, 7
000eb0 0f01       add byte, temp
000eb1 911f       pop temp
000eb2 e0d2       ldi YH, high(UART_RX_buffer)
000eb3 e4c3       ldi YL, low(UART_RX_buffer)
000eb4 0fc0       add YL, byte
000eb5 2700       clr byte
000eb6 1fd0       adc YH, byte
                 
000eb7 940e 1472  call GSM_OnOff_Validate
000eb9 3010       cpi temp, 0
000eba f1a9       breq GSM_set_memory_error
                 
000ebb 9621       adiw YH:YL, 1
000ebc 8118       ld temp, Y
000ebd 3416       cpi temp, 'F'
000ebe f0b1       breq GSM_set_memory_off
                 
000ebf e0d4       ldi YH, high(MC_Settings)
000ec0 eec9       ldi YL, low(MC_Settings)
000ec1 e011       ldi temp, 1
000ec2 8318       st Y, temp
000ec3 93bf
000ec4 93af
000ec5 93df
000ec6 93cf
000ec7 930f
000ec8 e0b4
000ec9 e4a6
000eca e0d0
000ecb efc0
000ecc 2700
000ecd 940e 0bdc
000ecf 910f
000ed0 91cf
000ed1 91df
000ed2 91af
000ed3 91bf       str_cpy On_str, mc_value
000ed4 c015       rjmp GSM_set_memory_return
                 
                  GSM_set_memory_off:
000ed5 e0d4       ldi YH, high(MC_Settings)
000ed6 eec9       ldi YL, low(MC_Settings)
000ed7 e010       ldi temp, 0
000ed8 93bf
000ed9 93af
000eda 93df
000edb 93cf
000edc 930f
000edd e0b4
000ede e4aa
000edf e0d0
000ee0 efc0
000ee1 2700
000ee2 940e 0bdc
000ee4 910f
000ee5 91cf
000ee6 91df
000ee7 91af
000ee8 91bf       str_cpy Off_str, mc_value
000ee9 8318       st Y, temp
                 
                  GSM_set_memory_return:
000eea e0d3       ldi YH, high(GSM_Status)
000eeb e4c7       ldi YL, low(GSM_Status)
000eec 8118       ld temp, Y
000eed 6016       ori temp, 6
000eee 8318       st Y, temp
000eef c005       rjmp GSM_send_SMS_command
                 
                  GSM_set_memory_error:
000ef0 e0d3       ldi YH, high(GSM_Status)
000ef1 e4c7       ldi YL, low(GSM_Status)
000ef2 8118       ld temp, Y
000ef3 6210       ori temp, 0b0010_0000
000ef4 8318       st Y, temp
                 
                  GSM_search_unsupported_set_parameter:
                  
                  /* SMS send command */
                  GSM_send_SMS_command:
000ef5 93df
000ef6 93cf
000ef7 931f
000ef8 930f
000ef9 2711
000efa 9310 0344
000efc e0d1
000efd e4c2
000efe 2711
000eff 2700
000f00 9309
000f01 951a
000f02 f7e9
000f03 910f
000f04 911f
000f05 91cf
000f06 91df       UART_clear_TX_buffer	//Clear TX buffer
000f07 93df
000f08 93cf
000f09 931f
000f0a 930f
000f0b 2711
000f0c 9310 0345
000f0e e0d2
000f0f e4c3
000f10 2711
000f11 2700
000f12 9309
000f13 951a
000f14 f7e9
000f15 910f
000f16 911f
000f17 91cf
000f18 91df       UART_clear_RX_buffer	//Clear TX buffer
                  //str_cpy GSM_phone_number, pressure_msg
                  //menu_refresh
                 
000f19 93bf
000f1a 93af
000f1b 93df
000f1c 93cf
000f1d 930f
000f1e e0b1
000f1f e4a2
000f20 e0d3
000f21 e6c4
000f22 2700
000f23 940e 0bbb
000f25 910f
000f26 91cf
000f27 91df
000f28 91af
000f29 91bf       str_concat UART_TX_buffer, GSM_write
000f2a 93bf
000f2b 93af
000f2c 93df
000f2d 93cf
000f2e 930f
000f2f e0b1
000f30 e4a2
000f31 e0d4
000f32 edc9
000f33 2700
000f34 940e 0bbb
000f36 910f
000f37 91cf
000f38 91df
000f39 91af
000f3a 91bf       str_concat UART_TX_buffer, GSM_phone_number	//prepare TX buffer
000f3b 93bf
000f3c 93af
000f3d 93df
000f3e 93cf
000f3f 930f
000f40 e0b1
000f41 e4a2
000f42 e0d3
000f43 e6cf
000f44 2700
000f45 940e 0bbb
000f47 910f
000f48 91cf
000f49 91df
000f4a 91af
000f4b 91bf       str_concat UART_TX_buffer, GSM_enter
                 
000f4c 93df
000f4d 93cf
000f4e 930f
000f4f 931f
000f50 e0d3
000f51 e4c6
000f52 8118
000f53 6011
000f54 8318
000f55 e0d3
000f56 e4c4
000f57 e011
000f58 8318
000f59 e0d1
000f5a e4c2
000f5b 8108
000f5c b11a
000f5d 6610
000f5e b90c
000f5f b91a
000f60 911f
000f61 910f
000f62 91cf
000f63 91df       UART_start_transmit
000f64 93df
000f65 93cf
000f66 931f
000f67 e0d3
000f68 e4c6
000f69 8118
000f6a 6011
000f6b 8318
000f6c b11a
000f6d 6810
000f6e b91a
000f6f 911f
000f70 91cf
000f71 91df       UART_start_receive
                 
000f72 939f
000f73 938f
000f74 937f
000f75 ef9f
000f76 ef8f
000f77 ef7f
000f78 940e 0029
000f7a 917f
000f7b 918f
000f7c 919f       delay 255,255,255		//long delay
                  //UART_stop_receive
                 
000f7d 93bf
000f7e 93af
000f7f 93df
000f80 93cf
000f81 e0b2
000f82 e4a3
000f83 e0d3
000f84 e6cd
000f85 940e 0b76
000f87 91cf
000f88 91df
000f89 91af
000f8a 91bf       str_search UART_RX_buffer, GSM_write_msg
000f8b 3010       cpi temp, 0
000f8c f409       brne PC+2
000f8d cf67       rjmp GSM_send_SMS_command
                 
000f8e 9a97       sbi PORTD, 7//?????????????????????????????????????????????????????
                 
                  
                  /* write answer message */
000f8f 93df
000f90 93cf
000f91 931f
000f92 930f
000f93 2711
000f94 9310 0344
000f96 e0d1
000f97 e4c2
000f98 2711
000f99 2700
000f9a 9309
000f9b 951a
000f9c f7e9
000f9d 910f
000f9e 911f
000f9f 91cf
000fa0 91df       UART_clear_TX_buffer	//Clear TX buffer
                 
000fa1 e0b3       ldi XH, high(GSM_Status)
000fa2 e4a7       ldi XL, low(GSM_Status)
000fa3 911c       ld temp, X
                 
000fa4 ff13       sbrs temp, 3	//check G/S bit
000fa5 c013       rjmp GSM_answer_set	//go to GSM_answer_set if G/S bit is 0
                 
                  //if G/S is 1 (get)
000fa6 7017       andi temp, 0b0000_0111
000fa7 3011       cpi temp, 1
000fa8 f0c9       breq GSM_answer_AllInfo
000fa9 3012       cpi temp, 2
000faa f409       brne PC+2
000fab c117       rjmp GSM_answer_time
000fac 3013       cpi temp, 3
000fad f409       brne PC+2
000fae c15a       rjmp GSM_answer_temp
000faf 3014       cpi temp, 4
000fb0 f409       brne PC+2
000fb1 c19d       rjmp GSM_answer_pressure
000fb2 3015       cpi temp, 5
000fb3 f409       brne PC+2
000fb4 c1e0       rjmp GSM_answer_sound
000fb5 3016       cpi temp, 6
000fb6 f409       brne PC+2
000fb7 c223       rjmp GSM_answer_memory
000fb8 c268       rjmp GSM_answer_invalid_get
                 
                  GSM_answer_set:
                  //if G/S is 0 (set)
                 
000fb9 fd14       sbrc temp, 4	//check for CE(code error) flags
000fba c28a       rjmp GSM_answer_invalid_time	
000fbb fd15       sbrc temp, 5
000fbc c2ac       rjmp GSM_answer_invalid_OnOff
                 
000fbd 7017       andi temp, 0b0000_0111
000fbe 3010       cpi temp, 0	//check for correct set
000fbf f409       brne PC+2
000fc0 c2cc       rjmp GSM_answer_invalid_set
000fc1 c2ef       rjmp GSM_answer_OK	//else: go to OK
                 
                  GSM_answer_AllInfo:
000fc2 93df
000fc3 93cf
000fc4 931f
000fc5 930f
000fc6 2711
000fc7 9310 0344
000fc9 e0d1
000fca e4c2
000fcb 2711
000fcc 2700
000fcd 9309
000fce 951a
000fcf f7e9
000fd0 910f
000fd1 911f
000fd2 91cf
000fd3 91df       UART_clear_TX_buffer	//Clear TX buffer
000fd4 93bf
000fd5 93af
000fd6 93df
000fd7 93cf
000fd8 930f
000fd9 e0b1
000fda e4a2
000fdb e0d0
000fdc e6c0
000fdd e002
000fde 940e 0bbb
000fe0 910f
000fe1 91cf
000fe2 91df
000fe3 91af
000fe4 91bf       str_concat_ex UART_TX_buffer, pressure_msg, 2
000fe5 93bf
000fe6 93af
000fe7 93df
000fe8 93cf
000fe9 930f
000fea e0b1
000feb e4a2
000fec e0d0
000fed ecc0
000fee e001
000fef 940e 0bbb
000ff1 910f
000ff2 91cf
000ff3 91df
000ff4 91af
000ff5 91bf       str_concat_ex UART_TX_buffer, pressure_value, 1
000ff6 93bf
000ff7 93af
000ff8 93df
000ff9 93cf
000ffa 930f
000ffb e0b1
000ffc e4a2
000ffd e0d3
000ffe e6cf
000fff 2700
001000 940e 0bbb
001002 910f
001003 91cf
001004 91df
001005 91af
001006 91bf       str_concat UART_TX_buffer, GSM_enter
001007 93bf
001008 93af
001009 93df
00100a 93cf
00100b 930f
00100c e0b1
00100d e4a2
00100e e0d0
00100f e7c0
001010 2700
001011 940e 0bbb
001013 910f
001014 91cf
001015 91df
001016 91af
001017 91bf       str_concat UART_TX_buffer, temperature_msg
001018 93bf
001019 93af
00101a 93df
00101b 93cf
00101c 930f
00101d e0b1
00101e e4a2
00101f e0d0
001020 edc0
001021 e001
001022 940e 0bbb
001024 910f
001025 91cf
001026 91df
001027 91af
001028 91bf       str_concat_ex UART_TX_buffer, temperature_value, 1
001029 93bf
00102a 93af
00102b 93df
00102c 93cf
00102d 930f
00102e e0b1
00102f e4a2
001030 e0d3
001031 e6cf
001032 2700
001033 940e 0bbb
001035 910f
001036 91cf
001037 91df
001038 91af
001039 91bf       str_concat UART_TX_buffer, GSM_enter
00103a 93bf
00103b 93af
00103c 93df
00103d 93cf
00103e 930f
00103f e0b1
001040 e4a2
001041 e0d0
001042 e8c0
001043 2700
001044 940e 0bbb
001046 910f
001047 91cf
001048 91df
001049 91af
00104a 91bf       str_concat UART_TX_buffer, time_msg
00104b 93bf
00104c 93af
00104d 93df
00104e 93cf
00104f 930f
001050 e0b1
001051 e4a2
001052 e0d0
001053 eec0
001054 e001
001055 940e 0bbb
001057 910f
001058 91cf
001059 91df
00105a 91af
00105b 91bf       str_concat_ex UART_TX_buffer, time_value, 1
00105c 93bf
00105d 93af
00105e 93df
00105f 93cf
001060 930f
001061 e0b1
001062 e4a2
001063 e0d3
001064 e6cf
001065 2700
001066 940e 0bbb
001068 910f
001069 91cf
00106a 91df
00106b 91af
00106c 91bf       str_concat UART_TX_buffer, GSM_enter
00106d 93bf
00106e 93af
00106f 93df
001070 93cf
001071 930f
001072 e0b1
001073 e4a2
001074 e0d0
001075 e9c0
001076 2700
001077 940e 0bbb
001079 910f
00107a 91cf
00107b 91df
00107c 91af
00107d 91bf       str_concat UART_TX_buffer, mc_msg
00107e 93bf
00107f 93af
001080 93df
001081 93cf
001082 930f
001083 e0b1
001084 e4a2
001085 e0d0
001086 efc0
001087 e001
001088 940e 0bbb
00108a 910f
00108b 91cf
00108c 91df
00108d 91af
00108e 91bf       str_concat_ex UART_TX_buffer, mc_value, 1
00108f 93bf
001090 93af
001091 93df
001092 93cf
001093 930f
001094 e0b1
001095 e4a2
001096 e0d3
001097 e6cf
001098 2700
001099 940e 0bbb
00109b 910f
00109c 91cf
00109d 91df
00109e 91af
00109f 91bf       str_concat UART_TX_buffer, GSM_enter
0010a0 93bf
0010a1 93af
0010a2 93df
0010a3 93cf
0010a4 930f
0010a5 e0b1
0010a6 e4a2
0010a7 e0d0
0010a8 ebc0
0010a9 2700
0010aa 940e 0bbb
0010ac 910f
0010ad 91cf
0010ae 91df
0010af 91af
0010b0 91bf       str_concat UART_TX_buffer, sound_msg
0010b1 93bf
0010b2 93af
0010b3 93df
0010b4 93cf
0010b5 930f
0010b6 e0b1
0010b7 e4a2
0010b8 e0d1
0010b9 e1c0
0010ba e002
0010bb 940e 0bbb
0010bd 910f
0010be 91cf
0010bf 91df
0010c0 91af
0010c1 91bf       str_concat_ex UART_TX_buffer, sound_value, 2
0010c2 c212       rjmp GSM_answer_continue
                 
                  GSM_answer_time:
0010c3 93df
0010c4 93cf
0010c5 931f
0010c6 930f
0010c7 2711
0010c8 9310 0344
0010ca e0d1
0010cb e4c2
0010cc 2711
0010cd 2700
0010ce 9309
0010cf 951a
0010d0 f7e9
0010d1 910f
0010d2 911f
0010d3 91cf
0010d4 91df       UART_clear_TX_buffer	//Clear TX buffer
0010d5 93bf
0010d6 93af
0010d7 93df
0010d8 93cf
0010d9 930f
0010da e0b1
0010db e4a2
0010dc e0d0
0010dd e8c0
0010de 2700
0010df 940e 0bbb
0010e1 910f
0010e2 91cf
0010e3 91df
0010e4 91af
0010e5 91bf       str_concat UART_TX_buffer, time_msg
0010e6 93bf
0010e7 93af
0010e8 93df
0010e9 93cf
0010ea 930f
0010eb e0b1
0010ec e4a2
0010ed e0d3
0010ee e6cf
0010ef 2700
0010f0 940e 0bbb
0010f2 910f
0010f3 91cf
0010f4 91df
0010f5 91af
0010f6 91bf       str_concat UART_TX_buffer, GSM_enter
0010f7 93bf
0010f8 93af
0010f9 93df
0010fa 93cf
0010fb 930f
0010fc e0b1
0010fd e4a2
0010fe e0d0
0010ff eec0
001100 e001
001101 940e 0bbb
001103 910f
001104 91cf
001105 91df
001106 91af
001107 91bf       str_concat_ex UART_TX_buffer, time_value, 1
001108 c1cc       rjmp GSM_answer_continue
                  
                  GSM_answer_temp:
001109 93df
00110a 93cf
00110b 931f
00110c 930f
00110d 2711
00110e 9310 0344
001110 e0d1
001111 e4c2
001112 2711
001113 2700
001114 9309
001115 951a
001116 f7e9
001117 910f
001118 911f
001119 91cf
00111a 91df       UART_clear_TX_buffer	//Clear TX buffer
00111b 93bf
00111c 93af
00111d 93df
00111e 93cf
00111f 930f
001120 e0b1
001121 e4a2
001122 e0d0
001123 e7c0
001124 2700
001125 940e 0bbb
001127 910f
001128 91cf
001129 91df
00112a 91af
00112b 91bf       str_concat UART_TX_buffer, temperature_msg
00112c 93bf
00112d 93af
00112e 93df
00112f 93cf
001130 930f
001131 e0b1
001132 e4a2
001133 e0d3
001134 e6cf
001135 2700
001136 940e 0bbb
001138 910f
001139 91cf
00113a 91df
00113b 91af
00113c 91bf       str_concat UART_TX_buffer, GSM_enter
00113d 93bf
00113e 93af
00113f 93df
001140 93cf
001141 930f
001142 e0b1
001143 e4a2
001144 e0d0
001145 edc0
001146 e001
001147 940e 0bbb
001149 910f
00114a 91cf
00114b 91df
00114c 91af
00114d 91bf       str_concat_ex UART_TX_buffer, temperature_value, 1
00114e c186       rjmp GSM_answer_continue
                 
                  GSM_answer_pressure:
00114f 93df
001150 93cf
001151 931f
001152 930f
001153 2711
001154 9310 0344
001156 e0d1
001157 e4c2
001158 2711
001159 2700
00115a 9309
00115b 951a
00115c f7e9
00115d 910f
00115e 911f
00115f 91cf
001160 91df       UART_clear_TX_buffer	//Clear TX buffer
001161 93bf
001162 93af
001163 93df
001164 93cf
001165 930f
001166 e0b1
001167 e4a2
001168 e0d0
001169 e6c0
00116a e002
00116b 940e 0bbb
00116d 910f
00116e 91cf
00116f 91df
001170 91af
001171 91bf       str_concat_ex UART_TX_buffer, pressure_msg, 2
001172 93bf
001173 93af
001174 93df
001175 93cf
001176 930f
001177 e0b1
001178 e4a2
001179 e0d3
00117a e6cf
00117b 2700
00117c 940e 0bbb
00117e 910f
00117f 91cf
001180 91df
001181 91af
001182 91bf       str_concat UART_TX_buffer, GSM_enter
001183 93bf
001184 93af
001185 93df
001186 93cf
001187 930f
001188 e0b1
001189 e4a2
00118a e0d0
00118b ecc0
00118c e001
00118d 940e 0bbb
00118f 910f
001190 91cf
001191 91df
001192 91af
001193 91bf       str_concat_ex UART_TX_buffer, pressure_value, 1
001194 c140       rjmp GSM_answer_continue
                 
                  GSM_answer_sound:
001195 93df
001196 93cf
001197 931f
001198 930f
001199 2711
00119a 9310 0344
00119c e0d1
00119d e4c2
00119e 2711
00119f 2700
0011a0 9309
0011a1 951a
0011a2 f7e9
0011a3 910f
0011a4 911f
0011a5 91cf
0011a6 91df       UART_clear_TX_buffer	//Clear TX buffer
0011a7 93bf
0011a8 93af
0011a9 93df
0011aa 93cf
0011ab 930f
0011ac e0b1
0011ad e4a2
0011ae e0d0
0011af ebc0
0011b0 2700
0011b1 940e 0bbb
0011b3 910f
0011b4 91cf
0011b5 91df
0011b6 91af
0011b7 91bf       str_concat UART_TX_buffer, sound_msg
0011b8 93bf
0011b9 93af
0011ba 93df
0011bb 93cf
0011bc 930f
0011bd e0b1
0011be e4a2
0011bf e0d3
0011c0 e6cf
0011c1 2700
0011c2 940e 0bbb
0011c4 910f
0011c5 91cf
0011c6 91df
0011c7 91af
0011c8 91bf       str_concat UART_TX_buffer, GSM_enter
0011c9 93bf
0011ca 93af
0011cb 93df
0011cc 93cf
0011cd 930f
0011ce e0b1
0011cf e4a2
0011d0 e0d1
0011d1 e1c0
0011d2 e002
0011d3 940e 0bbb
0011d5 910f
0011d6 91cf
0011d7 91df
0011d8 91af
0011d9 91bf       str_concat_ex UART_TX_buffer, sound_value, 2
0011da c0fa       rjmp GSM_answer_continue
                 
                  GSM_answer_memory:
0011db 93df
0011dc 93cf
0011dd 931f
0011de 930f
0011df 2711
0011e0 9310 0344
0011e2 e0d1
0011e3 e4c2
0011e4 2711
0011e5 2700
0011e6 9309
0011e7 951a
0011e8 f7e9
0011e9 910f
0011ea 911f
0011eb 91cf
0011ec 91df       UART_clear_TX_buffer	//Clear TX buffer
0011ed 93bf
0011ee 93af
0011ef 93df
0011f0 93cf
0011f1 930f
0011f2 e0b1
0011f3 e4a2
0011f4 e0d0
0011f5 e9c0
0011f6 2700
0011f7 940e 0bbb
0011f9 910f
0011fa 91cf
0011fb 91df
0011fc 91af
0011fd 91bf       str_concat UART_TX_buffer, mc_msg
0011fe 93bf
0011ff 93af
001200 93df
001201 93cf
001202 930f
001203 e0b1
001204 e4a2
001205 e0d3
001206 e6cf
001207 2700
001208 940e 0bbb
00120a 910f
00120b 91cf
00120c 91df
00120d 91af
00120e 91bf       str_concat UART_TX_buffer, GSM_enter
00120f 93bf
001210 93af
001211 93df
001212 93cf
001213 930f
001214 e0b1
001215 e4a2
001216 e0d0
001217 efc0
001218 e001
001219 940e 0bbb
00121b 910f
00121c 91cf
00121d 91df
00121e 91af
00121f 91bf       str_concat_ex UART_TX_buffer, mc_value, 1
001220 c0b4       rjmp GSM_answer_continue
                 
                  GSM_answer_invalid_get:
001221 93df
001222 93cf
001223 931f
001224 930f
001225 2711
001226 9310 0344
001228 e0d1
001229 e4c2
00122a 2711
00122b 2700
00122c 9309
00122d 951a
00122e f7e9
00122f 910f
001230 911f
001231 91cf
001232 91df       UART_clear_TX_buffer	//Clear TX buffer
001233 93bf
001234 93af
001235 93df
001236 93cf
001237 930f
001238 e0b1
001239 e4a2
00123a e0d3
00123b ebc1
00123c 2700
00123d 940e 0bbb
00123f 910f
001240 91cf
001241 91df
001242 91af
001243 91bf       str_concat UART_TX_buffer, GSM_invalid_get
001244 c090       rjmp GSM_answer_continue
                 
                  GSM_answer_invalid_time:
001245 93df
001246 93cf
001247 931f
001248 930f
001249 2711
00124a 9310 0344
00124c e0d1
00124d e4c2
00124e 2711
00124f 2700
001250 9309
001251 951a
001252 f7e9
001253 910f
001254 911f
001255 91cf
001256 91df       UART_clear_TX_buffer	//Clear TX buffer
001257 93bf
001258 93af
001259 93df
00125a 93cf
00125b 930f
00125c e0b1
00125d e4a2
00125e e0d4
00125f e4ce
001260 2700
001261 940e 0bbb
001263 910f
001264 91cf
001265 91df
001266 91af
001267 91bf       str_concat UART_TX_buffer, GSM_invalid_time_msg
001268 c06c       rjmp GSM_answer_continue
                 
                  GSM_answer_invalid_OnOff:
001269 93df
00126a 93cf
00126b 931f
00126c 930f
00126d 2711
00126e 9310 0344
001270 e0d1
001271 e4c2
001272 2711
001273 2700
001274 9309
001275 951a
001276 f7e9
001277 910f
001278 911f
001279 91cf
00127a 91df       UART_clear_TX_buffer	//Clear TX buffer
00127b 93bf
00127c 93af
00127d 93df
00127e 93cf
00127f 930f
001280 e0b1
001281 e4a2
001282 e0d4
001283 e8c3
001284 2700
001285 940e 0bbb
001287 910f
001288 91cf
001289 91df
00128a 91af
00128b 91bf       str_concat UART_TX_buffer, GSM_invalid_OnOff
00128c c048       rjmp GSM_answer_continue
                 
                  GSM_answer_invalid_set:
00128d 93df
00128e 93cf
00128f 931f
001290 930f
001291 2711
001292 9310 0344
001294 e0d1
001295 e4c2
001296 2711
001297 2700
001298 9309
001299 951a
00129a f7e9
00129b 910f
00129c 911f
00129d 91cf
00129e 91df       UART_clear_TX_buffer	//Clear TX buffer
00129f 93bf
0012a0 93af
0012a1 93df
0012a2 93cf
0012a3 930f
0012a4 e0b1
0012a5 e4a2
0012a6 e0d4
0012a7 e0c5
0012a8 2700
0012a9 940e 0bbb
0012ab 910f
0012ac 91cf
0012ad 91df
0012ae 91af
0012af 91bf       str_concat UART_TX_buffer, GSM_invalid_set
0012b0 c024       rjmp GSM_answer_continue
                 
                  GSM_answer_OK:
0012b1 93df
0012b2 93cf
0012b3 931f
0012b4 930f
0012b5 2711
0012b6 9310 0344
0012b8 e0d1
0012b9 e4c2
0012ba 2711
0012bb 2700
0012bc 9309
0012bd 951a
0012be f7e9
0012bf 910f
0012c0 911f
0012c1 91cf
0012c2 91df       UART_clear_TX_buffer	//Clear TX buffer
0012c3 93bf
0012c4 93af
0012c5 93df
0012c6 93cf
0012c7 930f
0012c8 e0b1
0012c9 e4a2
0012ca e0d3
0012cb e6c1
0012cc 2700
0012cd 940e 0bbb
0012cf 910f
0012d0 91cf
0012d1 91df
0012d2 91af
0012d3 91bf       str_concat UART_TX_buffer, GSM_result
0012d4 c000       rjmp GSM_answer_continue
                 
                  GSM_answer_continue:
                 
                  //UART_clear_TX_buffer	//Clear TX buffer
                  //str_concat UART_TX_buffer, GSM_enter
0012d5 93df
0012d6 93cf
0012d7 930f
0012d8 931f
0012d9 e0d3
0012da e4c6
0012db 8118
0012dc 6011
0012dd 8318
0012de e0d3
0012df e4c4
0012e0 e011
0012e1 8318
0012e2 e0d1
0012e3 e4c2
0012e4 8108
0012e5 b11a
0012e6 6610
0012e7 b90c
0012e8 b91a
0012e9 911f
0012ea 910f
0012eb 91cf
0012ec 91df       UART_start_transmit
0012ed 939f
0012ee 938f
0012ef 937f
0012f0 e592
0012f1 e28b
0012f2 e47d
0012f3 940e 0029
0012f5 917f
0012f6 918f
0012f7 919f       delay 82, 43, 77		//delay 1s
                 
                  //rcall dbg_TX
                  //rcall dbg_RX
                 
0012f8 93df
0012f9 93cf
0012fa 931f
0012fb 930f
0012fc 2711
0012fd 9310 0345
0012ff e0d2
001300 e4c3
001301 2711
001302 2700
001303 9309
001304 951a
001305 f7e9
001306 910f
001307 911f
001308 91cf
001309 91df       UART_clear_RX_buffer	//Clear RX buffer
00130a 93df
00130b 93cf
00130c 931f
00130d e0d3
00130e e4c6
00130f 8118
001310 6011
001311 8318
001312 b11a
001313 6810
001314 b91a
001315 911f
001316 91cf
001317 91df       UART_start_receive
001318 93df
001319 93cf
00131a 931f
00131b 930f
00131c 2711
00131d 9310 0344
00131f e0d1
001320 e4c2
001321 2711
001322 2700
001323 9309
001324 951a
001325 f7e9
001326 910f
001327 911f
001328 91cf
001329 91df       UART_clear_TX_buffer	//Clear TX buffer
00132a 93bf
00132b 93af
00132c 93df
00132d 93cf
00132e 930f
00132f e0b1
001330 e4a2
001331 e0d3
001332 e7c1
001333 2700
001334 940e 0bbb
001336 910f
001337 91cf
001338 91df
001339 91af
00133a 91bf       str_concat UART_TX_buffer, GSM_end_msg
00133b 93df
00133c 93cf
00133d 930f
00133e 931f
00133f e0d3
001340 e4c6
001341 8118
001342 6011
001343 8318
001344 e0d3
001345 e4c4
001346 e011
001347 8318
001348 e0d1
001349 e4c2
00134a 8108
00134b b11a
00134c 6610
00134d b90c
00134e b91a
00134f 911f
001350 910f
001351 91cf
001352 91df       UART_start_transmit 
                 
001353 9897       cbi PORTD, 7
                  /* wait for operation result */
001354 939f
001355 938f
001356 937f
001357 ef9f
001358 ef8f
001359 ef7f
00135a 940e 0029
00135c 917f
00135d 918f
00135e 919f       delay 255,255,255		//long delay
                  //UART_stop_receive
                 
00135f 9a97
001360 939f
001361 938f
001362 937f
001363 e592
001364 e28b
001365 e47d
001366 940e 0029
001368 917f
001369 918f
00136a 919f
00136b 9897
00136c 939f
00136d 938f
00136e 937f
00136f e592
001370 e28b
001371 e47d
001372 940e 0029
001374 917f
001375 918f
001376 919f       dbg
                 
001377 93bf
001378 93af
001379 93df
00137a 93cf
00137b e0b2
00137c e4a3
00137d e0d3
00137e e6c1
00137f 940e 0b76
001381 91cf
001382 91df
001383 91af
001384 91bf       str_search UART_RX_buffer, GSM_result
001385 3011       cpi temp, 1
001386 f409       brne PC+2
001387 c041       rjmp GSM_correct_return		////////////////////////////////////////////
                  //breq GSM_correct_return
001388 9a97
001389 939f
00138a 938f
00138b 937f
00138c e592
00138d e28b
00138e e47d
00138f 940e 0029
001391 917f
001392 918f
001393 919f
001394 9897
001395 939f
001396 938f
001397 937f
001398 e592
001399 e28b
00139a e47d
00139b 940e 0029
00139d 917f
00139e 918f
00139f 919f       dbg
0013a0 93bf
0013a1 93af
0013a2 93df
0013a3 93cf
0013a4 e0b2
0013a5 e4a3
0013a6 e0d4
0013a7 ecc8
0013a8 940e 0b76
0013aa 91cf
0013ab 91df
0013ac 91af
0013ad 91bf       str_search UART_RX_buffer, GSM_ERROR
0013ae 3011       cpi temp, 1
0013af f0c9       breq GSM_correct_return
0013b0 9a97
0013b1 939f
0013b2 938f
0013b3 937f
0013b4 e592
0013b5 e28b
0013b6 e47d
0013b7 940e 0029
0013b9 917f
0013ba 918f
0013bb 919f
0013bc 9897
0013bd 939f
0013be 938f
0013bf 937f
0013c0 e592
0013c1 e28b
0013c2 e47d
0013c3 940e 0029
0013c5 917f
0013c6 918f
0013c7 919f       dbg
0013c8 cb2c       rjmp GSM_send_SMS_command
                  /* return */
                  GSM_correct_return:
                 
0013c9 93df
0013ca 93cf
0013cb 931f
0013cc 930f
0013cd 2711
0013ce 9310 0345
0013d0 e0d2
0013d1 e4c3
0013d2 2711
0013d3 2700
0013d4 9309
0013d5 951a
0013d6 f7e9
0013d7 910f
0013d8 911f
0013d9 91cf
0013da 91df       UART_clear_RX_buffer	//Clear TX buffer
0013db 93df
0013dc 93cf
0013dd 931f
0013de e0d3
0013df e4c6
0013e0 8118
0013e1 6011
0013e2 8318
0013e3 b11a
0013e4 6810
0013e5 b91a
0013e6 911f
0013e7 91cf
0013e8 91df       UART_start_receive
                 
                  GSM_return:
0013e9 93df
0013ea 93cf
0013eb 931f
0013ec e0d3
0013ed e4c6
0013ee 8118
0013ef 6011
0013f0 8318
0013f1 b11a
0013f2 6810
0013f3 b91a
0013f4 911f
0013f5 91cf
0013f6 91df       UART_start_receive
0013f7 9a97       sbi PORTD, 7
0013f8 939f
0013f9 938f
0013fa 937f
0013fb ef9f
0013fc ef8f
0013fd ef7f
0013fe 940e 0029
001400 917f
001401 918f
001402 919f       delay 255,255,255
001403 9897       cbi PORTD, 7
001404 939f
001405 938f
001406 937f
001407 ef9f
001408 ef8f
001409 ef7f
00140a 940e 0029
00140c 917f
00140d 918f
00140e 919f       delay 255,255,255
                  
00140f 9508       ret
                  //.endm
                 
                  //------- store strings to SRAM ----------------
                  //.macro GSM_init_strings
                  GSM_init_strings:
001410 93df       push YH
001411 93cf       push YL
001412 93ff       push ZH
001413 93ef       push ZL
001414 93bf       push XH
001415 93af       push XL
001416 930f       push byte
                 
001417 e0d3       ldi YH, high(GSM_new_msg)	//Y is SRAM adress
001418 e4c8       ldi YL, low(GSM_new_msg)
                 
001419 e0f0       ldi ZH, high(ee_gsm_new_SMS)	//Z is EEPROM adress
00141a ece0       ldi ZL, low(ee_gsm_new_SMS)
                 
00141b e0b1       ldi XH,1
00141c e8ae       ldi XL,0x8E			
                 
                  gsm_EE_read_loop:
00141d 940e 039e  call EEPROM_read_byte		//read byte from EEPROM
00141f 9309       st Y+,byte					//Store byte to SRAM and post-Inc adress
001420 9631       adiw ZH:ZL, 1				//increment Z register after reading byte
                 
001421 9711       sbiw XH:XL, 1			//loop things...
001422 f7d1       brne gsm_EE_read_loop		//go to EE_read_loop label if r19 is not 0
                 
001423 910f       pop byte
001424 91af       pop XL
001425 91bf       pop XH
001426 91ef       pop ZL
001427 91ff       pop ZH
001428 91cf       pop YL
001429 91df       pop YH
                  //.endm
00142a 9508       ret
                  //----------------------------------------------
                  //======= PROCEDURES ===========================
                 
                  //------- time validate ----------------
                  GSM_time_validate:
00142b 93df       push YH
00142c 93cf       push YL
00142d 930f       push byte
                 
00142e 2711       clr temp
                 
00142f 9109       ld byte, Y+
001430 3300       cpi byte, '0'
001431 f1e0       brlo GSM_time_validate_return_false
001432 3303       cpi byte, '3'
001433 f5d0       brsh GSM_time_validate_return_false
                 
001434 9109       ld byte, Y+
001435 3300       cpi byte, '0'
001436 f1b8       brlo GSM_time_validate_return_false
001437 330a       cpi byte, ':'
001438 f5a8       brsh GSM_time_validate_return_false
                 
001439 9109       ld byte, Y+
00143a 330a       cpi byte, ':'
00143b f591       brne GSM_time_validate_return_false
                 
00143c 9109       ld byte, Y+
00143d 3300       cpi byte, '0'
00143e f178       brlo GSM_time_validate_return_false
00143f 3307       cpi byte, '7'
001440 f568       brsh GSM_time_validate_return_false
                 
001441 9109       ld byte, Y+
001442 3300       cpi byte, '0'
001443 f150       brlo GSM_time_validate_return_false
001444 330a       cpi byte, ':'
001445 f540       brsh GSM_time_validate_return_false
                 
001446 9109       ld byte, Y+
001447 3200       cpi byte, ' '
001448 f529       brne GSM_time_validate_return_false
                 
001449 9109       ld byte, Y+
00144a 3300       cpi byte, '0'
00144b f110       brlo GSM_time_validate_return_false
00144c 3304       cpi byte, '4'
00144d f500       brsh GSM_time_validate_return_false
                 
00144e 9109       ld byte, Y+
00144f 3300       cpi byte, '0'
001450 f0e8       brlo GSM_time_validate_return_false
001451 330a       cpi byte, ':'
001452 f4d8       brsh GSM_time_validate_return_false
                 
001453 9109       ld byte, Y+
001454 320f       cpi byte, '/'
001455 f4c1       brne GSM_time_validate_return_false
                 
001456 9109       ld byte, Y+
001457 3300       cpi byte, '0'
001458 f0a8       brlo GSM_time_validate_return_false
001459 3302       cpi byte, '2'
00145a f498       brsh GSM_time_validate_return_false
                 
00145b 9109       ld byte, Y+
00145c 3300       cpi byte, '0'
00145d f080       brlo GSM_time_validate_return_false
00145e 330a       cpi byte, ':'
00145f f470       brsh GSM_time_validate_return_false
                 
001460 9109       ld byte, Y+
001461 320f       cpi byte, '/'
001462 f459       brne GSM_time_validate_return_false
                 
001463 9109       ld byte, Y+
001464 3300       cpi byte, '0'
001465 f040       brlo GSM_time_validate_return_false
001466 330a       cpi byte, ':'
001467 f430       brsh GSM_time_validate_return_false
                 
001468 8108       ld byte, Y
001469 3300       cpi byte, '0'
00146a f018       brlo GSM_time_validate_return_false
00146b 330a       cpi byte, ':'
00146c f408       brsh GSM_time_validate_return_false
                 
                  GSM_time_validate_return_true:
00146d e011       ldi temp, 1
                  GSM_time_validate_return_false:
00146e 910f       pop byte
00146f 91cf       pop YL
001470 91df       pop YH
001471 9508       ret
                 //-----------------------------------------------
                 
                 //------- On/Off validate -----------------------
                 GSM_OnOff_Validate:
001472 93df      push YH
001473 93cf      push YL
001474 930f      push byte
                 
001475 2711      clr temp
                 
001476 9109      ld byte, Y+
001477 340f      cpi byte, 'O'
001478 f449      brne GSM_OnOff_Validate_return_false
                 
001479 9109      ld byte, Y+
00147a 340e      cpi byte, 'N'
00147b f029      breq GSM_OnOff_Validate_return_true
                 
00147c 3406      cpi byte, 'F'
00147d f421      brne GSM_OnOff_Validate_return_false
                 
00147e 8108      ld byte, Y
00147f 3406      cpi byte, 'F'
001480 f409      brne GSM_OnOff_Validate_return_false
                 
                 GSM_OnOff_Validate_return_true:
001481 e011      ldi temp, 1
                 GSM_OnOff_Validate_return_false:
001482 910f      pop byte
001483 91cf      pop YL
001484 91df      pop YH
001485 9508      ret
                 //-----------------------------------------------
                  //==============================================
                 
                  dbg_TX:
001486 930f       push r16
001487 931f       push r17
001488 932f       push r18
001489 933f       push r19
00148a 93df       push YH
00148b 93cf       push YL
00148c 93ff       push ZH
00148d 93ef       push ZL
                 
00148e b71f       in r17, SREG ; store SREG value
00148f 94f8       cli
                 
001490 e0d1       ldi YH, high(UART_TX_buffer)		 //load to YH register 0
001491 e4c2       ldi YL, low(UART_TX_buffer)		 //load to YL 0x60 coz 0x0060 - sram start
001492 e0f1       ldi ZH, 0x01
001493 efef       ldi ZL, 0xFF
                  
001494 e030       ldi r19,0			//r19 is a counter
                 
                  EE_write_loop:			//loop 96 times
001495 9109       ld byte, Y+				//Store byte to SRAM and post-Inc adress
001496 940e 14c4  call EEPROM_write		//read byte from EEPROM
001498 9631       adiw ZH:ZL,1				//increment Z register after reading byte
                 
001499 953a       dec r19				//loop things...
00149a f7d1       brne EE_write_loop		//go to EE_read_loop label if r19 is not 0
                 
00149b bf0f       out SREG, r16 ; restore SREG value (I-bit)
                 
00149c 91ef       pop ZL
00149d 91ff       pop ZH
00149e 91cf       pop YL
00149f 91df       pop YH
0014a0 913f       pop r19
0014a1 912f       pop r18
0014a2 911f       pop r17
0014a3 910f       pop r16
0014a4 9508       ret
                 
                  dbg_RX:
0014a5 930f       push r16
0014a6 931f       push r17
0014a7 932f       push r18
0014a8 933f       push r19
0014a9 93df       push YH
0014aa 93cf       push YL
0014ab 93ff       push ZH
0014ac 93ef       push ZL
                 
0014ad b71f       in r17, SREG ; store SREG value
0014ae 94f8       cli
                 
0014af e0d2       ldi YH, high(UART_RX_buffer)		 //load to YH register 0
0014b0 e4c3       ldi YL, low(UART_RX_buffer)		 //load to YL 0x60 coz 0x0060 - sram start
0014b1 e0f2       ldi ZH, 0x02
0014b2 efef       ldi ZL, 0xFF
                  
0014b3 e030       ldi r19,0			//r19 is a counter
                 
                  EE_write1_loop:			//loop 96 times
0014b4 9109       ld byte, Y+				//Store byte to SRAM and post-Inc adress
0014b5 940e 14c4  call EEPROM_write		//read byte from EEPROM
0014b7 9631       adiw ZH:ZL,1					//increment Z register after reading byte
                 
0014b8 953a       dec r19				//loop things...
0014b9 f7d1       brne EE_write1_loop		//go to EE_read_loop label if r19 is not 0
                 
0014ba bf0f       out SREG, r16 ; restore SREG value (I-bit)
                 
0014bb 91ef       pop ZL
0014bc 91ff       pop ZH
0014bd 91cf       pop YL
0014be 91df       pop YH
0014bf 913f       pop r19
0014c0 912f       pop r18
0014c1 911f       pop r17
0014c2 910f       pop r16
0014c3 9508       ret
                 
                  EEPROM_write:
                  ; Wait for completion of previous write
0014c4 99e1      sbic EECR,EEWE
0014c5 cffe      rjmp EEPROM_write
                 ; Set up address (r18:r17) in address register
0014c6 bbff      out EEARH, ZH
0014c7 bbee      out EEARL, ZL
                 ; Write data (r16) to data register
0014c8 bb0d      out EEDR,byte
                 ; Write logical one to EEMWE
0014c9 9ae2      sbi EECR,EEMWE
                 ; Start eeprom write by setting EEWE
0014ca 9ae1      sbi EECR,EEWE
                 .include "Temp.inc"
0014cb 9508      
                  * Temp.inc
                  *
                  *  Created: 31.05.2016 1:35:52
                  *   Author: Hogs
                  */
                 
                 .equ Wire_DDR = DDRA //   
                 .equ Wire_PORT = PORTA //   
                 .equ Wire_PIN = PINA //   
                 .equ Wire_BIT = 0 //      
                 
                 
                  //========== MACRO =============================
                  //---------- Wire delay 1 ----------------------
                  .macro Wire_delay1
                  ldi  r18, @0
                  rcall Wire_delay1_proc
                  .endm
                  //----------------------------------------------
                 
                  //---------- Wire delay 2 ----------------------
                  .macro Wire_delay2
                  ldi  r18, @0
                  ldi  r19, @1
                  rcall Wire_delay2_proc
                  .endm
                  //----------------------------------------------
                  //---------- Write byte ------------------------
                  .macro Wire_write
                  ldi byte, @0
                  rcall Wire_Write_proc
                  .endm
                  //----------------------------------------------
                 
                  //---------- Check reset -----------------------
                  .macro Wire_reset
                  rcall Wire_Reset_proc
                  tst temp
                  breq wire_return
                  .endm
                  //----------------------------------------------
                 
                  //---------- Main ------------------------------
                  //.macro Temperature
                  Temperature:
0014cc d03f       rcall Wire_Reset_proc
0014cd 2311       tst temp
0014ce f1e1       breq wire_return
0014cf d04d       rcall Wire_Init
                 
0014d0 d03b       rcall Wire_Reset_proc
0014d1 2311       tst temp
0014d2 f1c1       breq wire_return
0014d3 d054       rcall Wire_Measure
                 
0014d4 939f
0014d5 938f
0014d6 937f
0014d7 e592
0014d8 e28b
0014d9 e47d
0014da 940e 0029
0014dc 917f
0014dd 918f
0014de 919f       delay 82, 43, 77		//delay 1s
                 
0014df d02c       rcall Wire_Reset_proc
0014e0 2311       tst temp
0014e1 f149       breq wire_return
0014e2 d04a       rcall Wire_ReadTemp
                 
0014e3 d028       rcall Wire_Reset_proc
0014e4 2311       tst temp
0014e5 f129       breq wire_return
                 
0014e6 9100 04ec  lds byte, Wire_temp+1
0014e8 9502       swap byte
0014e9 7f00       andi byte, 0xF0 
0014ea 9110 04eb  lds temp, Wire_temp
0014ec 9512       swap temp
0014ed 701f       andi temp, 0x0F
0014ee 2b01       or byte, temp
                 
0014ef 9110 04ec  lds temp, Wire_temp+1
0014f1 ff17       sbrs temp, 7
0014f2 c006       rjmp wire_temp_plus
                 
0014f3 e21d       ldi temp, '-'
0014f4 9310 00d0  sts temperature_value, temp
0014f6 9500       com byte
0014f7 9503       inc byte
0014f8 c003       rjmp wire_refresh
                 
                  wire_temp_plus:
0014f9 e210       ldi temp, ' '
0014fa 9310 00d0  sts temperature_value, temp
                 
                  wire_refresh:
0014fc 2711       clr temp
                  
0014fd 300a       cpi byte, 10
0014fe f018       brlo wire_lbl
0014ff 9513       inc temp
001500 500a       subi byte, 10
001501 cffb       rjmp PC-4 
                  wire_lbl:
                 
001502 932f       push r18
001503 e320       ldi r18, 48
001504 0f12       add temp, r18
001505 0f02       add byte, r18
001506 912f       pop r18
001507 9310 00d1  sts temperature_value+1, temp
001509 9300 00d2  sts temperature_value+2, byte
                 
                  wire_return:
                  //.endm
00150b 9508       ret
                  //----------------------------------------------
                  //==============================================
                 
                  //========== PROCEDURES ========================
                  //---------- Check line -----------------
                  Wire_Reset_proc:
00150c 9ad0       sbi Wire_DDR, Wire_BIT			//   
00150d 98d8       cbi Wire_PORT, Wire_BIT			//    
00150e e02a
00150f ef39
001510 d051       Wire_delay2 10, 249				//  480 ,  
001511 98d0       cbi Wire_DDR, Wire_BIT			//   
001512 e022
001513 e733
001514 d04d       Wire_delay2 2, 115				//    70 
001515 9bc8       sbis Wire_PIN, Wire_BIT		//   ,     1
001516 e011       ldi temp, 1					//      1
001517 99c8       sbic Wire_PIN, Wire_BIT		//   ,     0
001518 2711       clr temp						//      0
001519 e029
00151a e834
00151b d046       Wire_delay2 9, 132				//    410 
00151c 9508       ret
                  //---------------------------------------
                 
                  //--------- Set 12bit mode --------------
                  Wire_Init:  
00151d ec0c
00151e d02d       Wire_write 0xCC	//    
00151f e40e
001520 d02b       Wire_write 0x4E	//       RAM  
001521 ef0f
001522 d029       Wire_write 0xFF	// 0xFF    2 ,   ,    
001523 ef0f
001524 d027       Wire_write 0xFF	// ,      
001525 e70f
001526 d025       Wire_write 0x7F	//       12  - 7F
001527 9508       ret
                  //---------------------------------------
                 
                  //--------- Start measuring -------------
                  Wire_Measure:
001528 ec0c
001529 d022       Wire_write 0xCC	//    
00152a e404
00152b d020       Wire_write 0x44	//      
00152c 9508       ret
                  //---------------------------------------
                 
                  //--------- Read Temperature ------------
                  Wire_ReadTemp:
00152d ec0c
00152e d01d       Wire_write 0xCC		//   0xCC,     
00152f eb0e
001530 d01b       Wire_write 0xBE		//  ,     
001531 d006       rcall Wire_Read_proc	//     ,  
001532 9300 04eb  sts Wire_temp, byte	//     ,   Trm
001534 d003       rcall Wire_Read_proc	//  
001535 9300 04ec  sts Wire_temp+1, byte	//     ,   Trm+1
001537 9508       ret
                  //---------------------------------------
                 
                  //---------- Read byte ------------------
                  Wire_Read_proc:
001538 e018       ldi temp, 8
001539 2700       clr byte
                  wire_read_bit:
00153a 9ad0       sbi Wire_DDR, Wire_BIT		//   
00153b 98d8       cbi Wire_PORT, Wire_BIT	//    
00153c e220
00153d d029       Wire_delay1 32				//  6 
00153e 98d0       cbi Wire_DDR, Wire_BIT		//   
00153f e320
001540 d026       Wire_delay1 48 			//  9 
001541 9bc8       sbis Wire_PIN, Wire_BIT
001542 9488       clc						//   C = 0
001543 99c8       sbic Wire_PIN, Wire_BIT
001544 9408       sec						//   C = 1
001545 9507       ror byte					//      
001546 e022
001547 e233
001548 d019       Wire_delay2 2, 35			//  55 
001549 951a       dec temp
00154a f779       brne wire_read_bit
00154b 9508       ret
                  //---------------------------------------
                 
                  //---------- Write byte -----------------
                  Wire_Write_proc:
00154c e018       ldi temp, 8
                  wire_write_bit: 
00154d 9ad0       sbi Wire_DDR, Wire_BIT			//   
00154e 98d8       cbi Wire_PORT, Wire_BIT		//    
00154f fd00       sbrc byte, 0					// ,  r16  0    
001550 c007       rjmp wire_write_1				//      
                 
001551 e022
001552 e33e
001553 d00e       Wire_delay2 2, 62				//  60 
001554 98d0       cbi Wire_DDR, Wire_BIT			//   
001555 e325
001556 d010       Wire_delay1 53					//  10 
001557 c006       rjmp wire_next_bit
                 
                  wire_write_1:
001558 e220
001559 d00d       Wire_delay1 32					//  6 
00155a 98d0       cbi Wire_DDR, Wire_BIT			//   
00155b e022
00155c e533
00155d d004       Wire_delay2 2, 83					//  64 
                 
                  wire_next_bit:
00155e 9506       lsr byte
00155f 951a       dec temp
001560 f761       brne wire_write_bit
001561 9508       ret
                  //---------------------------------------
                 
                  //--------- Short delay -----------------
                  Wire_delay2_proc:
001562 953a       dec  r19
001563 f7f1       brne Wire_delay2_proc
001564 952a       dec  r18
001565 f7e1       brne Wire_delay2_proc
001566 9508       ret
                  //---------------------------------------
                 
                  //--------- Short delay -----------------
                  Wire_delay1_proc:
001567 952a       dec  r18
001568 f7f1       brne Wire_delay1_proc
001569 9508       ret
                  //---------------------------------------
                 //.include "bmp.inc"
                 
                 reset:
                 .include "core_init.inc"	//clear sram, registers and stack init
                 
                  * Clear all registers and SRAM
                  * Initialization stack
                  */ 
                 
                 //================SRAM CLEAR=================================
                 RAM_Flush:	
00156a e6e0      LDI	ZL,Low(SRAM_START)
00156b e0f0      LDI	ZH,High(SRAM_START)
00156c 2700      CLR	R16
                 Flush:
00156d 9301      ST Z+,R16
00156e 30f8      CPI	ZH,High(RAMEND+1)
00156f f7e9      BRNE Flush
001570 36e0      CPI	ZL,Low(RAMEND+1)	
001571 f7d9      BRNE Flush 
001572 27ee      CLR	ZL
001573 27ff      CLR	ZH
                 //===============REGISTERS CLEAR=============================
001574 e1ee      LDI	ZL, 30			
001575 27ff      CLR	ZH		
001576 95ea      DEC	ZL		
001577 83f0      ST Z,ZH		
001578 f7e9      BRNE PC-2		
                 //===============STACK INIT==================================
001579 e50f      LDI R16,Low(RAMEND)		
00157a bf0d      OUT SPL,R16			
00157b e008      LDI R16,High(RAMEND)
00157c bf0e      OUT SPH,R16
                 //-----------Program start-------------------------
00157d 9a8f      sbi DDRD, 7
00157e 94f8
00157f e110
001580 bf19
001581 2711
001582 bd1f
001583 e014
001584 bd1e
001585 e00c
001586 e315
001587 bd0b
001588 bd1a
001589 e70a
00158a e112
00158b bd09
00158c bd18
00158d 2711
00158e bd1d
00158f bd1c
001590 9478      Timer1_Init					//initialization timer 1
001591 b317
001592 7f18
001593 bb17
001594 b318
001595 6017
001596 bb18
001597 b311
001598 631c
001599 bb11      keyboard_init				//initialization of ports for keyboard
00159a 940e 0055 call LCD_init				//LCD initialization
00159c 94f8
00159d 27dd
00159e e6c0
00159f 27ee
0015a0 27ff
0015a1 ec31
0015a2 940e 039e
0015a4 9309
0015a5 95e3
0015a6 953a
0015a7 f7d1
0015a8 9478
0015a9 e0d1
0015aa e2c0
0015ab e010
0015ac 8318
0015ad 93ff
0015ae 93ef
0015af 931f
0015b0 930f
0015b1 933f
0015b2 e0f0
0015b3 e6e0
0015b4 e014
0015b5 e131
0015b6 9101
0015b7 940e 0030
0015b9 939f
0015ba 938f
0015bb 937f
0015bc ef90
0015bd e081
0015be e071
0015bf 940e 0029
0015c1 917f
0015c2 918f
0015c3 919f
0015c4 953a
0015c5 f781
0015c6 913f
0015c7 910f
0015c8 911f
0015c9 91ef
0015ca 91ff
0015cb 931f
0015cc 930f
0015cd 931f
0015ce 930f
0015cf e010
0015d0 ec00
0015d1 940e 0030
0015d3 910f
0015d4 911f
0015d5 939f
0015d6 938f
0015d7 937f
0015d8 ef90
0015d9 e081
0015da e071
0015db 940e 0029
0015dd 917f
0015de 918f
0015df 919f
0015e0 910f
0015e1 911f
0015e2 93ff
0015e3 93ef
0015e4 931f
0015e5 930f
0015e6 933f
0015e7 e0f0
0015e8 ece0
0015e9 e014
0015ea e131
0015eb 9101
0015ec 940e 0030
0015ee 939f
0015ef 938f
0015f0 937f
0015f1 ef90
0015f2 e081
0015f3 e071
0015f4 940e 0029
0015f6 917f
0015f7 918f
0015f8 919f
0015f9 953a
0015fa f781
0015fb 913f
0015fc 910f
0015fd 911f
0015fe 91ef
0015ff 91ff      menu_init					//menu initialization
001600 b311
001601 6410
001602 bb11
001603 b312
001604 7b1f
001605 bb12
001606 2711
001607 bf12
001608 e117
001609 bf1c
00160a b719
00160b 6012
00160c bf19      sound_init					//buzzer initialization
00160d e31c
00160e b910      I2C_Init					//i2c initialization
00160f 931f
001610 932f
001611 93df
001612 93cf
001613 930f
001614 931f
001615 933f
001616 e02b
001617 e633
001618 953a
001619 f7f1
00161a 952a
00161b f7e1
00161c 2733
00161d ed00
00161e e010
00161f 940e 03d8
001621 913f
001622 911f
001623 910f
001624 ff27
001625 c013
001626 772f
001627 930f
001628 931f
001629 933f
00162a e02b
00162b e633
00162c 953a
00162d f7f1
00162e 952a
00162f f7e1
001630 2f22
001631 2733
001632 ed00
001633 e010
001634 940e 03a7
001636 913f
001637 911f
001638 910f
001639 930f
00163a 931f
00163b 933f
00163c e02b
00163d e633
00163e 953a
00163f f7f1
001640 952a
001641 f7e1
001642 2733
001643 ed00
001644 e012
001645 940e 03d8
001647 913f
001648 911f
001649 910f
00164a ff16
00164b c013
00164c 7b2f
00164d 930f
00164e 931f
00164f 933f
001650 e02b
001651 e633
001652 953a
001653 f7f1
001654 952a
001655 f7e1
001656 2f22
001657 2733
001658 ed00
001659 e010
00165a 940e 03a7
00165c 913f
00165d 911f
00165e 910f
00165f 91cf
001660 91df
001661 912f
001662 911f      I2C_Check_Clock_Settings	//check clock settings and correct if needed
001663 e0d1
001664 e3c0
001665 e012
001666 9319
001667 e019
001668 9319
001669 e016
00166a 9319
00166b e019
00166c 9319
00166d e013
00166e 9319
00166f e019
001670 9319
001671 e011
001672 9319
001673 e019
001674 9319
001675 9319
001676 9319
001677 e0d1
001678 e3ca
001679 e118
00167a 9319
00167b e31c
00167c 9319
00167d e11f
00167e 9319
00167f e01c
001680 9319
001681 e613
001682 9319      time_set_init
001683 e617
001684 b919
001685 e010
001686 bd10
001687 e118
001688 b91a
001689 2711
00168a b91b
00168b e816
00168c bd10      UART_init
00168d 940e 1410
00168f 93df
001690 93cf
001691 931f
001692 930f
001693 2711
001694 9310 0344
001696 e0d1
001697 e4c2
001698 2711
001699 2700
00169a 9309
00169b 951a
00169c f7e9
00169d 910f
00169e 911f
00169f 91cf
0016a0 91df
0016a1 93df
0016a2 93cf
0016a3 931f
0016a4 e0d3
0016a5 e4c6
0016a6 8118
0016a7 6011
0016a8 8318
0016a9 b11a
0016aa 6810
0016ab b91a
0016ac 911f
0016ad 91cf
0016ae 91df
0016af 93bf
0016b0 93af
0016b1 93df
0016b2 93cf
0016b3 930f
0016b4 e0b1
0016b5 e4a2
0016b6 e0d4
0016b7 ecce
0016b8 2700
0016b9 940e 0bbb
0016bb 910f
0016bc 91cf
0016bd 91df
0016be 91af
0016bf 91bf
0016c0 93df
0016c1 93cf
0016c2 930f
0016c3 931f
0016c4 e0d3
0016c5 e4c6
0016c6 8118
0016c7 6011
0016c8 8318
0016c9 e0d3
0016ca e4c4
0016cb e011
0016cc 8318
0016cd e0d1
0016ce e4c2
0016cf 8108
0016d0 b11a
0016d1 6610
0016d2 b90c
0016d3 b91a
0016d4 911f
0016d5 910f
0016d6 91cf
0016d7 91df
0016d8 939f
0016d9 938f
0016da 937f
0016db ef9f
0016dc ef8f
0016dd ef7f
0016de 940e 0029
0016e0 917f
0016e1 918f
0016e2 919f
0016e3 939f
0016e4 938f
0016e5 937f
0016e6 ef9f
0016e7 ef8f
0016e8 ef7f
0016e9 940e 0029
0016eb 917f
0016ec 918f
0016ed 919f
0016ee 939f
0016ef 938f
0016f0 937f
0016f1 ef9f
0016f2 ef8f
0016f3 ef7f
0016f4 940e 0029
0016f6 917f
0016f7 918f
0016f8 919f
0016f9 93bf
0016fa 93af
0016fb 93df
0016fc 93cf
0016fd e0b2
0016fe e4a3
0016ff e0d3
001700 e6c1
001701 940e 0b76
001703 91cf
001704 91df
001705 91af
001706 91bf
001707 3011
001708 f4c1
001709 9a97
00170a 939f
00170b 938f
00170c 937f
00170d e592
00170e e28b
00170f e47d
001710 940e 0029
001712 917f
001713 918f
001714 919f
001715 9897
001716 939f
001717 938f
001718 937f
001719 e592
00171a e28b
00171b e47d
00171c 940e 0029
00171e 917f
00171f 918f
001720 919f
001721 93df
001722 93cf
001723 931f
001724 930f
001725 2711
001726 9310 0345
001728 e0d2
001729 e4c3
00172a 2711
00172b 2700
00172c 9309
00172d 951a
00172e f7e9
00172f 910f
001730 911f
001731 91cf
001732 91df
001733 93df
001734 93cf
001735 931f
001736 930f
001737 2711
001738 9310 0344
00173a e0d1
00173b e4c2
00173c 2711
00173d 2700
00173e 9309
00173f 951a
001740 f7e9
001741 910f
001742 911f
001743 91cf
001744 91df
001745 93df
001746 93cf
001747 931f
001748 e0d3
001749 e4c6
00174a 8118
00174b 6011
00174c 8318
00174d b11a
00174e 6810
00174f b91a
001750 911f
001751 91cf
001752 91df      GSM_init
                 
                 /*ldi YH, high(testtest)
                 ldi YL, low(testtest)
                 ldi temp, 0xFF
                 st Y, temp
                 
                 .MACRO stw
                 ldi temp, high(@1)
                 sts @0, temp
                 ldi temp, low(@1)
                 sts @0+1, temp
                 .endm
                 
                 stw AC1, 0x0198
                 stw AC2, 0xffb8
                 stw AC3, 0xc7d1
                 stw AC4, 0x7FE5
                 stw AC5, 0x7FF5
                 stw AC6, 0x5A71
                 stw B1, 0x182E
                 stw B2, 0x0004
                 stw MB, 0x8000
                 stw MC, 0xDDF9
                 stw MD, 0x0B34
                 stw UT, 0x6CFA
                 stw UP, 0x5D23*/
                 
                 /*ldi temp, 0x12
                 sts X1, temp
                 ldi temp, 0x34
                 sts X1+1, temp
                 
                 ldi temp, 0x56
                 sts X1+2, temp
                 ldi temp, 0x78
                 sts X1+3, temp
                 
                 ldi temp, 0x87
                 sts X2, temp
                 ldi temp, 0x65
                 sts X2+1, temp
                 
                 ldi temp, 0x43
                 sts X2+2, temp
                 ldi temp, 0x21
                 sts X2+3, temp
                 
                 tmul32 X1, X2, T
                 muli32 X2, 0x12345678, X3
                 mul16 X1, X2, B5
                 muli16 X1, 0x4321, B6
                 
                 //swldw X1, 10, X2
                 //mulwdw X1+2, X1, X1
                 
                 call bmp_calculate*/
                 
                 //-----------MAIN----------------------------------
                 main:
                 
001753 940e 0bfc 	call GSM_main
001755 940e 0426
001757 940e 0488 	Refresh_time
001759 940e 14cc 	call Temperature
00175b 932f
00175c 93bf
00175d 93af
00175e 931f
00175f 93df
001760 93cf
001761 940e 0115
001763 e0d1
001764 e2c0
001765 8128
001766 e110
001767 9f12
001768 2da0
001769 2db1
00176a e610
00176b 0fa1
00176c 2711
00176d 1fb1
00176e 931f
00176f 930f
001770 931f
001771 930f
001772 e010
001773 e800
001774 940e 0030
001776 910f
001777 911f
001778 939f
001779 938f
00177a 937f
00177b ef90
00177c e081
00177d e071
00177e 940e 0029
001780 917f
001781 918f
001782 919f
001783 910f
001784 911f
001785 931f
001786 930f
001787 93af
001788 93bf
001789 933f
00178a e014
00178b e131
00178c 910d
00178d 940e 0030
00178f 939f
001790 938f
001791 937f
001792 ef90
001793 e081
001794 e071
001795 940e 0029
001797 917f
001798 918f
001799 919f
00179a 953a
00179b f781
00179c 913f
00179d 91bf
00179e 91af
00179f 910f
0017a0 911f
0017a1 e110
0017a2 9f12
0017a3 2da0
0017a4 2db1
0017a5 ec10
0017a6 0fa1
0017a7 2711
0017a8 1fb1
0017a9 931f
0017aa 930f
0017ab 931f
0017ac 930f
0017ad e010
0017ae ec00
0017af 940e 0030
0017b1 910f
0017b2 911f
0017b3 939f
0017b4 938f
0017b5 937f
0017b6 ef90
0017b7 e081
0017b8 e071
0017b9 940e 0029
0017bb 917f
0017bc 918f
0017bd 919f
0017be 910f
0017bf 911f
0017c0 931f
0017c1 930f
0017c2 93af
0017c3 93bf
0017c4 933f
0017c5 e014
0017c6 e131
0017c7 910d
0017c8 940e 0030
0017ca 939f
0017cb 938f
0017cc 937f
0017cd ef90
0017ce e081
0017cf e071
0017d0 940e 0029
0017d2 917f
0017d3 918f
0017d4 919f
0017d5 953a
0017d6 f781
0017d7 913f
0017d8 91bf
0017d9 91af
0017da 910f
0017db 911f
0017dc 91cf
0017dd 91df
0017de 911f
0017df 91af
0017e0 91bf
0017e1 912f      	menu_refresh
0017e2 939f
0017e3 938f
0017e4 937f
0017e5 ef9f
0017e6 ef8f
0017e7 ef7f
0017e8 940e 0029
0017ea 917f
0017eb 918f
0017ec 919f      	delay 255,255,255		//long delay
                 
0017ed cf65      rjmp main		
                 //-------------------------------------------------
                 //========EEPROM SEGMENT=================================================
                 .eseg
                 .include "EEPROM.inc"
                 
                  * EEPROM.inc
                  *
                  *  Created: 30.03.2016 0:35:04
                  *   Author: Hogs
                  */ 
                 
                 .org 0
                 
                 //--------------- MENU strings ------------------------------------------
000000 50
000001 72
000002 65
000003 73
000004 73
000005 75
000006 72
000007 65
000008 20
000009 20
00000a 20
00000b 20
00000c 20
00000d 20
00000e 20
00000f 02        ee_pressure_msg:.db "Pressure       ",2		//menu strings
000010 54
000011 65
000012 6d
000013 70
000014 65
000015 72
000016 61
000017 74
000018 75
000019 72
00001a 65
00001b 20
00001c 20
00001d 20
00001e 20
00001f 00        ee_temp_msg:	.db "Temperature    ",0		//0 is up arrow
000020 54
000021 69
000022 6d
000023 65
000024 20
000025 20
000026 20
000027 20
000028 20
000029 20
00002a 20
00002b 20
00002c 20
00002d 20
00002e 20
00002f 00        ee_time_msg:	.db "Time           ",0
000030 4d
000031 65
000032 6d
000033 6f
000034 72
000035 79
000036 20
000037 43
000038 61
000039 72
00003a 64
00003b 20
00003c 20
00003d 20
00003e 20
00003f 00        ee_mc_msg:		.db "Memory Card    ",0
000040 53
000041 4d
000042 53
000043 20
000044 72
000045 65
000046 73
000047 70
000048 6f
000049 6e
00004a 73
00004b 65
00004c 20
00004d 20
00004e 20
00004f 00        ee_sms_msg:		.db "SMS response   ",0
000050 53
000051 6f
000052 75
000053 6e
000054 64
000055 20
000056 20
000057 20
000058 20
000059 20
00005a 20
00005b 20
00005c 20
00005d 20
00005e 20
00005f 00        ee_sound_msg:	.db "Sound          ",0
000060 37
000061 36
000062 30
000063 20
000064 6d
000065 6d
000066 48
000067 67
000068 20
000069 20
00006a 20
00006b 20
00006c 20
00006d 20
00006e 20
00006f 01        ee_test_msg1:	.db "760 mmHg       ",1		//1 is down arrow
000070 20
000071 32
000072 35
000073 20
000074 43
000075 20
000076 20
000077 20
000078 6d
000079 61
00007a 78
00007b 20
00007c 39
00007d 39
00007e 20
00007f 01        ee_test_msg2:	.db " 25 C   max 99 ",1
000080 31
000081 32
000082 3a
000083 33
000084 34
000085 20
000086 31
000087 34
000088 2f
000089 31
00008a 31
00008b 2f
00008c 31
00008d 35
00008e 20
00008f 01        ee_test_msg3:	.db "12:34 14/11/15 ",1
000090 4f
000091 66
000092 66
000093 20
000094 20
000095 20
000096 20
000097 20
000098 20
000099 20
00009a 20
00009b 20
00009c 20
00009d 20
00009e 20
00009f 01        ee_test_msg4:	.db "Off            ",1
0000a0 4f
0000a1 66
0000a2 66
0000a3 20
0000a4 20
0000a5 20
0000a6 20
0000a7 20
0000a8 20
0000a9 20
0000aa 20
0000ab 20
0000ac 20
0000ad 20
0000ae 20
0000af 01        ee_test_msg5:	.db "Off            ",1
0000b0 4f
0000b1 66
0000b2 66
0000b3 20
0000b4 20
0000b5 20
0000b6 20
0000b7 20
0000b8 20
0000b9 20
0000ba 20
0000bb 20
0000bc 20
0000bd 20
0000be 20
0000bf 02        ee_test_msg6:	.db "Off            ",2
                 //------------------------------------------------------------------------
                 
                 //------------ GSM strings -----------------------------------------------
0000c0 2b
0000c1 43
0000c2 4d
0000c3 54
0000c4 49
0000c5 3a
0000c6 20
0000c7 22
0000c8 53
0000c9 4d
0000ca 22
0000cb 2c
0000cc 00        ee_gsm_new_SMS:				.db "+CMTI: ",'"',"SM",'"',',',0    //+CMTI: "SM",INDEX  
0000cd 41
0000ce 54
0000cf 2b
0000d0 43
0000d1 4d
0000d2 47
0000d3 52
0000d4 3d
0000d5 00        ee_gsm_read_SMS1:			.db "AT+CMGR=",0
0000d6 2c
0000d7 30
0000d8 00        ee_gsm_read_SMS2:			.db ",0",0
0000d9 4f
0000da 4b
0000db 00        ee_gsm_result:				.db "OK",0
0000dc 41
0000dd 54
0000de 2b
0000df 43
0000e0 4d
0000e1 47
0000e2 53
0000e3 3d
0000e4 00        ee_gsm_write:				.db "AT+CMGS=",0
0000e5 3e
0000e6 00        ee_gsm_write_msg:			.db ">",0
0000e7 0d
0000e8 00        ee_gsm_enter:				.db 0x0D,0
0000e9 1a
0000ea 00        ee_gsm_end_msg:				.db 0x1A,0
0000eb 22
0000ec 2c
0000ed 00        ee_gsm_phone_start:			.db '"',',',0
0000ee 64
0000ef 65
0000f0 76
0000f1 69
0000f2 63
0000f3 65
0000f4 20
0000f5 67
0000f6 65
0000f7 74
0000f8 00        ee_gsm_cmd1:				.db "device get",0
0000f9 64
0000fa 65
0000fb 76
0000fc 69
0000fd 63
0000fe 65
0000ff 20
000100 73
000101 65
000102 74
000103 00        ee_gsm_cmd2:				.db "device set",0
000104 69
000105 6e
000106 66
000107 6f
000108 00        ee_gsm_info_parameter:		.db "info",0
000109 74
00010a 69
00010b 6d
00010c 65
00010d 00        ee_gsm_time_parameter:		.db "time",0
00010e 74
00010f 65
000110 6d
000111 70
000112 00        ee_gsm_temp_parameter:		.db "temp",0
000113 70
000114 72
000115 65
000116 73
000117 73
000118 75
000119 72
00011a 65
00011b 00        ee_gsm_pressure_parameter:	.db "pressure",0
00011c 73
00011d 6f
00011e 75
00011f 6e
000120 64
000121 00        ee_gsm_sound_parameter:		.db "sound",0
000122 6d
000123 65
000124 6d
000125 6f
000126 72
000127 79
000128 00        ee_gsm_memory_parameter:	.db "memory",0
000129 69
00012a 6e
00012b 76
00012c 61
00012d 6c
00012e 69
00012f 64
000130 20
000131 67
000132 65
000133 74
000134 20
000135 63
000136 6f
000137 6d
000138 6d
000139 61
00013a 6e
00013b 64
00013c 2c
00013d 20
00013e 79
00013f 6f
000140 75
000141 20
000142 63
000143 61
000144 6e
000145 20
000146 75
000147 73
000148 65
000149 20
00014a 6f
00014b 6e
00014c 6c
00014d 79
00014e 0d
00014f 69
000150 6e
000151 66
000152 6f
000153 0d
000154 74
000155 69
000156 6d
000157 65
000158 0d
000159 74
00015a 65
00015b 6d
00015c 70
00015d 0d
00015e 70
00015f 72
000160 65
000161 73
000162 73
000163 75
000164 72
000165 65
000166 0d
000167 73
000168 6f
000169 75
00016a 6e
00016b 64
00016c 0d
00016d 6d
00016e 65
00016f 6d
000170 6f
000171 72
000172 79
000173 0d
000174 63
000175 6f
000176 6d
000177 6d
000178 61
000179 6e
00017a 64
00017b 73
00017c 00        ee_gsm_invalid_get:			.db "invalid get command, you can use only", 0x0D, "info", 0x0D, "time", 0x0D, "temp", 0x0D, "pressure", 0x0D, "sound", 0x0D, "memory", 0x0D, "commands", 0
00017d 69
00017e 6e
00017f 76
000180 61
000181 6c
000182 69
000183 64
000184 20
000185 73
000186 65
000187 74
000188 20
000189 63
00018a 6f
00018b 6d
00018c 6d
00018d 61
00018e 6e
00018f 64
000190 2c
000191 20
000192 79
000193 6f
000194 75
000195 20
000196 63
000197 61
000198 6e
000199 20
00019a 75
00019b 73
00019c 65
00019d 20
00019e 6f
00019f 6e
0001a0 6c
0001a1 79
0001a2 0d
0001a3 74
0001a4 69
0001a5 6d
0001a6 65
0001a7 0d
0001a8 73
0001a9 6f
0001aa 75
0001ab 6e
0001ac 64
0001ad 0d
0001ae 6d
0001af 65
0001b0 6d
0001b1 6f
0001b2 72
0001b3 79
0001b4 0d
0001b5 63
0001b6 6f
0001b7 6d
0001b8 6d
0001b9 61
0001ba 6e
0001bb 64
0001bc 73
0001bd 00        ee_gsm_invalid_set:			.db "invalid set command, you can use only", 0x0D, "time", 0x0D, "sound", 0x0D, "memory", 0x0D, "commands", 0
0001be 4f
0001bf 6e
0001c0 20
0001c1 00        ee_On_str:					.db "On ",0
0001c2 4f
0001c3 66
0001c4 66
0001c5 00        ee_Off_str:					.db "Off",0
0001c6 69
0001c7 6e
0001c8 76
0001c9 61
0001ca 6c
0001cb 69
0001cc 64
0001cd 20
0001ce 74
0001cf 69
0001d0 6d
0001d1 65
0001d2 20
0001d3 73
0001d4 65
0001d5 74
0001d6 2c
0001d7 20
0001d8 75
0001d9 73
0001da 65
0001db 0d
0001dc 64
0001dd 65
0001de 76
0001df 69
0001e0 63
0001e1 65
0001e2 20
0001e3 73
0001e4 65
0001e5 74
0001e6 20
0001e7 74
0001e8 69
0001e9 6d
0001ea 65
0001eb 20
0001ec 32
0001ed 33
0001ee 3a
0001ef 34
0001f0 35
0001f1 20
0001f2 31
0001f3 39
0001f4 2f
0001f5 30
0001f6 34
0001f7 2f
0001f8 31
0001f9 36
0001fa 00        ee_gsm_invalid_time:		.db "invalid time set, use", 0x0D, "device set time 23:45 19/04/16",0
0001fb 69
0001fc 6e
0001fd 76
0001fe 61
0001ff 6c
000200 69
000201 64
000202 20
000203 4f
000204 6e
000205 2f
000206 4f
000207 66
000208 66
000209 20
00020a 73
00020b 65
00020c 74
00020d 2c
00020e 20
00020f 75
000210 73
000211 65
000212 0d
000213 64
000214 65
000215 76
000216 69
000217 63
000218 65
000219 20
00021a 73
00021b 65
00021c 74
00021d 20
00021e 73
00021f 6f
000220 75
000221 6e
000222 64
000223 20
000224 4f
000225 4e
000226 0d
000227 6f
000228 72
000229 0d
00022a 64
00022b 65
00022c 76
00022d 69
00022e 63
00022f 65
000230 20
000231 73
000232 65
000233 74
000234 20
000235 6d
000236 65
000237 6d
000238 6f
000239 72
00023a 79
00023b 20
00023c 4f
00023d 46
00023e 46
00023f 00        ee_gsm_invalid_OnOff:		.db "invalid On/Off set, use", 0x0D, "device set sound ON", 0x0D, "or", 0x0D, "device set memory OFF",0  
000240 45
000241 52
000242 52
000243 4f
000244 52
000245 00        ee_gsm_Error:				.db "ERROR",0
000246 41
000247 54
000248 45
000249 30
00024a 20
00024b 20
00024c 0d
00024d 00
00024e 00
00024f 00        ee_gsm_CSQ:					.db "ATE0  ",0x0D,0,0,0
                 //------------------------------------------------------------------------
000250 ff
000251 ff
000252 ff
000253 ff
000254 ff
000255 ff
000256 ff
000257 ff
000258 ff
000259 ff
00025a ff
00025b ff
00025c ff
00025d ff
00025e ff
00025f ff
000260 ff
000261 ff
000262 ff
000263 ff
000264 ff
000265 ff
000266 ff
000267 ff
000268 ff
000269 ff
00026a ff
00026b ff
00026c ff
00026d ff
00026e ff
00026f ff
000270 ff
000271 ff
000272 ff
000273 ff
000274 ff
000275 ff
000276 ff
000277 ff
000278 ff
000279 ff
00027a ff
00027b ff
00027c ff
00027d ff
00027e ff
00027f ff
000280 ff
000281 ff
000282 ff
000283 ff
000284 ff
000285 ff
000286 ff
000287 ff
000288 ff
000289 ff
00028a ff
00028b ff
00028c ff
00028d ff
00028e ff
00028f ff
000290 ff
000291 ff
000292 ff
000293 ff
000294 ff
000295 ff
000296 ff
000297 ff
000298 ff
000299 ff
00029a ff
00029b ff
00029c ff
00029d ff
00029e ff
00029f ff
0002a0 ff
0002a1 ff
0002a2 ff
0002a3 ff
0002a4 ff
0002a5 ff
0002a6 ff
0002a7 ff
0002a8 ff
0002a9 ff
0002aa ff
0002ab ff
0002ac ff
0002ad ff
0002ae ff
0002af ff
0002b0 ff
0002b1 ff
0002b2 ff
0002b3 ff
0002b4 ff
0002b5 ff
0002b6 ff
0002b7 ff
0002b8 ff
0002b9 ff
0002ba ff
0002bb ff
0002bc ff
0002bd ff
0002be ff
0002bf ff
0002c0 ff
0002c1 ff
0002c2 ff
0002c3 ff
0002c4 ff
0002c5 ff
0002c6 ff
0002c7 ff
0002c8 ff
0002c9 ff
0002ca ff
0002cb ff
0002cc ff
0002cd ff
0002ce ff
0002cf ff
0002d0 ff
0002d1 ff
0002d2 ff
0002d3 ff
0002d4 ff
0002d5 ff
0002d6 ff
0002d7 ff
0002d8 ff
0002d9 ff
0002da ff
0002db ff
0002dc ff
0002dd ff
0002de ff
0002df ff
0002e0 ff
0002e1 ff
0002e2 ff
0002e3 ff
0002e4 ff
0002e5 ff
0002e6 ff
0002e7 ff
0002e8 ff
0002e9 ff
0002ea ff
0002eb ff
0002ec ff
0002ed ff
0002ee ff
0002ef ff
0002f0 ff
0002f1 ff
0002f2 ff
0002f3 ff
0002f4 ff
0002f5 ff
0002f6 ff
0002f7 ff
0002f8 ff
0002f9 ff
0002fa ff
0002fb ff
0002fc ff
0002fd ff
0002fe ff
0002ff ff
000300 ff
000301 ff
000302 ff
000303 ff
000304 ff
000305 ff
000306 ff
000307 ff
000308 ff
000309 ff
00030a ff
00030b ff
00030c ff
00030d ff
00030e ff
00030f ff
000310 ff
000311 ff
000312 ff
000313 ff
000314 ff
000315 ff
000316 ff
000317 ff
000318 ff
000319 ff
00031a ff
00031b ff
00031c ff
00031d ff
00031e ff
00031f ff
000320 ff
000321 ff
000322 ff
000323 ff
000324 ff
000325 ff
000326 ff
000327 ff
000328 ff
000329 ff
00032a ff
00032b ff
00032c ff
00032d ff
00032e ff
00032f ff
000330 ff
000331 ff
000332 ff
000333 ff
000334 ff
000335 ff
000336 ff
000337 ff
000338 ff
000339 ff
00033a ff
00033b ff
00033c ff
00033d ff
00033e ff
00033f ff
000340 ff
000341 ff
000342 ff
000343 ff
000344 ff
000345 ff
000346 ff
000347 ff
000348 ff
000349 ff
00034a ff
00034b ff
00034c ff
00034d ff
00034e ff
00034f ff
000350 ff
000351 ff
000352 ff
000353 ff
000354 ff
000355 ff
000356 ff
000357 ff
000358 ff
000359 ff
00035a ff
00035b ff
00035c ff
00035d ff
00035e ff
00035f ff
000360 ff
000361 ff
000362 ff
000363 ff
000364 ff
000365 ff
000366 ff
000367 ff
000368 ff
000369 ff
00036a ff
00036b ff
00036c ff
00036d ff
00036e ff
00036f ff
000370 ff
000371 ff
000372 ff
000373 ff
000374 ff
000375 ff
000376 ff
000377 ff
000378 ff
000379 ff
00037a ff
00037b ff
00037c ff
00037d ff
00037e ff
00037f ff
000380 ff
000381 ff
000382 ff
000383 ff
000384 ff
000385 ff
000386 ff
000387 ff
000388 ff
000389 ff
00038a ff
00038b ff
00038c ff
00038d ff
00038e ff
00038f ff
000390 ff
000391 ff
000392 ff
000393 ff
000394 ff
000395 ff
000396 ff
000397 ff
000398 ff
000399 ff
00039a ff
00039b ff
00039c ff
00039d ff
00039e ff
00039f ff
0003a0 ff
0003a1 ff
0003a2 ff
0003a3 ff
0003a4 ff
0003a5 ff
0003a6 ff
0003a7 ff
0003a8 ff
0003a9 ff
0003aa ff
0003ab ff
0003ac ff
0003ad ff
0003ae ff
0003af ff
0003b0 ff
0003b1 ff
0003b2 ff
0003b3 ff
0003b4 ff
0003b5 ff
0003b6 ff
0003b7 ff
0003b8 ff
0003b9 ff
0003ba ff
0003bb ff
0003bc ff
0003bd ff
0003be ff
0003bf ff
0003c0 ff
0003c1 ff
0003c2 ff
0003c3 ff
0003c4 ff
0003c5 ff
0003c6 ff
0003c7 ff
0003c8 ff
0003c9 ff
0003ca ff
0003cb ff
0003cc ff
0003cd ff
0003ce ff
0003cf ff
0003d0 ff
0003d1 ff
0003d2 ff
0003d3 ff
0003d4 ff
0003d5 ff
0003d6 ff
0003d7 ff
0003d8 ff
0003d9 ff
0003da ff
0003db ff
0003dc ff
0003dd ff
0003de ff
0003df ff
0003e0 ff
0003e1 ff
0003e2 ff
0003e3 ff
0003e4 ff
0003e5 ff
0003e6 ff
0003e7 ff
0003e8 ff
0003e9 ff
0003ea ff
0003eb ff
0003ec ff
0003ed ff
0003ee ff
0003ef ff
0003f0 ff
0003f1 ff
0003f2 ff
0003f3 ff
0003f4 ff
0003f5 ff
0003f6 ff
0003f7 ff
0003f8 ff
0003f9 ff
0003fa ff
0003fb ff
0003fc ff
0003fd ff
0003fe ff        //=======================================================================


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32" register use summary:
r0 :  13 r1 :  12 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16: 820 r17:1271 r18: 165 r19: 164 r20:   0 r21:   0 r22:   0 r23: 301 
r24: 301 r25: 301 r26: 297 r27: 297 r28: 532 r29: 532 r30:  42 r31:  41 
x  :  26 y  : 266 z  :  14 
Registers used: 18 out of 35 (51.4%)

"ATmega32" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  25 add   :  41 adiw  :  14 and   :   0 
andi  :  38 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  34 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  15 brlt  :   0 brmi  :   0 
brne  : 129 brpl  :   1 brsh  :  24 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  : 266 cbi   :  21 cbr   :   2 
clc   :   1 clh   :   0 cli   :  12 cln   :   0 clr   : 175 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   1 cp    :   7 cpc   :   0 
cpi   : 107 cpse  :   2 dec   :  82 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  54 inc   :  15 jmp   :   8 
ld    : 160 ldd   :   0 ldi   :1284 lds   :   8 lpm   :  27 lsl   :   0 
lsr   :   1 mov   :  41 movw  :   0 mul   :  13 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   5 ori   :  50 out   : 103 pop   :1241 
push  :1231 rcall :  79 ret   :  58 reti  :  21 rjmp  : 125 rol   :   0 
ror   :   1 sbc   :   0 sbci  :   0 sbi   :  21 sbic  :   4 sbis  :  15 
sbiw  :   1 sbr   :   1 sbrc  :   6 sbrs  :  30 sec   :   1 seh   :   0 
sei   :  13 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    : 146 std   :   0 sts   :  33 
sub   :   0 subi  :  10 swap  :   6 tst   :   6 wdr   :   0 
Instructions used: 54 out of 113 (47.8%)

"ATmega32" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x002fdc  12224      0  12224   32768  37.3%
[.dseg] 0x000060 0x00053a      0   1242   1242    2048  60.6%
[.eseg] 0x000000 0x0003ff      0   1023   1023    1024  99.9%

Assembly complete, 0 errors, 0 warnings
