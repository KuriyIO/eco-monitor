
AVRASM ver. 2.1.57  D:\diplom\eco\eco\eco.asm Mon Nov 30 22:26:06 2015

[builtin](2): Including file 'D:\dev\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m32def.inc'
D:\diplom\eco\eco\eco.asm(1): Including file 'D:\dev\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m32def.inc'
D:\diplom\eco\eco\eco.asm(44): Including file 'D:\diplom\eco\eco\int_table.inc'
D:\diplom\eco\eco\eco.asm(45): Including file 'D:\diplom\eco\eco\LCD.inc'
D:\diplom\eco\eco\eco.asm(46): Including file 'D:\diplom\eco\eco\menu.inc'
D:\diplom\eco\eco\eco.asm(47): Including file 'D:\diplom\eco\eco\I2C_Real_Time_Clock.inc'
D:\diplom\eco\eco\eco.asm(48): Including file 'D:\diplom\eco\eco\TimeSet.inc'
D:\diplom\eco\eco\eco.asm(49): Including file 'D:\diplom\eco\eco\sound.inc'
D:\diplom\eco\eco\eco.asm(50): Including file 'D:\diplom\eco\eco\keyboard.inc'
D:\diplom\eco\eco\eco.asm(51): Including file 'D:\diplom\eco\eco\timers.inc'
D:\diplom\eco\eco\eco.asm(54): Including file 'D:\diplom\eco\eco\core_init.inc'
                 
                 .include "m32def.inc" //include define for ATmega32 controller
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m32def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega32
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega32
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M32DEF_INC_
                 #define _M32DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega32
                 #pragma AVRPART ADMIN PART_NAME ATmega32
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x02
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	OCR0	= 0x3c
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	OCDR	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDTOE	= 4	; RW
                 .equ	WDDE	= WDTOE	; For compatibility
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF2	= 5	; External Interrupt Flag 2
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - General Interrupt Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	ISC2	= 6	; Interrupt Sense Control 2
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0 - Timer/Counter Control Register
                 .equ	CS00	= 0	; Clock Select 1
                 .equ	CS01	= 1	; Clock Select 1
                 .equ	CS02	= 2	; Clock Select 2
                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                 .equ	CTC0	= WGM01	; For compatibility
                 .equ	COM00	= 4	; Compare match Output Mode 0
                 .equ	COM01	= 5	; Compare Match Output Mode 1
                 .equ	WGM00	= 6	; Waveform Generation Mode
                 .equ	PWM0	= WGM00	; For compatibility
                 .equ	FOC0	= 7	; Force Output Compare
                 
                 ; TCNT0 - Timer/Counter Register
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0 - Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0	= 1	; Output Compare Flag 0
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Clear Timer/Counter2 on Compare Match
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Pulse Width Modulator Enable
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; When this bit is written to one,the Timer/Counter2 prescaler will be reset.The bit will be cleared by hardware after the operation is performed.Writing a zero to this bit will have no effect.This bit will always be read as zero if Timer/C                 ounter2 is clocked by the internal CPU clock.If this bit is written when Timer/Counter2 is operating in asynchronous mode,the bit will remain one until the prescaler has been reset.
                 .equ	ADFR	= ADATE	; For compatibility
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	ADTS0	= 5	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 6	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 7	; ADC Auto Trigger Source 2
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1&0
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PUD	= 2	; Pull-up Disable
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                 .equ	ASRE	= RWWSRE	; For compatibility
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	ASB	= RWWSB	; For compatibility
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler bits
                 .equ	TWPS1	= 1	; TWI Prescaler bits
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x085f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	OC2addr	= 0x0008	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x000a	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x000c	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x000e	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0010	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0012	; Timer/Counter1 Overflow
                 .equ	OC0addr	= 0x0014	; Timer/Counter0 Compare Match
                 .equ	OVF0addr	= 0x0016	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0018	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x001a	; USART, Rx Complete
                 .equ	UDREaddr	= 0x001c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x001e	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x0020	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0022	; EEPROM Ready
                 .equ	ACIaddr	= 0x0024	; Analog Comparator
                 .equ	TWIaddr	= 0x0026	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0028	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 42	; size in words
                 
                 #endif  /* _M32DEF_INC_ */
                 
                 
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m32def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega32
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega32
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M32DEF_INC_
                 
                 #endif  /* _M32DEF_INC_ */
                 
                 
                  .def temp=r17		   //define r16 as temp
                  .def byte=r16		   //define r17 as byte (will be used for send byte to LCD)
                  .def menu_loc=r18
                 
                 //==========DATA SEGMENT=================================================
                 // In this segment we can to reserve some memory
                 // for strings for example...
                 .dseg
                 .org 0x0060						//starting from 0x0060 because 
                 								//before that adress we have reserved memory for registers
000060           CO_msg:				.byte 16	//level CO string
000070           CH4_msg:			.byte 16	//CH4 level message string
000080           temperature_msg:	.byte 16	//Temperature message string
000090           coords_msg:			.byte 16	//Coordinates message string
0000a0           time_msg:			.byte 16	//Time message string
0000b0           sound_msg:			.byte 16	//Sound option message string
0000c0           CO_value:			.byte 16	//string which contain level CO value
0000d0           CH4_value:			.byte 16	//string which contain level CH4 value
0000e0           temperature_value:	.byte 16	//string which contain temperature value
0000f0           coords_value:		.byte 16	//string which contain coordinates value
000100           time_value:			.byte 16	//string which contain time value
000110           sound_value:		.byte 16	//string which contain sound On/Off value
000120           menu_location:		.byte 1		//current menu location
000121           tick_count:			.byte 1		//count of button activations
000122           last_btn:			.byte 1		//number of last pressed button
000123           sound_status:		.byte 1		//status of sound
000124           I2C_status:			.byte 1		//I2C status register
000125           I2C_buffer:			.byte 5		//I2C buffer
00012a           I2C_device:			.byte 1		//I2C device adress + R/W
00012b           I2C_data_pointer:	.byte 1		//pointer to clock's register
00012c           I2C_data_read:		.byte 1		//readed data
00012d           I2C_data_write:		.byte 1		//data which need to write
00012e           time_set_status:	.byte 1		//time set status register
00012f           time_set_value:		.byte 1		//contain a value which need to set
000130           time_set_ranges:	.byte 10	//contain a table with max values range
00013a           time_set_max_values:.byte 5		//caontain a max values of hh:mm dd/MM/yy
00013f           time_set_buffer:	.byte 2		//contain a active pair values
000141           time_set_blink_count:.byte 1	//count of tick before blink
                 
                 //==========CODE SEGMENT=================================================
                 .cseg
                 .include "int_table.inc"	//interrupt vectors
                 
                  * Interrupt vectors table
                  */ 
                 
                  //=========INTERRUPT VECTORS TABLE=============================================
                  .org $000 //RESET
000000 940c 0883  jmp reset 
                  .org $002 //INT0 External Interrupt Request 0
000002 9518       reti
                  .org $004 //INT1 External Interrupt Request 1
000004 9518       reti
                  .org $006 //INT2 External Interrupt Request 2
000006 9518       reti
                  .org $008 //TIMER2 COMP Timer/Counter2 Compare Match
000008 9518       reti
                  .org $00A //TIMER2 OVF Timer/Counter2 Overflow
00000a 9518       reti
                  .org $00C //TIMER1 CAPT Timer/Counter1 Capture Event
00000c 9518       reti
                  .org $00E //TIMER1 COMPA Timer/Counter1 Compare Match A
00000e 940c 0832  jmp Keyboard_check_interrupt
                  .org $010 //TIMER1 COMPB Timer/Counter1 Compare Match B
000010 c52c       rjmp Sound_play_and_pause
                  .org $012 //TIMER1 OVF Timer/Counter1 Overflow
000012 9518       reti
                  .org $014 //TIMER0 COMP Timer/Counter0 Compare Match
000014 c522       rjmp Sound_generation
                  .org $016 //TIMER0 OVF Timer/Counter0 Overflow
000016 9518       reti
                  .org $018 //SPI, STC Serial Transfer Complete
000018 9518       reti
                  .org $01A //USART, RXC USART, Rx Complete
00001a 9518       reti
                  .org $01C //USART, UDRE USART Data Register Empty
00001c 9518       reti
                  .org $01E //USART, TXC USART, Tx Complete
00001e 9518       reti
                  .org $020 //ADC ADC Conversion Complete
000020 9518       reti
                  .org $022 //EE_RDY EEPROM Ready
000022 9518       reti
                  .org $024 //ANA_COMP Analog Comparator
000024 9518       reti
                  .org $026 //TWI Two-wire Serial Interface
000026 c037       rjmp I2C_Interrupt
                  .org $028 //SPM_RDY Store Program Memory Ready
000028 9518       reti
                 //===============================================================================================
                 
                 .include "LCD.inc"			//macro and procedures for HD44780 like displays
                 
                  * Macro and procedures
                  * for HD44780 like LCD 
                  * Sorry for bad english...
                  */ 
                 
                  .equ data = 0x04	   //create constant cmd = 0b00000100 
                  .equ cmd = 0		   //create constant data = 0
                  .equ RS = 2		   //RS - 2nd pin in port C
                  .equ E = 3			   //E - is strob line, is a 3rd pin in port C
                  .equ D4 = 4		   //LCD data pins in port C
                  .equ D5 = 5
                  .equ D6 = 6
                  .equ D7 = 7
                 
                  //========MACRO================================================================
                  
                 //----------delay---------------------------------------------
                   
                  .macro delay
                  push r25
                  push r24
                  push r23
                 
                  ldi r25,@0
                  ldi r24,@1
                  ldi r23,@2
                 
                  call delay_proc
                 
                  pop r23
                  pop r24
                  pop r25
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      LCD initialization
                  .macro LCD_init
                  LCD_port_init		//init port C as output
                 
                  delay 242,15,5		//50 ms delay
                  ldi temp,0x30
                  out portc,temp		//send 0x30
                  sbi portc,E
                  lpm
                  cbi portc,E
                  delay 229,30,9		//100 ms delay
                  sbi portc,E
                  lpm				//send 0x30
                  cbi portc,E
                  delay 242,15,5		//50 ms delay 
                  sbi portc,E
                  lpm				//send 0x30
                  cbi portc,E
                  delay 242,15,5		//50 ms delay
                  ldi temp,0x20
                  out portc,temp
                  sbi portc,E		//send 0x20
                  lpm
                  cbi portc,E
                  delay 240,1,1		//delay 45us
                 
                  LCD_send_cmd 0x28	//init 4-bit mode 2 lines
                  delay 240,1,1 //delay 45us
                  LCD_send_cmd 0x01	//clear display
                  delay 142,42,1 //delay 2ms
                  LCD_send_cmd 0x0F	//display ON
                  delay 142,42,1 //delay 2ms
                 
                  LCD_send_cmd 0b0100_0000	//Set CGRAM adress as 0x00
                  delay 240,1,1 //delay 45us
                 
                  LCD_send_symbol 0b00000000			//Start sending bytes for draw a new symbol
                  delay 240,1,1 //delay 45us			//in this case i draw upper arrow
                  LCD_send_symbol 0b00000000			//for do that i sending next bytes
                  delay 240,1,1 //delay 45us			//
                  LCD_send_symbol 0b00000000			//00000000
                  delay 240,1,1 //delay 45us			//00000000
                  LCD_send_symbol 0b00000000			//00000000
                  delay 240,1,1 //delay 45us			//00000000
                  LCD_send_symbol 0b00000100			//00000100
                  delay 240,1,1 //delay 45us			//00001110
                  LCD_send_symbol 0b00001110			//00011111
                  delay 240,1,1 //delay 45us			//00000000
                  LCD_send_symbol 0b00011111			//
                  delay 240,1,1 //delay 45us			//
                  LCD_send_symbol 0b00000000			//
                  delay 240,1,1 //delay 45us			//
                 
                  LCD_send_symbol 0b00000000			//the same like previous but for draw down arrow
                  delay 240,1,1 //delay 45us
                  LCD_send_symbol 0b00011111
                  delay 240,1,1 //delay 45us
                  LCD_send_symbol 0b00001110
                  delay 240,1,1 //delay 45us
                  LCD_send_symbol 0b00000100
                  delay 240,1,1 //delay 45us
                  LCD_send_symbol 0b00000000
                  delay 240,1,1 //delay 45us
                  LCD_send_symbol 0b00000000
                  delay 240,1,1 //delay 45us
                  LCD_send_symbol 0b00000000
                  delay 240,1,1 //delay 45us
                  LCD_send_symbol 0b00000000
                  delay 240,1,1 //delay 45us
                 
                  first_line	//set DDRAM as 0 (in start of first line)
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      LCD clear
                  .macro LCD_clear
                  push temp
                  push byte
                  LCD_send_cmd 0x01	//clear display
                  delay 142,42,1 //delay 2ms
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      1st line
                  .macro first_line
                  push temp
                  push byte
                  LCD_send_cmd 0x80	//first line
                  delay 240,1,1 //delay 45us
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      2nd line
                  .macro second_line
                  push temp
                  push byte
                  LCD_send_cmd 0xC0	//second line
                  delay 240,1,1 //delay 45us
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      set port C as output for working with display
                  .macro LCD_port_init  
                  in temp, ddrc
                  ori temp, (0 | (1<<RS) | (1<<E) | (1<<D4) | (1<<D5) | (1<<D6) | (1<<D7))
                  out ddrc,temp
                  in temp,portc
                  andi temp, (~(0 | (1<<RS) | (1<<E) | (1<<D4) | (1<<D5) | (1<<D6) | (1<<D7)))
                  out portc,temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      send command to LCD
                  .macro LCD_send_cmd
                  push temp
                  push byte	
                  ldi temp,cmd
                  ldi byte,@0
                  call LCD_send_byte_proc
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      send symbol to LCD
                  .macro LCD_send_symbol	
                  push temp
                  push byte
                  ldi temp,4
                  ldi byte,@0
                  call LCD_send_byte_proc
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      print 16-symbol string from sram adress (if adress is const)
                  .macro LCD_print_str
                  push ZH
                  push ZL
                  push temp
                  push byte
                  push r19
                  ldi ZH,high(@0)	//load to high Z-byte high byte of adress
                  ldi ZL,low(@0)	//load to low Z-byte low byte of adress
                  ldi temp,data	//temp = 0x04 for send data to LCD
                 
                  ldi r19,17			//r19 is a counter
                  sram_read_loop:	//loop 16 times
                  ld byte,Z+			//read from SRAM and post-inc
                  call LCD_send_byte_proc	//print symbol to LCD
                  delay 240,1,1 //delay 45us
                  dec r19			//loop things...
                  brne sram_read_loop//go to sram_read_loop label if r19 is not 0
                 
                  pop r19
                  pop byte
                  pop temp
                  pop ZL
                  pop ZH
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                  //      print 16-symbol string from sram adress (if adress is in register)
                  //					ADRESS MUST BE IN X REGISTER
                  .macro LCD_print_str_reg
                  push temp
                  push byte
                  push XL
                  push XH
                  push r19
                 
                  ldi temp,data	//temp = 0x04 for send data to LCD
                 
                  ldi r19,17			//r19 is a counter
                  sram_read_loop:	//loop 16 times
                  ld byte,X+			//read from SRAM and post-inc
                  call LCD_send_byte_proc	//print symbol to LCD
                  delay 240,1,1 //delay 45us
                  dec r19			//loop things...
                  brne sram_read_loop//go to sram_read_loop label if r19 is not 0
                 
                  pop r19
                  pop XH
                  pop XL
                  pop byte
                  pop temp
                  .endm
                 
                 //------------------------------------------------------------------------
                 
                 //==============PROCEDURES=====================================================
                 
                  //------delay proc-------------------------------------------------------
                       
                  delay_proc:
                 
                 delay_proc_label: 
000029 959a      	dec  r25
00002a f7f1          brne delay_proc_label
00002b 958a          dec  r24
00002c f7e1          brne delay_proc_label
00002d 957a      	dec  r23
00002e f7d1          brne delay_proc_label
                 
00002f 9508       ret
                 
                 //------Send byte to LCD as 4-but mode------------------------------------
                 
                  LCD_send_byte_proc:
000030 94f8       cli
000031 930f       push byte //save symbol to stack
000032 7014       andi temp,0b0000_0100
000033 bb15       out portc,temp //setting RS line
                 
                  //======High half-byte send=======
000034 7f00       andi byte,0xF0 //clear low half-byte
                 				//example:
                 				//before ANDI byte was 0b01011111
                 				//after byte is 0b01010000
                 
000035 2b10       or temp,byte	//add high half-byte to temp register
                 				//example:
                 				//before: temp = 0b00000100, byte = 0b11110000
                 				//after: temp = 0b11110100
                 
000036 bb15       out portc,temp //out temp to port C
000037 95c8       lpm			//3 clocks delay
000038 9aab       sbi portc,E	//enable E signal
000039 95c8       lpm			//3 clocks delay
00003a 98ab       cbi portc,E	//disable E signal
00003b 939f
00003c 938f
00003d 937f
00003e ef90
00003f e081
000040 e071
000041 940e 0029
000043 917f
000044 918f
000045 919f       delay 240,1,1 //delay 45us
                  //======Low half-byte send========
000046 7014       andi temp,0b0000_0100
000047 910f       pop byte		//get symbol from stack
000048 9502       swap byte		//swap byte register
                 				//example:
                 				//before swap byte was: 0b01011010
                 				//after swap byte is:   0b10100101
000049 7f00       andi byte,0xF0 //clear high half-byte
                 				//example:
                 				//before andi: byte = 0b01011010
                 				//after: byte = 0b01010000
                 
00004a 2b10       or temp,byte	//add symbol's low half-byte 
00004b bb15       out portc,temp //out temp to port C
00004c 95c8       lpm			//3 clocks delay
00004d 9aab       sbi portc,E	//enable E
00004e 95c8       lpm			//3 clocks delay
00004f 98ab       cbi portc,E	//disable E
000050 95c8       lpm			//3 clocks delay
                  //=====Set port C as 0xFF=========
000051 ef00       ldi byte,0xF0
000052 bb05       out portc,byte	//out to port C 0b11110000
000053 9478       sei
000054 9508       ret
                 //------------------------------------------------------------------------
                 //                          sorry for bad english
                 .include "menu.inc"			//macro for menu uses
                 
                  * menu.inc
                  *
                  *  Created: 26.10.2015 0:27:02
                  *   Author: Hogs
                  */ 
                 
                  //========MACRO==========================================
                 
                  //--------Init menu page--------------------
                  .macro menu_init
                 
                  load_strings_to_SRAM		//save strings from eeprom to ram
                 
                  ldi YH,high(menu_location) //set current menu page as 0 (first page)
                  ldi YL,low(menu_location)	//
                  ldi temp,0
                  st Y,temp
                 
                  LCD_print_str CO_msg		//print first menu page
                  second_line
                  LCD_print_str CO_msg+96
                  .endm
                  //------------------------------------------
                  //--------Menu refresh page----------------
                  .macro menu_refresh
                 
                  push menu_loc			//Save all register which will be used
                  push XH				//
                  push XL				//
                  push temp
                  push YH
                  push YL
                 
                  ldi YH,high(menu_location)		//load to Y register adress of
                  ldi YL,low(menu_location)		//current menu page
                  ld menu_loc,Y					//read from SRAM current menu page
                  
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain first string
                  mov XH,r1					//of menu message
                  ldi temp,0x60				//
                  add XL,temp				//adress = ((page - 1)*16)+96
                  clr temp					//
                  adc XH,temp				//
                 
                  first_line					//set first line for print
                  LCD_print_str_reg			//print message from adress (in X register)
                 
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain second string
                  mov XH,r1					//of menu message
                  ldi temp,0xC0				//
                  add XL,temp				//adress = ((page - 1) * 16)+192
                  clr temp					//
                  adc XH,temp				//
                 
                  second_line				//set second line for print
                  LCD_print_str_reg			//print second string
                 		
                  pop YL					//return all of used registers
                  pop YH					//to their place
                  pop temp
                  pop XL
                  pop XH
                  pop menu_loc
                 
                  .endm
                 
                  //--------Menu previous page----------------
                  .macro menu_prev
                 
                  push menu_loc			//Save all register which will be used
                  push XH				//
                  push XL				//
                  push temp
                  push YH
                  push YL
                 
                  ldi YH,high(menu_location)		//load to Y register adress of
                  ldi YL,low(menu_location)		//current menu page
                  ld menu_loc,Y					//read from SRAM current menu page
                 
                  ldi temp,0					//if current page is first
                  cpse menu_loc,temp			//then going out of procedure
                  rjmp PC+2					//else - continue
                  rjmp return_menu_prev		//
                 
                  dec menu_loc				//decrease page because menu moving up
                  
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain first string
                  mov XH,r1					//of menu message
                  ldi temp,0x60				//
                  add XL,temp				//adress = ((page - 1)*16)+96
                  clr temp					//
                  adc XH,temp				//
                 
                  first_line					//set first line for print
                  LCD_print_str_reg			//print message from adress (in X register)
                 
                  ldi temp,16				//
                  mul temp,menu_loc			//counting adress of string
                  mov XL,r0					//which contain second string
                  mov XH,r1					//of menu message
                  ldi temp,0xC0				//
                  add XL,temp				//adress = ((page - 1) * 16)+192
                  clr temp					//
                  adc XH,temp				//
                 
                  second_line				//set second line for print
                  LCD_print_str_reg			//print second string
                 
                  ldi YH,high(menu_location)	//
                  ldi YL,low(menu_location)	//Save current page status to SRAM
                  st Y,menu_loc				//
                 
                  return_menu_prev:			
                  pop YL					//return all of used registers
                  pop YH					//to their place
                  pop temp
                  pop XL
                  pop XH
                  pop menu_loc
                 
                  .endm
                  //------------------------------------------
                 
                  //--------Menu next page--------------------
                  .macro menu_next
                 
                  push menu_loc		//save to stack
                  push XH			//all of used registers
                  push XL
                  push temp
                  push YH
                  push YL
                 
                  ldi YH,high(menu_location)	//
                  ldi YL,low(menu_location)	//read number of current page from SRAM
                  ld menu_loc,Y				//
                 
                  ldi temp,5					//if this page is last
                  cpse menu_loc,temp			//then go to return of procedure
                  rjmp PC+2					//else - continue
                  rjmp return_menu_next		//
                 
                  inc menu_loc		//increase page because moving down
                  
                  ldi temp,16			//counting of first string adress
                  mul temp,menu_loc		//and move it to X register
                  mov XL,r0				//
                  mov XH,r1				//adress = ((page + 1) * 16)+96
                  ldi temp,0x60
                  add XL,temp
                  clr temp
                  adc XH,temp
                 
                  first_line			//
                  LCD_print_str_reg	//printing first line
                 
                  ldi temp,16		//counting of second string adress
                  mul temp,menu_loc	//and move it to X register
                  mov XL,r0			//
                  mov XH,r1			//adress = ((page + 1) * 16)+192
                  ldi temp,0xC0
                  add XL,temp
                  clr temp
                  adc XH,temp
                 
                  second_line		//
                  LCD_print_str_reg	//printing second line
                 
                  ldi YH,high(menu_location)	//
                  ldi YL,low(menu_location)	//save new current page to SRAM
                  st Y,menu_loc				//
                 
                  return_menu_next:
                  pop YL				//return all of used registers
                  pop YH				//
                  pop temp
                  pop XL
                  pop XH
                  pop menu_loc
                 
                  .endm
                  //------------------------------------------
                 
                  //      Read from EEPROM and write it in SRAM
                  .macro load_strings_to_SRAM
                  cli
                  clr YH		 //load to YH register 0
                  ldi YL,0x60 //load to YL 0x60 coz 0x0060 - sram start
                  clr ZL		 //clear Z register
                  clr ZH
                  //?????????????????-----DEBUG------????????????????????????????????????????????????????????????????????
                  ldi r19,193			//r19 is a counter
                 						//USE <LDI r19,97> AFTER DEBUG
                  //?????????????????????????????????????????????????????????????????????????????????????????????????????
                 
                  EE_read_loop:			//loop 96 times
                  call EEPROM_read_byte //read byte from EEPROM
                  st Y+,byte				//Store byte to SRAM and post-Inc adress
                  inc ZL					//increment Z register after reading byte
                 
                  dec r19				//loop things...
                  brne EE_read_loop		//go to EE_read_loop label if r19 is not 0
                  sei
                  .endm
                 
                 //--------------------------------------------
                 
                  //=========PROCEDURES=====================================
                  //------Read Byte form EEPROM-----------------------
                 
                  EEPROM_read_byte:
                  ; Wait for completion of previous write
000055 99e1       sbic EECR,EEWE
000056 cffe       rjmp EEPROM_read_byte
                 
000057 94f8       cli //disable all interrupts
                 
                  ; Set up address (Z register) in address register
000058 bbff       out EEARH, ZH
000059 bbee       out EEARL, ZL
                  ; Start eeprom read by writing EERE
00005a 9ae0       sbi EECR,EERE
                  ; Read data from data register
00005b b30d       in byte,EEDR
                 
00005c 9478       sei //enable interrupts
00005d 9508       ret
                 .include "I2C_Real_Time_Clock.inc"	//working with LCD
                 
                  * I2C_Real_Time_Clock.inc
                  *
                  *  Created: 14.11.2015 0:41:13
                  *   Author: Hogs
                  */ 
                  .equ I2C_BS = 7		//bit 7 in I2C status is busy flag (1-busy, 0-free)
                  .equ I2C_OP = 6		//bit 6 in I2C status is operation mode(1-read, 0-write)
                  .equ I2C_E = 5			//bit 5 in I2C status is error(1 - error occurred, 0 - all is ok)
                  .equ I2C_dev_id = 0b11010000	//adress of Real Time Clock
                 
                  //========INTERRUPTS=========================================
                 
                  //------On I2C interrupt------------------------------
                  I2C_Interrupt:
00005e 931f       push temp
00005f 93df       push YH
000060 93cf       push YL
                 
000061 e0d1       ldi YH, high(I2C_status)
000062 e2c4       ldi YL, low(I2C_status)
000063 8118       ld temp, Y
                 
000064 ff16       sbrs temp, 6			//skip if operation bit is 1 (read data)
000065 c0a9       rjmp I2C_write_data	//if operation bit is 0 (write data) go to I2C_write_data
                  
                  //- - - - - I2C read - - - - - -
                 
000066 711f       andi temp, ~((1<<I2C_BS)|(1<<I2C_OP)|(1<<I2C_E))
                 									//set BS flag, OP flag, E flag as 0, for comfortable 
                 									//compare of current stage operation process
                 
000067 3011       cpi temp, 1
000068 f071       breq stage_1		//go to stage 1(start)
000069 3012       cpi temp, 2
00006a f0b9       breq stage_2		//go to stage 2(device id + W)
00006b 3013       cpi temp, 3
00006c f159       breq stage_3		//go to stage 3(pointer to clock register)
                 
00006d 3014       cpi temp, 4			//some hack
00006e f409       brne PC+2				//the same as breq stage_4_read
00006f c03d       rjmp stage_4_read	//go to stage 4 for reading data(restart)
                 
000070 3015       cpi temp, 5			//some hack
000071 f409       brne PC+2				//the same as breq stage_5_read
000072 c049       rjmp stage_5_read	//go to stage 5 (device id + R)
                 
000073 3016       cpi temp, 6			//some hack
000074 f409       brne PC+2				//the same as breq stage_5_read
000075 c05a       rjmp stage_6_read	//go to stage 6 for reading data(read data)
                 
                 
000076 c074       rjmp stop_stage	//else - go to stop stage(generate stop)
                  // - - - - - - - - - - - - - - -
                 
                  //-------stage 1-----------
                  stage_1:
000077 e0d1       ldi YH,high(I2C_status)
000078 e2c4       ldi YL,low(I2C_status)
000079 8118       ld temp,Y
00007a 9513       inc temp				//set next stage
00007b 8318       st Y,temp		
                 
00007c ea15       ldi temp, ((1<<TWSTA)|(1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//generating start
00007d bf16       out TWCR,temp
                 
00007e 91cf       pop YL
00007f 91df       pop YH
000080 911f       pop temp
000081 9518       reti
                 
                  //-------stage 2-----------
                  stage_2:
000082 b111       in temp, TWSR
000083 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))	//clear prescaller bits
                 										//for comfortable compare
                 
000084 3018       cpi temp,0x08			//some hack, coz brne cannot reach label
000085 b71f       in temp,SREG			//the same as:
000086 ff11       sbrs temp, 1			// cpi temp,0x08
                 						// brne I2C_error
                 						//but have longer branch range
                 
000087 c057       rjmp I2C_error			//if got error than set error code and restart
                 
000088 e0d1       ldi YH,high(I2C_status)
000089 e2c4       ldi YL,low(I2C_status)
00008a 8118       ld temp,Y
00008b 9513       inc temp				//set next stage
00008c 8318       st Y,temp
                 
00008d e0d1       ldi YH,high(I2C_device)
00008e e2ca       ldi YL,low(I2C_device)
00008f 8118       ld temp,Y
000090 7f1e       andi temp, ~(1<<0)		//set R/W bit as 0 for write
000091 b913       out TWDR,temp			//load to TWDR SLA+W(device id + write)
                 
000092 e815       ldi temp, ((1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//send SLA+W(device id + write)
000093 bf16       out TWCR,temp
                 
000094 91cf       pop YL
000095 91df       pop YH
000096 911f       pop temp
000097 9518       reti
                 
                  //-------stage 3-----------
                  stage_3:
000098 b111       in temp, TWSR
000099 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))	//clear prescaller bits
                 										//for comfortable compare
00009a 3118       cpi temp,0x18
00009b b71f       in temp,SREG			//the same as:
00009c ff11       sbrs temp, 1			// cpi temp,0x18
                 						// brne I2C_error
                 						//but have longer branch range
                 
00009d c041       rjmp I2C_error			//if got error than set error code and restart
                 
00009e e0d1       ldi YH,high(I2C_status)
00009f e2c4       ldi YL,low(I2C_status)
0000a0 8118       ld temp,Y
0000a1 9513       inc temp				//set next stage
0000a2 8318       st Y,temp
                 
0000a3 e0d1       ldi YH,high(I2C_data_pointer)
0000a4 e2cb       ldi YL,low(I2C_data_pointer)
0000a5 8118       ld temp,Y
0000a6 b913       out TWDR,temp			//load to data pointer
                 
0000a7 e815       ldi temp, ((1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//send data pointer
0000a8 bf16       out TWCR,temp
                 
0000a9 91cf       pop YL
0000aa 91df       pop YH
0000ab 911f       pop temp
0000ac 9518       reti
                 
                  //-------stage 4 read------
                  stage_4_read:
0000ad b111       in temp, TWSR
0000ae 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))	//clear prescaller bits
                 										//for comfortable compare
0000af 3218       cpi temp,0x28
0000b0 f571       brne I2C_error			//if got error than set error code and restart
                 
0000b1 e0d1       ldi YH,high(I2C_status)
0000b2 e2c4       ldi YL,low(I2C_status)
0000b3 8118       ld temp,Y
0000b4 9513       inc temp				//set next stage
0000b5 8318       st Y,temp
                 
0000b6 ea15       ldi temp, ((1<<TWSTA)|(1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//generating start
0000b7 bf16       out TWCR,temp
                 
0000b8 91cf       pop YL
0000b9 91df       pop YH
0000ba 911f       pop temp
0000bb 9518       reti
                 
                  //-------stage 5 read------
                  stage_5_read:
0000bc b111       in temp, TWSR
0000bd 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))	//clear prescaller bits
                 										//for comfortable compare
0000be 3110       cpi temp,0x10
0000bf f4f9       brne I2C_error			//if got error than set error code and restart
                 
0000c0 e0d1       ldi YH,high(I2C_status)
0000c1 e2c4       ldi YL,low(I2C_status)
0000c2 8118       ld temp,Y
0000c3 9513       inc temp				//set next stage
0000c4 8318       st Y,temp
                 
0000c5 e0d1       ldi YH,high(I2C_device)
0000c6 e2ca       ldi YL,low(I2C_device)
0000c7 8118       ld temp,Y
0000c8 6011       ori temp, (1<<0)		//set R/W bit as 1 for read
0000c9 b913       out TWDR,temp			//load to TWDR SLA+R(device id + read)
                 
0000ca e815       ldi temp, ((1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//send SLA+R(device id + read)
0000cb bf16       out TWCR,temp
                 
0000cc 91cf       pop YL
0000cd 91df       pop YH
0000ce 911f       pop temp
0000cf 9518       reti
                 
                  //-------stage 6 read------
                  stage_6_read:
0000d0 b111       in temp, TWSR
0000d1 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))	//clear prescaller bits
                 										//for comfortable compare
0000d2 3410       cpi temp,0x40
0000d3 f459       brne I2C_error			//if got error than set error code and restart
                 
0000d4 e0d1       ldi YH,high(I2C_status)
0000d5 e2c4       ldi YL,low(I2C_status)
0000d6 8118       ld temp,Y
0000d7 9513       inc temp				//set next stage
0000d8 8318       st Y,temp
                 
0000d9 e815       ldi temp, ((1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//send data pointer
0000da bf16       out TWCR,temp
                 
0000db 91cf       pop YL
0000dc 91df       pop YH
0000dd 911f       pop temp
0000de 9518       reti
                 
                  //-------I2C error---------
                  I2C_error:
0000df e0d1       ldi YH,high(I2C_status)
0000e0 e2c4       ldi YL,low(I2C_status)
0000e1 8118       ld temp,Y
0000e2 771f       andi temp, ~(1<<I2C_BS)//clear busy flag
0000e3 6210       ori temp,(1<<I2C_E)	//set error flag
0000e4 8318       st Y,temp				//save error to I2C status
                 						//for restart operation
                 						//and after that send STOP
                 
0000e5 e915       ldi temp, ((1<<TWSTO)|(1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//generating stop
0000e6 bf16       out TWCR,temp
                 
0000e7 91cf       pop YL
0000e8 91df       pop YH
0000e9 911f       pop temp
0000ea 9518       reti
                  //-------stop stage--------
                  stop_stage:
0000eb e0d1       ldi YH,high(I2C_status)
0000ec e2c4       ldi YL,low(I2C_status)
0000ed 8118       ld temp,Y
0000ee 2711       clr temp		//set current stage 0(operation end) also clear all flags
0000ef 8318       st Y,temp
                 
                  
0000f0 e0d1       ldi YH,high(I2C_data_read)
0000f1 e2cc       ldi YL,low(I2C_data_read)
                 
0000f2 b113       in temp,TWDR			//load to temp just readed data
0000f3 8318       st Y,temp				//save it to I2C_data_read
0000f4 2711       clr temp
0000f5 b913       out TWDR,temp			//clear TWDR
                  
0000f6 e915       ldi temp, ((1<<TWSTO)|(1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//generating stop
0000f7 bf16       out TWCR,temp
                 
0000f8 91cf       pop YL
0000f9 91df       pop YH
0000fa 911f       pop temp
0000fb 9518       reti
                 
                  //-------stage 4 write------
                  stage_4_write:
0000fc b111       in temp, TWSR
0000fd 7f1c       andi temp, ~((1<<TWPS1) | (1<<TWPS0))	//clear prescaller bits
                 										//for comfortable compare
0000fe 3218       cpi temp,0x28
0000ff f6f9       brne I2C_error			//if got error than set error code and restart
                 
000100 e0d1       ldi YH,high(I2C_status)
000101 e2c4       ldi YL,low(I2C_status)
000102 8118       ld temp,Y
000103 9513       inc temp				//set next stage
000104 8318       st Y,temp
                 
000105 e0d1       ldi YH,high(I2C_data_write)
000106 e2cd       ldi YL,low(I2C_data_write)
000107 8118       ld temp,Y
000108 b913       out TWDR,temp			//load data
                 
000109 e815       ldi temp, ((1<<TWINT)|(1<<TWEN)|(1<<TWIE))	//send data
00010a bf16       out TWCR,temp
                 
00010b 91cf       pop YL
00010c 91df       pop YH
00010d 911f       pop temp
00010e 9518       reti
                 
                  //-------------------------
                 
                  //- - - - - I2C write - - - - - -
                  I2C_write_data:
                 
00010f 711f       andi temp, ~((1<<I2C_BS)|(1<<I2C_OP)|(1<<I2C_E))
                 									//set BS flag, OP flag, E flag as 0, for comfortable 
                 									//compare of current stage operation process
                 
000110 3011       cpi temp, 1
000111 f409       brne PC+2			//the same as:
                 					// cpi temp,1
                 					// breq stage_1
                 					//but have longer branch range
                 
000112 cf64       rjmp stage_1		//go to stage 1(start)
                 
                 
000113 3012       cpi temp, 2
000114 f409       brne PC+2			//the same as:
                 					// cpi temp,2
                 					// breq stage_2
                 					//but have longer branch range
000115 cf6c       rjmp stage_2		//go to stage 2(device id + W)
                 
                 
000116 3013       cpi temp, 3
000117 f409       brne PC+2			//the same as:
                 					// cpi temp,3
                 					// breq stage_3
                 					//but have longer branch range
000118 cf7f       rjmp stage_3		//go to stage 3(pointer to clock's register)
                 
                 
000119 3014       cpi temp, 4
00011a f409       brne PC+2			//the same as:
                 					// cpi temp,4
                 					// breq stage_4_write
                 					//but have longer branch range
00011b cfe0       rjmp stage_4_write	//go to stage 4 for write data(write data)
                 
00011c cfce       rjmp stop_stage	//else - go to stop stage(generate stop)
                  // - - - - - - - - - - - - - - -
                  
                  //----------------------------------------------------
                 
                  //=========MACRO============================================
                  
                  //------I2C Init-----------------------
                  .macro I2C_Init
                  ldi temp,60
                  out TWBR,temp		//set SCL frequency as 100KHz
                 
                  ldi YH,high(I2C_device)
                  ldi YL,low(I2C_device)
                  ldi temp,I2C_dev_id	//save to RAM Clock id
                  st Y,temp
                 
                  .endm
                  //-------------------------------------
                 
                  //------Correct settings---------------
                  //   That macro check clock's setting
                  //   and if some settings was wrong
                  //   then set it correct
                 
                  .macro I2C_Check_Clock_Settings
                  push temp
                  push YH
                  push YL
                 
                  ldi YH,high(I2C_data_pointer)
                  ldi YL,low(I2C_data_pointer)
                  ldi temp,0x00
                  st Y,temp
                  call I2C_read_byte
                 
                  ldi YH,high(I2C_data_read)
                  ldi YL,low(I2C_data_read)
                  ld temp,Y
                  
                  sbrc temp,7	//skip next command if clock is On
                  call I2C_Clock_Enable
                 
                  ldi YH,high(I2C_data_pointer)
                  ldi YL,low(I2C_data_pointer)
                  ldi temp,0x02
                  st Y,temp
                  call I2C_read_byte
                 
                  ldi YH,high(I2C_data_read)
                  ldi YL,low(I2C_data_read)
                  ld temp,Y
                  
                  sbrc temp,6	//skip next command if 24-hour mode is set
                  call I2C_Clock_Set_24Hour
                 
                  pop YL
                  pop YH
                  pop temp
                  .endm
                 
                  //-------------------------------------
                 
                  //------Refresh time-------------------------------------------
                  .macro Refresh_time
                  call I2C_Clock_Get_Time
                  call Time_to_string
                  .endm
                  //-------------------------------------------------------------
                  //======PROCEDURES=========================================
                  //-------Set new time----------------------
                  I2C_Clock_Set_New_Time:
00011d 931f       push temp
00011e 930f       push r16
00011f 93df       push YH
000120 93cf       push YL
                 
                  //- - - - - - - - - - - - WRITE HOURS- - - - - - - - - - - - - - - - - - - - - - - - - - 
000121 2700       clr r16
000122 e0d1       ldi YH,high(I2C_buffer)
000123 e2c5       ldi YL,low(I2C_buffer)
000124 8118       ld temp,Y
                 
000125 e0d1       ldi YH,high(I2C_data_write)
000126 e2cd       ldi YL,low(I2C_data_write)
000127 8318       st Y,temp							//save to I2C_data_write value from I2C_buffer+1
                 
000128 e0d1       ldi YH,high(I2C_data_pointer)
000129 e2cb       ldi YL,low(I2C_data_pointer)
00012a e012       ldi temp,0x02
00012b 8318       st Y,temp							//write to 0x02 adress
                 
00012c d0e9       rcall I2C_write_byte				//write hours
                 
                  //- - - - - - - - - - - - -WRITE MINUTES - - - - - - - - - - - - - - - - - - - - - - - - 
00012d 9503       inc r16
00012e e0d1       ldi YH,high(I2C_buffer)
00012f e2c5       ldi YL,low(I2C_buffer)
000130 0fc0       add YL,r16
000131 930f       push r16
000132 2700       clr r16
000133 1fd0       adc YH,r16
000134 910f       pop r16
000135 8118       ld temp,Y
                 
000136 e0d1       ldi YH,high(I2C_data_write)
000137 e2cd       ldi YL,low(I2C_data_write)
000138 8318       st Y,temp						//save to I2C_data_write value from I2C_buffer+0
                 
000139 e0d1       ldi YH,high(I2C_data_pointer)
00013a e2cb       ldi YL,low(I2C_data_pointer)
00013b e011       ldi temp,0x01
00013c 8318       st Y,temp						//write to 0x01 adress
                 
00013d d0d8       rcall I2C_write_byte			//write minutes
                 
                  //- - - - - - - - - - - - WRITE DATE - - - - - - - - - - - - - - - - - - - - - - - 
00013e 9503       inc r16
00013f e0d1       ldi YH,high(I2C_buffer)
000140 e2c5       ldi YL,low(I2C_buffer)
000141 0fc0       add YL,r16
000142 930f       push r16
000143 2700       clr r16
000144 1fd0       adc YH,r16
000145 910f       pop r16
000146 8118       ld temp,Y
                 
000147 e0d1       ldi YH,high(I2C_data_write)
000148 e2cd       ldi YL,low(I2C_data_write)
000149 8318       st Y,temp							//save to I2C_data_write value from I2C_buffer+2
                 
00014a e0d1       ldi YH,high(I2C_data_pointer)
00014b e2cb       ldi YL,low(I2C_data_pointer)
00014c e014       ldi temp,0x04
00014d 8318       st Y,temp							//write to 0x04 adress
                 
00014e d0c7       rcall I2C_write_byte				//write date
                 
                  //- - - - - - - - - - - WRITE MONTH- - - - - - - - - - - - - - - - - - - - - - - - - - 
00014f 9503       inc r16
000150 e0d1       ldi YH,high(I2C_buffer)
000151 e2c5       ldi YL,low(I2C_buffer)
000152 0fc0       add YL,r16
000153 930f       push r16
000154 2700       clr r16
000155 1fd0       adc YH,r16
000156 910f       pop r16
000157 8118       ld temp,Y
                 
000158 e0d1       ldi YH,high(I2C_data_write)
000159 e2cd       ldi YL,low(I2C_data_write)
00015a 8318       st Y,temp							//save to I2C_data_write value from I2C_buffer+3
                 
00015b e0d1       ldi YH,high(I2C_data_pointer)
00015c e2cb       ldi YL,low(I2C_data_pointer)
00015d e015       ldi temp,0x05
00015e 8318       st Y,temp							//write to 0x05 adress
                 
00015f d0b6       rcall I2C_write_byte				//write month
                 
                  //- - - - - - - - - - - -WRITE YEARS - - - - - - - - - - - - - - - - - - - - - - - - - 
000160 9503       inc r16
000161 e0d1       ldi YH,high(I2C_buffer)
000162 e2c5       ldi YL,low(I2C_buffer)
000163 0fc0       add YL,r16
000164 930f       push r16
000165 2700       clr r16
000166 1fd0       adc YH,r16
000167 910f       pop r16
000168 8118       ld temp,Y
                 
000169 e0d1       ldi YH,high(I2C_data_write)
00016a e2cd       ldi YL,low(I2C_data_write)
00016b 8318       st Y,temp							//save to I2C_data_write value from I2C_buffer+4
                 
00016c e0d1       ldi YH,high(I2C_data_pointer)
00016d e2cb       ldi YL,low(I2C_data_pointer)
00016e e016       ldi temp,0x06
00016f 8318       st Y,temp							//write to 0x06 adress
                 
000170 d0a5       rcall I2C_write_byte				//write years
                  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
000171 91cf       pop YL
000172 91df       pop YH
000173 910f       pop r16
000174 911f       pop temp
000175 9508       ret
                  //-----------------------------------------
                 
                  //-------Get new time----------------------
                  I2C_Clock_Get_Time:
000176 931f       push temp
000177 930f       push r16
000178 93df       push YH
000179 93cf       push YL
                 
00017a 2700       clr r16
                  //- - - - - - - - - - - - READ HOURS- - - - - - - - - - - - - - - - - - - - - - - - - - 
00017b e0d1       ldi YH,high(I2C_data_pointer)
00017c e2cb       ldi YL,low(I2C_data_pointer)
00017d e012       ldi temp,0x02
00017e 8318       st Y,temp							//read from 0x02 adress
                 
00017f d0ae       rcall I2C_read_byte				//read hours to I2C_data_read
                 
000180 e0d1       ldi YH,high(I2C_data_read)
000181 e2cc       ldi YL,low(I2C_data_read)
000182 8118       ld temp,Y							//load to temp just readed data
                 
000183 e0d1       ldi YH,high(I2C_buffer)
000184 e2c5       ldi YL,low(I2C_buffer)
000185 8318       st Y,temp						//store temp to I2C_buffer[0]
                  
                  //- - - - - - - - - - - - -READ MINUTES - - - - - - - - - - - - - - - - - - - - - - - - 
000186 e0d1       ldi YH,high(I2C_data_pointer)
000187 e2cb       ldi YL,low(I2C_data_pointer)
000188 e011       ldi temp,0x01
000189 8318       st Y,temp						//read from 0x01 adress
                 
00018a d0a3       rcall I2C_read_byte			//read minutes to I2C_data_read
                 
00018b e0d1       ldi YH,high(I2C_data_read)
00018c e2cc       ldi YL,low(I2C_data_read)
00018d 8118       ld temp,Y						//load I2C_data_read to temp
                 
00018e 9503       inc r16
00018f e0d1       ldi YH,high(I2C_buffer)
000190 e2c5       ldi YL,low(I2C_buffer)
000191 0fc0       add YL,r16
000192 930f       push r16
000193 2700       clr r16
000194 1fd0       adc YH,r16
000195 910f       pop r16
000196 8318       st Y,temp							//store temp to buffer[1]
                 
                  //- - - - - - - - - - - - READ DATE - - - - - - - - - - - - - - - - - - - - - - - 
000197 e0d1       ldi YH,high(I2C_data_pointer)
000198 e2cb       ldi YL,low(I2C_data_pointer)
000199 e014       ldi temp,0x04
00019a 8318       st Y,temp							//read from 0x04 adress
                 
00019b d092       rcall I2C_read_byte				//read date to I2C_data_read
                 
00019c e0d1       ldi YH,high(I2C_data_read)
00019d e2cc       ldi YL,low(I2C_data_read)
00019e 8118       ld temp,Y							//load to temp just readed data
                 
00019f 9503       inc r16
0001a0 e0d1       ldi YH,high(I2C_buffer)
0001a1 e2c5       ldi YL,low(I2C_buffer)
0001a2 0fc0       add YL,r16
0001a3 930f       push r16
0001a4 2700       clr r16
0001a5 1fd0       adc YH,r16
0001a6 910f       pop r16
0001a7 8318       st Y,temp							//store temp to buffer[2]
                 
                  //- - - - - - - - - - - READ MONTH- - - - - - - - - - - - - - - - - - - - - - - - - - 
0001a8 e0d1       ldi YH,high(I2C_data_pointer)
0001a9 e2cb       ldi YL,low(I2C_data_pointer)
0001aa e015       ldi temp,0x05
0001ab 8318       st Y,temp							//read from 0x05 adress
                 
0001ac d081       rcall I2C_read_byte				//read month to I2C_data_read
                 
0001ad e0d1       ldi YH,high(I2C_data_read)
0001ae e2cc       ldi YL,low(I2C_data_read)
0001af 8118       ld temp,Y							//load to temp just readed data
                 
0001b0 9503       inc r16
0001b1 e0d1       ldi YH,high(I2C_buffer)
0001b2 e2c5       ldi YL,low(I2C_buffer)
0001b3 0fc0       add YL,r16
0001b4 930f       push r16
0001b5 2700       clr r16
0001b6 1fd0       adc YH,r16
0001b7 910f       pop r16
0001b8 8318       st Y,temp							//store temp to buffer[3]
                 
                  //- - - - - - - - - - - -READ YEARS - - - - - - - - - - - - - - - - - - - - - - - - - 
0001b9 e0d1       ldi YH,high(I2C_data_pointer)
0001ba e2cb       ldi YL,low(I2C_data_pointer)
0001bb e016       ldi temp,0x06
0001bc 8318       st Y,temp							//read from 0x06 adress
                 
0001bd d070       rcall I2C_read_byte				//read years to I2C_data_read
                 
0001be e0d1       ldi YH,high(I2C_data_read)
0001bf e2cc       ldi YL,low(I2C_data_read)
0001c0 8118       ld temp,Y							//load to temp just readed data
                 
0001c1 9503       inc r16
0001c2 e0d1       ldi YH,high(I2C_buffer)
0001c3 e2c5       ldi YL,low(I2C_buffer)
0001c4 0fc0       add YL,r16
0001c5 930f       push r16
0001c6 2700       clr r16
0001c7 1fd0       adc YH,r16
0001c8 910f       pop r16
0001c9 8318       st Y,temp							//store temp to buffer[4]
                  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0001ca 91cf       pop YL
0001cb 91df       pop YH
0001cc 910f       pop r16
0001cd 911f       pop temp
0001ce 9508       ret
                  //-----------------------------------------
                  //-------load time value from I2C_buffer-----------------------
                  Time_to_string:
0001cf 932f       push r18
0001d0 933f       push r19
0001d1 931f       push temp
0001d2 93df       push YH
0001d3 93cf       push YL
0001d4 93bf       push XH
0001d5 93af       push XL
                 
0001d6 e0d1       ldi YH,high(time_set_status)
0001d7 e2ce       ldi YL,low(time_set_status)
0001d8 8118       ld temp,Y
0001d9 fd17       sbrc temp,time_set_S		//if time set mode on then return
0001da c014       rjmp return_time_to_string
                 
0001db e330       ldi r19,48
0001dc 2722       clr r18
                 
0001dd e0d1       ldi YH,high(time_value)
0001de e0c0       ldi YL,low(time_value)
                 
0001df e0b1       ldi XH,high(I2C_buffer)
0001e0 e2a5       ldi XL,low(I2C_buffer)
                 
                  Time_to_string_loop:
                 
0001e1 911d       ld temp,X+
                 
0001e2 931f       push temp
0001e3 9512       swap temp
0001e4 701f       andi temp,0x0F	//clear high half-byte
0001e5 0f13       add temp,r19	//temp += 48
0001e6 9319       st Y+,temp
                 
0001e7 911f       pop temp
0001e8 701f       andi temp,0x0F	//clear high half-byte
0001e9 0f13       add temp,r19	//temp += 48
0001ea 9319       st Y+,temp
                 
0001eb 9621       adiw YH:YL,1
                 
0001ec 9523       inc r18
0001ed 3025       cpi r18,5
0001ee f791       brne Time_to_string_loop
                 
                  return_time_to_string:
0001ef 91af       pop XL
0001f0 91bf       pop XH
0001f1 91cf       pop YL
0001f2 91df       pop YH
0001f3 911f       pop temp
0001f4 913f       pop r19
0001f5 912f       pop r18
0001f6 9508       ret
                  //-------------------------------------------------------------
                  //-------load I2C_buffer from time value-----------------------
                  String_to_time:
0001f7 932f       push r18
0001f8 933f       push r19
0001f9 931f       push temp
0001fa 93df       push YH
0001fb 93cf       push YL
0001fc 93bf       push XH
0001fd 93af       push XL
                 
0001fe 2722       clr r18
                 
0001ff e0d1       ldi YH,high(time_value)
000200 e0c0       ldi YL,low(time_value)
                 
000201 e0b1       ldi XH,high(I2C_buffer)
000202 e2a5       ldi XL,low(I2C_buffer)
                 
                  String_to_time_loop:
                 
000203 9119       ld temp,Y+
000204 5310       subi temp,48
000205 9512       swap temp
                 
000206 9139       ld r19,Y+
000207 5330       subi r19,48
000208 2b13       or temp,r19
                 
000209 931d       st X+,temp
                 
00020a 9621       adiw YH:YL,1
                 
00020b 9523       inc r18
00020c 3025       cpi r18,5
00020d f7a9       brne String_to_time_loop
                 
00020e 91af       pop XL
00020f 91bf       pop XH
000210 91cf       pop YL
000211 91df       pop YH
000212 911f       pop temp
000213 913f       pop r19
000214 912f       pop r18
000215 9508       ret
                  //-------------------------------------------------------------
                  //-----Write byte------------------
                  I2C_write_byte:
000216 931f       push temp
000217 93df       push YH
000218 93cf       push YL
                 
                  I2C_error_restart_write:
                 
000219 e0d1       ldi YH,high(I2C_status)
00021a e2c4       ldi YL,low(I2C_status)
00021b 8118       ld temp,Y
00021c fd17       sbrc temp,I2C_BS					//wait for last I2C operation end
00021d cffb       rjmp I2C_error_restart_write
                 
00021e e810       ldi temp, (1<<I2C_BS)				//set I2C busy and write
00021f 9513       inc temp							//set current stage as 1
000220 8318       st Y,temp		//save to I2C_data_pointer a pointer to register
                 				//which need to read
                 				
000221 de3c       rcall I2C_Interrupt
                 
                  I2C_wait_write_end:
                 
000222 e0d1       ldi YH,high(I2C_status)
000223 e2c4       ldi YL,low(I2C_status)
000224 8118       ld temp,Y
                 
000225 fd15       sbrc temp, I2C_E				//if error occurred
000226 cff2       rjmp I2C_error_restart_write	//restart read
                 
000227 711f       andi temp, 0b0001_1111		//clear flags, for comfortable compare
000228 3010       cpi temp,0
000229 f7c1       brne I2C_wait_write_end
                 
00022a 91cf       pop YL
00022b 91df       pop YH
00022c 911f       pop temp
00022d 9508       ret
                   //-----Read byte-------------------
                  I2C_read_byte:
00022e 931f       push temp
00022f 93df       push YH
000230 93cf       push YL
                 
                  I2C_error_restart_read:
                 
000231 e0d1       ldi YH,high(I2C_status)
000232 e2c4       ldi YL,low(I2C_status)
000233 8118       ld temp,Y
000234 fd17       sbrc temp,I2C_BS					//wait for last I2C operation end
000235 cffb       rjmp I2C_error_restart_read
                 
000236 ec10       ldi temp, (1<<I2C_BS)|(1<<I2C_OP)	//set I2C busy and read
000237 9513       inc temp							//set current stage as 1
000238 8318       st Y,temp		//save to I2C_data_pointer a pointer to register
                 				//which need to read
                 				
000239 de24       rcall I2C_Interrupt
                 
                  I2C_wait_read_end:
                 
00023a e0d1       ldi YH,high(I2C_status)
00023b e2c4       ldi YL,low(I2C_status)
00023c 8118       ld temp,Y
                 
00023d fd15       sbrc temp, I2C_E			//if error occurred
00023e cff2       rjmp I2C_error_restart_read	//restart read
                 
00023f 711f       andi temp, 0b0001_1111		//clear flags, for comfortable compare
000240 3010       cpi temp,0
000241 f7c1       brne I2C_wait_read_end
                 
000242 91cf       pop YL
000243 91df       pop YH
000244 911f       pop temp
000245 9508       ret
                 
                  //----Set Clock Halt(enable clock)------------------
                  I2C_Clock_Enable:
000246 931f       push temp
000247 93df       push YH
000248 93cf       push YL
                 
000249 771f       andi temp, ~(1<<7)	//set clock halt as 0(enable clock)
00024a e0d1       ldi YH,high(I2C_data_write)
00024b e2cd       ldi YL,low(I2C_data_write)
00024c 8318       st Y,temp
                 
00024d e0d1       ldi YH,high(I2C_data_pointer)
00024e e2cb       ldi YL,low(I2C_data_pointer)
00024f e010       ldi temp,0x00
000250 8318       st Y,temp
                 
000251 dfc4       rcall I2C_write_byte
                 
000252 91cf       pop YL
000253 91df       pop YH
000254 911f       pop temp
000255 9508       ret
                  //--------------------------------------------------
                 
                  //----Set 24-hour mode------------------------------
                  I2C_Clock_Set_24Hour:
000256 931f       push temp
000257 93df       push YH
000258 93cf       push YL
                 
000259 7b1f       andi temp, ~(1<<6)	//set hour mode as 0(24-hour mode)
00025a e0d1       ldi YH,high(I2C_data_write)
00025b e2cd       ldi YL,low(I2C_data_write)
00025c 8318       st Y,temp
                 
00025d e0d1       ldi YH,high(I2C_data_pointer)
00025e e2cb       ldi YL,low(I2C_data_pointer)
00025f e012       ldi temp,0x02
000260 8318       st Y,temp
                 
000261 dfb4       rcall I2C_write_byte
                 
000262 91cf       pop YL
000263 91df       pop YH
000264 911f       pop temp
000265 9508       ret
                  //--------------------------------------------------
                 .include "TimeSet.inc"		//time set procedures and macro
                 
                  * TimeSet.inc
                  *
                  *  Created: 17.11.2015 1:07:04
                  *   Author: Hogs
                  */ 
                  .equ time_set_S = 7		//time set status flag
                  .equ time_set_F = 6		//time set first number flag
                  .equ time_set_B = 5		//time set blink flag
                 
                  //======PROCEDURES==========================================
                  //-----------------------------------------------------
                  time_set_blink:
000266 931f       push temp
000267 93df       push YH
000268 93cf       push YL
000269 930f       push r16
                 
00026a e0d1       ldi YH,high(time_set_status)		//read time_set status
00026b e2ce       ldi YL,low(time_set_status)
00026c 8108       ld r16,Y
                 
00026d ff07       sbrs r16,time_set_S				//if time set mode is off
00026e c023       rjmp return_time_set_blink			//then return
                 
                 									//continue if time set mode is On
                 
00026f e0d1       ldi YH,high(time_set_blink_count)	//time_set_blink_count is a counter
000270 e4c1       ldi YL,low(time_set_blink_count)	//how much timer was ticked before
000271 8118       ld temp,Y							//pair visible On/Off
                 
000272 301a       cpi temp,10						//if timer ticked 10 times or more - continue
000273 f0f0       brlo return_time_set_blink			//else - return
                 
000274 e0d1       ldi YH,high(time_set_blink_count)
000275 e4c1       ldi YL,low(time_set_blink_count)
000276 2711       clr temp							//clear time_set_blink_counter
000277 8318       st Y,temp
                 
000278 ff05       sbrs r16,time_set_B			//check blink flag
000279 c009       rjmp blink_pair				//if blink flag is 0 then pair is visible,
                 								//if blink flag is 1 then pair is "  "
                 
00027a e0d1       ldi YH,high(time_set_status)
00027b e2ce       ldi YL,low(time_set_status)
00027c 7d0f       andi r16, ~(1<<time_set_B)			//set blink flag as 0
00027d 8308       st Y,r16
                 
00027e d0af       rcall time_set_get_pair_adress		//get to Y register adress of symbols for current pair
00027f e210       ldi temp, ' '				//set current pair as "  " so it is like invisible
000280 9319       st Y+,temp
000281 8318       st Y,temp
                 
000282 c00f       rjmp return_time_set_blink	//return
                 
                  blink_pair:
                 
000283 e0d1       ldi YH,high(time_set_status)
000284 e2ce       ldi YL,low(time_set_status)
000285 6200       ori r16, (1<<time_set_B)		//set blink flag as 1
000286 8308       st Y,r16
                 
000287 93ff       push ZH
000288 93ef       push ZL
000289 d0a4       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
00028a e0f1       ldi ZH,high(time_set_buffer)	
00028b e3ef       ldi ZL,low(time_set_buffer)
00028c 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
00028d 9319       st Y+,temp
00028e 8110       ld temp,Z
00028f 8318       st Y,temp
000290 91ef       pop ZL
000291 91ff       pop ZH
                 
                 
                  return_time_set_blink:
000292 932f
000293 93bf
000294 93af
000295 931f
000296 93df
000297 93cf
000298 e0d1
000299 e2c0
00029a 8128
00029b e110
00029c 9f12
00029d 2da0
00029e 2db1
00029f e610
0002a0 0fa1
0002a1 2711
0002a2 1fb1
0002a3 931f
0002a4 930f
0002a5 931f
0002a6 930f
0002a7 e010
0002a8 e800
0002a9 940e 0030
0002ab 910f
0002ac 911f
0002ad 939f
0002ae 938f
0002af 937f
0002b0 ef90
0002b1 e081
0002b2 e071
0002b3 940e 0029
0002b5 917f
0002b6 918f
0002b7 919f
0002b8 910f
0002b9 911f
0002ba 931f
0002bb 930f
0002bc 93af
0002bd 93bf
0002be 933f
0002bf e014
0002c0 e131
0002c1 910d
0002c2 940e 0030
0002c4 939f
0002c5 938f
0002c6 937f
0002c7 ef90
0002c8 e081
0002c9 e071
0002ca 940e 0029
0002cc 917f
0002cd 918f
0002ce 919f
0002cf 953a
0002d0 f781
0002d1 913f
0002d2 91bf
0002d3 91af
0002d4 910f
0002d5 911f
0002d6 e110
0002d7 9f12
0002d8 2da0
0002d9 2db1
0002da ec10
0002db 0fa1
0002dc 2711
0002dd 1fb1
0002de 931f
0002df 930f
0002e0 931f
0002e1 930f
0002e2 e010
0002e3 ec00
0002e4 940e 0030
0002e6 910f
0002e7 911f
0002e8 939f
0002e9 938f
0002ea 937f
0002eb ef90
0002ec e081
0002ed e071
0002ee 940e 0029
0002f0 917f
0002f1 918f
0002f2 919f
0002f3 910f
0002f4 911f
0002f5 931f
0002f6 930f
0002f7 93af
0002f8 93bf
0002f9 933f
0002fa e014
0002fb e131
0002fc 910d
0002fd 940e 0030
0002ff 939f
000300 938f
000301 937f
000302 ef90
000303 e081
000304 e071
000305 940e 0029
000307 917f
000308 918f
000309 919f
00030a 953a
00030b f781
00030c 913f
00030d 91bf
00030e 91af
00030f 910f
000310 911f
000311 91cf
000312 91df
000313 911f
000314 91af
000315 91bf
000316 912f       menu_refresh		//refresh menu
                 
000317 910f       pop r16
000318 91cf       pop YL
000319 91df       pop YH
00031a 911f       pop temp
00031b 9508       ret
                  //-----------------------------------------------------
                  time_set_set_buffer:
00031c 93df       push YH
00031d 93cf       push YL
00031e 93ff       push ZH
00031f 93ef       push ZL
000320 931f       push temp
                 
000321 e0f1       ldi ZH,high(time_set_buffer)
000322 e3ef       ldi ZL,low(time_set_buffer)
                 
000323 d00a       rcall time_set_get_pair_adress
000324 9119       ld temp,Y+
000325 9311       st Z+,temp
000326 8118       ld temp,Y
000327 8310       st Z,temp
                 
000328 911f       pop temp
000329 91ef       pop ZL
00032a 91ff       pop ZH
00032b 91cf       pop YL
00032c 91df       pop YH
00032d 9508       ret
                 
                  //-----------------------------------------------------
                  time_set_get_pair_adress:
00032e 931f       push temp
00032f 930f       push r16
                 
000330 e0d1       ldi YH,high(time_set_status)
000331 e2ce       ldi YL,low(time_set_status)
000332 8118       ld temp,Y
                 
000333 711f       andi temp,0b0001_1111		//clear flags
000334 2f01       mov r16,temp	
000335 0f10       add temp,r16				//temp = pair*2
000336 0f10       add temp,r16				//temp = pair*2 + pair
                 
000337 e0d1       ldi YH,high(time_value)
000338 e0c0       ldi YL,low(time_value)
                 
000339 0fc1       add YL,temp
00033a 2700       clr r16
00033b 1fd0       adc YH,r16
                 
00033c 910f       pop r16
00033d 911f       pop temp
00033e 9508       ret
                  //---------------------------------------------
                  time_set_next_pair:
00033f 93df       push YH
000340 93cf       push YL
000341 931f       push temp
                 
000342 93ff       push ZH
000343 93ef       push ZL
000344 dfe9       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
000345 e0f1       ldi ZH,high(time_set_buffer)	
000346 e3ef       ldi ZL,low(time_set_buffer)
000347 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
000348 9319       st Y+,temp
000349 8110       ld temp,Z
00034a 8318       st Y,temp
00034b 91ef       pop ZL
00034c 91ff       pop ZH
                 
00034d e0d1       ldi YH,high(time_set_status)
00034e e2ce       ldi YL,low(time_set_status)
00034f 8118       ld temp,Y
                 
000350 7b1f       andi temp,~(1<<time_set_F)
                 
000351 931f       push temp
                  
000352 711f       andi temp,0b0001_1111
000353 3014       cpi temp,4
000354 f418       brsh time_set_next_pair_clear
                 
000355 911f       pop temp
000356 9513       inc temp
000357 c002       rjmp time_set_next_pair_return
                 
                  time_set_next_pair_clear:
000358 911f       pop temp
000359 7e10       andi temp,0b1110_0000
                 
                  time_set_next_pair_return:
00035a 8318       st Y,temp
00035b dfc0       rcall time_set_set_buffer
                 
00035c 911f       pop temp
00035d 91cf       pop YL
00035e 91df       pop YH
00035f 9508       ret
                  //-------Time set mode toggle--------------------
                  time_set_start:
                  
000360 e0d1       ldi YH,high(time_set_status)
000361 e2ce       ldi YL,low(time_set_status)
000362 8118       ld temp,Y
                 
000363 ff17       sbrs temp,time_set_S
000364 c016       rjmp enable_time_set
                 
                 
000365 93ff       push ZH
000366 93ef       push ZL
000367 dfc6       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
000368 e0f1       ldi ZH,high(time_set_buffer)	
000369 e3ef       ldi ZL,low(time_set_buffer)
00036a 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
00036b 9319       st Y+,temp
00036c 8110       ld temp,Z
00036d 8318       st Y,temp
00036e 91ef       pop ZL
00036f 91ff       pop ZH
                 
000370 e0d1       ldi YH,high(time_set_status)
000371 e2ce       ldi YL,low(time_set_status)
000372 e010       ldi temp, 0x00
000373 8318       st Y,temp
000374 de82       rcall String_to_time
000375 dda7       rcall I2C_Clock_Set_New_Time
000376 940e 0176
000378 940e 01cf  Refresh_time
                 
00037a c003       rjmp return_time_set_start
                 
                  enable_time_set:
                 
00037b dfa0       rcall time_set_set_buffer	//save values of current pair to buffer
00037c e810       ldi temp,(1<<time_set_S)
00037d 8318       st Y,temp
                 
                  return_time_set_start:
00037e 932f
00037f 93bf
000380 93af
000381 931f
000382 93df
000383 93cf
000384 e0d1
000385 e2c0
000386 8128
000387 e110
000388 9f12
000389 2da0
00038a 2db1
00038b e610
00038c 0fa1
00038d 2711
00038e 1fb1
00038f 931f
000390 930f
000391 931f
000392 930f
000393 e010
000394 e800
000395 940e 0030
000397 910f
000398 911f
000399 939f
00039a 938f
00039b 937f
00039c ef90
00039d e081
00039e e071
00039f 940e 0029
0003a1 917f
0003a2 918f
0003a3 919f
0003a4 910f
0003a5 911f
0003a6 931f
0003a7 930f
0003a8 93af
0003a9 93bf
0003aa 933f
0003ab e014
0003ac e131
0003ad 910d
0003ae 940e 0030
0003b0 939f
0003b1 938f
0003b2 937f
0003b3 ef90
0003b4 e081
0003b5 e071
0003b6 940e 0029
0003b8 917f
0003b9 918f
0003ba 919f
0003bb 953a
0003bc f781
0003bd 913f
0003be 91bf
0003bf 91af
0003c0 910f
0003c1 911f
0003c2 e110
0003c3 9f12
0003c4 2da0
0003c5 2db1
0003c6 ec10
0003c7 0fa1
0003c8 2711
0003c9 1fb1
0003ca 931f
0003cb 930f
0003cc 931f
0003cd 930f
0003ce e010
0003cf ec00
0003d0 940e 0030
0003d2 910f
0003d3 911f
0003d4 939f
0003d5 938f
0003d6 937f
0003d7 ef90
0003d8 e081
0003d9 e071
0003da 940e 0029
0003dc 917f
0003dd 918f
0003de 919f
0003df 910f
0003e0 911f
0003e1 931f
0003e2 930f
0003e3 93af
0003e4 93bf
0003e5 933f
0003e6 e014
0003e7 e131
0003e8 910d
0003e9 940e 0030
0003eb 939f
0003ec 938f
0003ed 937f
0003ee ef90
0003ef e081
0003f0 e071
0003f1 940e 0029
0003f3 917f
0003f4 918f
0003f5 919f
0003f6 953a
0003f7 f781
0003f8 913f
0003f9 91bf
0003fa 91af
0003fb 910f
0003fc 911f
0003fd 91cf
0003fe 91df
0003ff 911f
000400 91af
000401 91bf
000402 912f       menu_refresh
                 
000403 9508       ret
                 
                  //-----------------------------------------
                  time_set_set_next_pair:
                  
000404 e0d1       ldi YH,high(time_set_status)
000405 e2ce       ldi YL,low(time_set_status)
000406 8118       ld temp,Y
                 
000407 ff17       sbrs temp,time_set_S
000408 c001       rjmp return_time_set_set_next_pair
                 
000409 df35       rcall time_set_next_pair
                 
                  return_time_set_set_next_pair:
00040a 932f
00040b 93bf
00040c 93af
00040d 931f
00040e 93df
00040f 93cf
000410 e0d1
000411 e2c0
000412 8128
000413 e110
000414 9f12
000415 2da0
000416 2db1
000417 e610
000418 0fa1
000419 2711
00041a 1fb1
00041b 931f
00041c 930f
00041d 931f
00041e 930f
00041f e010
000420 e800
000421 940e 0030
000423 910f
000424 911f
000425 939f
000426 938f
000427 937f
000428 ef90
000429 e081
00042a e071
00042b 940e 0029
00042d 917f
00042e 918f
00042f 919f
000430 910f
000431 911f
000432 931f
000433 930f
000434 93af
000435 93bf
000436 933f
000437 e014
000438 e131
000439 910d
00043a 940e 0030
00043c 939f
00043d 938f
00043e 937f
00043f ef90
000440 e081
000441 e071
000442 940e 0029
000444 917f
000445 918f
000446 919f
000447 953a
000448 f781
000449 913f
00044a 91bf
00044b 91af
00044c 910f
00044d 911f
00044e e110
00044f 9f12
000450 2da0
000451 2db1
000452 ec10
000453 0fa1
000454 2711
000455 1fb1
000456 931f
000457 930f
000458 931f
000459 930f
00045a e010
00045b ec00
00045c 940e 0030
00045e 910f
00045f 911f
000460 939f
000461 938f
000462 937f
000463 ef90
000464 e081
000465 e071
000466 940e 0029
000468 917f
000469 918f
00046a 919f
00046b 910f
00046c 911f
00046d 931f
00046e 930f
00046f 93af
000470 93bf
000471 933f
000472 e014
000473 e131
000474 910d
000475 940e 0030
000477 939f
000478 938f
000479 937f
00047a ef90
00047b e081
00047c e071
00047d 940e 0029
00047f 917f
000480 918f
000481 919f
000482 953a
000483 f781
000484 913f
000485 91bf
000486 91af
000487 910f
000488 911f
000489 91cf
00048a 91df
00048b 911f
00048c 91af
00048d 91bf
00048e 912f       menu_refresh
                 
00048f 9508       ret
                  //-----------------------------------------
                  time_set:
000490 931f       push temp
000491 93df       push YH
000492 93cf       push YL
000493 930f       push r16
                 
000494 93ff       push ZH
000495 93ef       push ZL
000496 de97       rcall time_set_get_pair_adress	//get to Y register symbol's adress of current pair
000497 e0f1       ldi ZH,high(time_set_buffer)	
000498 e3ef       ldi ZL,low(time_set_buffer)
000499 9111       ld temp,Z+						//returning from time_set_buffer symbols which was before clear
00049a 9319       st Y+,temp
00049b 8110       ld temp,Z
00049c 8318       st Y,temp
00049d 91ef       pop ZL
00049e 91ff       pop ZH
                 
00049f e0d1       ldi YH,high(time_set_status)
0004a0 e2ce       ldi YL,low(time_set_status)
0004a1 8118       ld temp,Y						//read time_set_status to temp
                 
0004a2 ff17       sbrs temp,time_set_S	//return if time set status is off(0)
0004a3 c05d       rjmp return_time_set	//if time set status is 1 then continue
                 
                  //time set mode is on
0004a4 fd16       sbrc temp,time_set_F			//skip if number is second
0004a5 c01d       rjmp time_set_second_number	//continue if number is first
                 
                  //number is first
                 
0004a6 8108       ld r16,Y
0004a7 710f       andi r16, ~((1<<time_set_S)|(1<<time_set_F)|(1<<time_set_B))	//now r16 is a number of pair
0004a8 e0d1       ldi YH,high(time_set_ranges)
0004a9 e3c0       ldi YL,low(time_set_ranges)	//load to Y adress of max ranges
0004aa 0f00       add r16,r16
0004ab 0fc0       add YL,r16						//now Y is max ranges for current pair
0004ac 2700       clr r16		//clear r16, for next operation
0004ad 1fd0       adc YH,r16
0004ae 8108       ld r16,Y		//now r16 = max range for first number of this pair
                 
0004af 2f12       mov temp,r18		//temp = ASCII code of number
0004b0 5310       subi temp,48		//now temp = number
0004b1 1710       cp temp,r16	//if number > max range, then continue
0004b2 f039       breq time_set_first_lower_first	//if number = max range, then go to label
0004b3 f030       brlo time_set_first_lower_first	//if number < max range, then go to label
                 
                  //if number is higher than max range
0004b4 de79       rcall time_set_get_pair_adress
0004b5 e300       ldi r16,'0'
0004b6 9309       st Y+,r16						//pair will seems like that, example for hours
0004b7 2f12       mov temp,r18					//if u try to set high hours higher than 2
0004b8 8318       st Y,temp						//then pair will be 02, and time_set will switch on next pair
0004b9 c01e       rjmp time_set_check_max_value
                 
                  //if number is ok(lower than max range)
                  time_set_first_lower_first:
                 
0004ba de73       rcall time_set_get_pair_adress
0004bb 2f12       mov temp,r18					//if nubmer is ok then first number will be like pressed
0004bc 8318       st Y,temp						//and time_set_F flag will be set as 1, for set second number
0004bd e0d1       ldi YH,high(time_set_status)
0004be e2ce       ldi YL,low(time_set_status)
0004bf 8118       ld temp,Y
0004c0 6410       ori temp,(1<<time_set_F)
0004c1 8318       st Y,temp
0004c2 c03e       rjmp return_time_set
                 
                 
                  //if setting second number
                  time_set_second_number:
                 
0004c3 8108       ld r16,Y
0004c4 710f       andi r16, ~((1<<time_set_S)|(1<<time_set_F)|(1<<time_set_B))	//now r16 = pair
0004c5 e0d1       ldi YH,high(time_set_ranges)
0004c6 e3c0       ldi YL,low(time_set_ranges)
0004c7 0f00       add r16,r16
0004c8 9503       inc r16
0004c9 0fc0       add YL,r16
0004ca 2700       clr r16
0004cb 1fd0       adc YH,r16
0004cc 8108       ld r16,Y		//now r16 = max range for first number of this pair
                 
0004cd 2f12       mov temp,r18		//temp = ASCII code of number
0004ce 5310       subi temp,48		//now temp = number
                 
0004cf 1710       cp temp,r16		//if nubmer > max range, then continue
0004d0 f011       breq time_set_first_lower_second //if number is ok then go to label
0004d1 f008       brlo time_set_first_lower_second //if number is ok then go to label
                 
0004d2 2f10       mov temp,r16
                 
                  time_set_first_lower_second:
0004d3 e300       ldi r16,48				//
0004d4 0f10       add temp,r16			// temp = ASCII code of number
0004d5 de58       rcall time_set_get_pair_adress	//get to Y pair adress
0004d6 9621       adiw YH:YL,1
0004d7 8318       st Y,temp				//store second number to RAM
                  
                 
                  time_set_check_max_value:
                  //check for max value
0004d8 de55       rcall time_set_get_pair_adress		//load to Y adress of pair
0004d9 9119       ld temp,Y+			//temp = first number(ASCII)
0004da 5310       subi temp,48		//temp = first number
0004db e00a       ldi r16,10
0004dc 9f10       mul temp,r16
0004dd 2d00       mov r16,r0			//r16 = first number * 10
0004de 8118       ld temp,Y			//temp = second number(ASCII)
0004df 5310       subi temp,48		//temp = second number
0004e0 0f01       add r16,temp		//r16 is value of pair
                 
0004e1 e0d1       ldi YH,high(time_set_status)
0004e2 e2ce       ldi YL,low(time_set_status)
0004e3 8118       ld temp,Y
0004e4 711f       andi temp, 0b0001_1111		//temp = number of pair
0004e5 e0d1       ldi YH,high(time_set_max_values)
0004e6 e3ca       ldi YL,low(time_set_max_values)
0004e7 0fc1       add YL,temp
0004e8 2711       clr temp
0004e9 1fd1       adc YH,temp
0004ea 8118       ld temp,Y					//temp = max value for current pair
                 
0004eb 1701       cp r16,temp				//if current value of pair > max value for this pair, then continue
0004ec f091       breq time_set_value_is_ok	//
0004ed f088       brlo time_set_value_is_ok	//else - all is ok, return
                 
0004ee 2700       clr r16				//r16, is a counter for first number
                  time_set_div_label:
0004ef 9503       inc r16
0004f0 501a       subi temp,10
0004f1 f7ea       brpl time_set_div_label
0004f2 950a       dec r16				//now r16 contain first number
0004f3 930f       push r16				//and temp contain second
0004f4 e00a       ldi r16,10
0004f5 0f10       add temp,r16
0004f6 910f       pop r16
                 
0004f7 932f       push r18
0004f8 e320       ldi r18,48				//convert numbers to ASCII symbols
0004f9 0f02       add r16,r18
0004fa 0f12       add temp,r18
0004fb 912f       pop r18
                 
0004fc de31       rcall time_set_get_pair_adress
0004fd 9309       st Y+,r16				//save max value in time_value string
0004fe 8318       st Y,temp
                 
                  time_set_value_is_ok:
0004ff de1c       rcall time_set_set_buffer	//save values of current pair to buffer
000500 de3e       rcall time_set_next_pair	//set next pair
                  
                  return_time_set:
000501 de1a       rcall time_set_set_buffer	//save values of current pair to buffer
                 
000502 910f       pop r16
000503 91cf       pop YL
000504 91df       pop YH
000505 911f       pop temp
000506 9508       ret
                  //========MACRO============================================
                 
                  //------INIT-------------------------------
                  .macro time_set_init
                  ldi YH,high(time_set_ranges)
                  ldi YL,low(time_set_ranges)
                 
                  ldi temp,2
                  st Y+,temp		//max hours high 2
                  ldi temp,9
                  st Y+,temp		//max hours low 9
                 
                  ldi temp,6
                  st Y+,temp		//max minutes high 6
                  ldi temp,9
                  st Y+,temp		//max minutes low 9
                 
                  ldi temp,3
                  st Y+,temp		//max date high 3
                  ldi temp,9
                  st Y+,temp		//max date low 9
                 
                  ldi temp,1
                  st Y+,temp		//max month high 1
                  ldi temp,9
                  st Y+,temp		//max month low 9
                 
                  st Y+,temp		//max year high 9
                  st Y+,temp		//max year low 9
                 
                  ldi YH,high(time_set_max_values)
                  ldi YL,low(time_set_max_values)
                 
                  ldi temp,24
                  st Y+,temp
                 
                  ldi temp,60
                  st Y+,temp
                 
                  ldi temp,31
                  st Y+,temp
                 
                  ldi temp,12
                  st Y+,temp
                 
                  ldi temp,99
                  st Y+,temp
                 
                  .endm
                  
                 .include "sound.inc"		//macro and procedures for buzzer sound
                 
                  * sound.inc
                  *
                  *  Created: 10.11.2015 23:44:51
                  *   Author: Hogs
                  */ 
                 
                  .equ BUZZER = 6				//6 - is number of pin for buzzer
                  .equ sound_general_status = 0	//number of sound_status bit, 
                 								//for get general sound status (sound_on/sound_off)
                  .equ sound_freq = 23			//frequency of sound
                 
                  //=======Sound macro=======================================
                  //-------Sound test---------------------------
                  .macro sound_test
                  ldi YH, high(menu_location)
                  ldi YL, low(menu_location)
                  ld temp, Y			//load current menu page to temp
                  cpi temp,5			//if current page is sound
                  brne @0			//then continue, else return
                  ldi YH,high(sound_status)	//
                  ldi YL,low(sound_status)	//read sound status from RAM
                  ld temp,Y
                 
                  sbrc temp,sound_general_status	//if sound is generally off then set sound on
                  rjmp sound_off					//else set sound off
                 
                  rcall sound_alarm_enable
                  rjmp @0
                 
                  sound_off:
                  rcall sound_alarm_disable
                  .endm
                  //-------Sound Init---------------------------
                  .macro sound_init
                  in temp, ddrd
                  ori temp, (0 | (1<<BUZZER))	//set buzzer pin as output
                  out ddrd,temp
                  in temp, portd
                  andi temp, ~(1<<BUZZER)	//set buzzer pin as 0
                  out portd, temp
                 
                 								//setting timer0
                  clr temp
                  out TCNT0,temp		//set counter as 0
                  ldi temp,sound_freq
                  out OCR0,temp		//set sound frequency
                  in temp, TIMSK
                  ori temp, (1<<OCIE0)	//
                  out TIMSK, temp	//enable On match timer 0 interrupt
                  .endm
                  //-------Timer0 enable---------------------------
                  .macro Timer0_enable
                  push temp
                  ldi temp, 0 | (1<<WGM01) | (1<<CS02)
                  out TCCR0, temp //set timer in CTC mode with 256 prescaler (enable)
                  pop temp
                  .endm
                  //-------Timer0 disable---------------------------
                  .macro Timer0_disable
                  push temp
                  clr temp
                  out TCCR0, temp //disable timer0
                  pop temp
                  .endm
                   //-------Timer 0 toggle--------------------------
                  .macro Timer0_toggle
                  push temp
                 
                  in temp, TCCR0			//if TCCR0 is empty
                  cpi temp,0				//then set timer on
                  breq set_timer_on		//else set timer off
                 
                  Timer0_disable
                  rjmp end_timer_toggle	//disable timer
                 
                  set_timer_on:
                  Timer0_enable
                 
                  end_timer_toggle:
                  pop temp
                  .endm
                  //=======PROCEDURES=======================================================
                  //-------Sound Alarm enable----------------------
                  sound_alarm_enable:
000507 931f       push temp
000508 93df       push YH
000509 93cf       push YL
                 
00050a e0d1       ldi YH,high(sound_status)	//
00050b e2c3       ldi YL,low(sound_status)	//set sound status in RAM
                  
00050c e011       ldi temp, 0 | (1<<sound_general_status)
00050d 8318       st Y,temp	//set general sound status and pause status
                 
00050e b719       in temp, TIMSK
00050f 6018       ori temp, (1<<OCIE1B)	//set OCIE1B as 1
000510 bf19       out TIMSK, temp	//enable interrupt(every 0.5sec)
                 
000511 931f
000512 e01c
000513 bf13
000514 911f       Timer0_enable		//enable timer0
                 
000515 91cf       pop YL
000516 91df       pop YH
000517 911f       pop temp
000518 9508       ret
                  //-------Sound Alarm disable---------------------
                  sound_alarm_disable:
000519 931f       push temp
00051a 93df       push YH
00051b 93cf       push YL
                  
00051c e0d1       ldi YH,high(sound_status)	//
00051d e2c3       ldi YL,low(sound_status)	//set sound status in RAM
                 
00051e e010       ldi temp, 0
00051f 8318       st Y,temp			//set general sound status as 0 (alarm disable:)
                 
000520 b719       in temp, TIMSK
000521 7f17       andi temp, ~(1<<OCIE1B)	//set OCIE1B as 0
000522 bf19       out TIMSK, temp	//disable interrupt
                 
000523 931f
000524 2711
000525 bf13
000526 911f       Timer0_disable		//stop sound generation
                 
000527 27cc       clr YL
000528 27dd       clr YH
000529 94f8       cli
00052a bddd       out TCNT1H,YH	//clear counter of timer1
00052b bdcc       out TCNT1L,YL
00052c 9478       sei
                 
00052d e00c       ldi r16,0x0C			//set A as standart value	
00052e e315       ldi r17,0x35
00052f 94f8       cli
000530 bd0b       out OCR1AH,r16			//set A as 3125
000531 bd1a       out OCR1AL,r17			//that mean timer tick is every 0.05sec
000532 9478       sei
                 
000533 91cf       pop YL
000534 91df       pop YH
000535 911f       pop temp
000536 9508       ret
                  //-----------------------------------------------
                 
                  //=======Sound interrupts==================================
                 
                  //-------Sound generation interrupt-----------
                  Sound_generation:
000537 9b86       sbis pind, BUZZER
000538 c002       rjmp Buzzer_set_1
000539 9896       cbi portd, BUZZER	//if buzzer pin is 1, then set it as 0
00053a 9518       reti
                  Buzzer_set_1:
00053b 9a96       sbi portd, BUZZER	//if buzzer pin is 0, then set is as 1
00053c 9518       reti
                 
                  //--------Sound play/pause interrupt----------
                  Sound_play_and_pause:
00053d 931f       push temp
00053e 93df       push YH
00053f 93cf       push YL
                 
000540 e0dc       ldi YH,0x0C
000541 e3c5       ldi YL,0x35
000542 94f8       cli
000543 bddb       out OCR1AH,YH	//set timer1 A as 3125
000544 bdca       out OCR1AL,YL	//for correct work with keyboard
000545 9478       sei
                 
000546 931f
000547 b713
000548 3010
000549 f029
00054a 931f
00054b 2711
00054c bf13
00054d 911f
00054e c004
00054f 931f
000550 e01c
000551 bf13
000552 911f
000553 911f       Timer0_toggle
                 
000554 27cc       clr YL
000555 27dd       clr YH
000556 94f8       cli
000557 bddd       out TCNT1H,YH	//clear counter of timer1
000558 bdcc       out TCNT1L,YL
000559 9478       sei
                 
00055a 91cf       pop YL
00055b 91df       pop YH
00055c 911f       pop temp
00055d 9518       reti
                  //--------------------------------------------
                 .include "keyboard.inc"		//macro and procedures for 3x4 keyboard
                 
                  * keyboard.inc
                  * macro and procedures for 3x4 keyboard
                  * Sorry for bad english
                  */ 
                 
                  .equ KBD_A = 2
                  .equ KBD_B = 3
                  .equ KBD_C = 4
                  .equ KBD_D = 5
                  .equ KBD_1 = 0
                  .equ KBD_2 = 1
                  .equ KBD_3 = 2
                  .equ count_of_ticks = 1	//count of ticks for prevent false activation macro
                 
                  //=======MACRO==========================================
                  //-------Preventing false activation----------------------------
                  .macro Anti_false_activation
                  
                  ldi YH,high(tick_count)
                  ldi YL,low(tick_count)
                  ld temp,Y+						//load to temp count of ticks
                  ld r16,Y						//load to r16 number of last pressed button
                 
                  cpi r16,@0							//compare block
                  brne end_of_activation_macro		//example on C language:
                  cpi temp,count_of_ticks			//	if(last_btn == @0)
                  brsh end_of_activation_macro		//	{
                 									//		if(tick > count_of_ticks)
                 									//		{
                 									//			tick = 0;
                 									//			do_something...
                 									//		}
                 									//		else
                 									//		{
                 									//			return of On_(button)_Click
                 									//		}
                 									//	}
                 									//	else
                 									//	{
                 									//		tick = 0;
                 									//		do_something...
                 									//	}
                 									//	last_btn=@0
                 
                  rjmp @1							//return of On_(some_btn)_Click
                 
                  end_of_activation_macro:			//label to end of macro for continue
                 
                  ldi temp,0							//saving to RAM
                  ldi r16,@0
                  ldi YH,high(tick_count)
                  ldi YL,low(tick_count)
                  st Y+,temp
                  st Y,r16
                 
                  .endm
                  //-------Initialization ports for working with keyboard---------
                  .macro keyboard_init
                  in temp,ddrb
                  andi temp, (~(0 | (1<<KBD_1) | (1<<KBD_2) | (1<<KBD_3)))
                  out ddrb,temp			//set KBD_1 KBD_2 KBD_3 as input
                 
                  in temp,portb
                  ori temp, (0 | (1<<KBD_1) | (1<<KBD_2) | (1<<KBD_3))
                  out portb,temp			//enable pull-ups for KBD_1 KBD_2 KBD_3
                 
                  in temp,ddrd
                  ori temp, (0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D))
                  out ddrd,temp			//set KBD_A KBD_B KBD_C KBD_D as output
                  .endm
                  //-------Check buttons------------------------------------------
                  .macro keyboard_check
                 
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_A)))//set KBD_A as 0, and KBD_B,C,D as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_asterisk_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_2_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_3_Click
                 
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_B)))//set KBD_B as 0, and KBD_A,C,D as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_1_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_5_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_6_Click
                 
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_C)))//set KBD_C as 0, and KBD_A,B,D as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_4_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_8_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_9_Click
                 
                 	in temp,pind		//set pins without corruption of other pins
                 	ori temp, 0 | (1<<KBD_A) | (1<<KBD_B) | (1<<KBD_C) | (1<<KBD_D)
                 	andi temp, (~(0 | (1<<KBD_D)))//set KBD_D as 0, and KBD_A,B,C as 1
                 	out portd,temp
                 
                 		sbis pinb,KBD_3
                 		rcall On_7_Click
                 
                 		sbis pinb,KBD_2
                 		rcall On_0_Click
                 
                 		sbis pinb,KBD_1
                 		rcall On_grid_Click
                 
                  .endm
                 
                  //=======PROCEDURES=====================================
                  //-------On 1 click-----------------------------
                  On_1_click:
00055e 931f       push temp
00055f 93df       push YH
000560 93cf       push YL
000561 930f       push r16
                 
000562 e0d1
000563 e2c1
000564 9119
000565 8108
000566 3301
000567 f419
000568 3011
000569 f408
00056a c00f
00056b e010
00056c e301
00056d e0d1
00056e e2c1
00056f 9319
000570 8308       Anti_false_activation '1', return_On_1_Click
                 
000571 e0d1       ldi YH,high(time_set_status)
000572 e2ce       ldi YL,low(time_set_status)
000573 8118       ld temp,Y
000574 ff17       sbrs temp,time_set_S
000575 c004       rjmp return_On_1_Click
                 
000576 932f       push r18
000577 e321       ldi r18,'1'
000578 df17       rcall time_set
000579 912f       pop r18
                 
                  return_On_1_Click:
00057a 910f       pop r16
00057b 91cf       pop YL
00057c 91df       pop YH
00057d 911f       pop temp
                 
00057e 9478       sei
00057f 9bb2       sbis pinb,KBD_3		//wait until button is turned off
000580 cffe       rjmp PC-1
000581 9508       ret
                  //-------On 2 click-----------------------------
                  On_2_click:
000582 931f       push temp
000583 93df       push YH
000584 93cf       push YL
000585 930f       push r16
                 
000586 e0d1
000587 e2c1
000588 9119
000589 8108
00058a 3302
00058b f419
00058c 3011
00058d f408
00058e c09d
00058f e010
000590 e302
000591 e0d1
000592 e2c1
000593 9319
000594 8308       Anti_false_activation '2', return_On_2_Click
                 
000595 e0d1       ldi YH,high(time_set_status)
000596 e2ce       ldi YL,low(time_set_status)
000597 8118       ld temp,Y
000598 ff17       sbrs temp,time_set_S		//if time set mode on then skip menu navigation
000599 c005       rjmp menu_On_2_Click_label
                 
00059a 932f       push r18
00059b e322       ldi r18,'2'
00059c def3       rcall time_set
00059d 912f       pop r18
00059e c08d       rjmp return_On_2_Click
                 
                  menu_On_2_Click_label:
00059f 932f
0005a0 93bf
0005a1 93af
0005a2 931f
0005a3 93df
0005a4 93cf
0005a5 e0d1
0005a6 e2c0
0005a7 8128
0005a8 e010
0005a9 1321
0005aa c001
0005ab c07a
0005ac 952a
0005ad e110
0005ae 9f12
0005af 2da0
0005b0 2db1
0005b1 e610
0005b2 0fa1
0005b3 2711
0005b4 1fb1
0005b5 931f
0005b6 930f
0005b7 931f
0005b8 930f
0005b9 e010
0005ba e800
0005bb 940e 0030
0005bd 910f
0005be 911f
0005bf 939f
0005c0 938f
0005c1 937f
0005c2 ef90
0005c3 e081
0005c4 e071
0005c5 940e 0029
0005c7 917f
0005c8 918f
0005c9 919f
0005ca 910f
0005cb 911f
0005cc 931f
0005cd 930f
0005ce 93af
0005cf 93bf
0005d0 933f
0005d1 e014
0005d2 e131
0005d3 910d
0005d4 940e 0030
0005d6 939f
0005d7 938f
0005d8 937f
0005d9 ef90
0005da e081
0005db e071
0005dc 940e 0029
0005de 917f
0005df 918f
0005e0 919f
0005e1 953a
0005e2 f781
0005e3 913f
0005e4 91bf
0005e5 91af
0005e6 910f
0005e7 911f
0005e8 e110
0005e9 9f12
0005ea 2da0
0005eb 2db1
0005ec ec10
0005ed 0fa1
0005ee 2711
0005ef 1fb1
0005f0 931f
0005f1 930f
0005f2 931f
0005f3 930f
0005f4 e010
0005f5 ec00
0005f6 940e 0030
0005f8 910f
0005f9 911f
0005fa 939f
0005fb 938f
0005fc 937f
0005fd ef90
0005fe e081
0005ff e071
000600 940e 0029
000602 917f
000603 918f
000604 919f
000605 910f
000606 911f
000607 931f
000608 930f
000609 93af
00060a 93bf
00060b 933f
00060c e014
00060d e131
00060e 910d
00060f 940e 0030
000611 939f
000612 938f
000613 937f
000614 ef90
000615 e081
000616 e071
000617 940e 0029
000619 917f
00061a 918f
00061b 919f
00061c 953a
00061d f781
00061e 913f
00061f 91bf
000620 91af
000621 910f
000622 911f
000623 e0d1
000624 e2c0
000625 8328
000626 91cf
000627 91df
000628 911f
000629 91af
00062a 91bf
00062b 912f       menu_prev
                 
                  return_On_2_Click:
00062c 910f       pop r16
00062d 91cf       pop YL
00062e 91df       pop YH
00062f 911f       pop temp
                 
000630 9478       sei
000631 9bb1       sbis pinb,KBD_2		//wait until button is turned off
000632 cffe       rjmp PC-1
000633 9508       ret
                  //-------On 3 click-----------------------------
                  On_3_click:
000634 931f       push temp
000635 93df       push YH
000636 93cf       push YL
000637 930f       push r16
                 
000638 e0d1
000639 e2c1
00063a 9119
00063b 8108
00063c 3303
00063d f419
00063e 3011
00063f f408
000640 c00f
000641 e010
000642 e303
000643 e0d1
000644 e2c1
000645 9319
000646 8308       Anti_false_activation '3', return_On_3_Click
                  
000647 e0d1       ldi YH,high(time_set_status)
000648 e2ce       ldi YL,low(time_set_status)
000649 8118       ld temp,Y
00064a ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
00064b c004       rjmp return_On_3_Click
                 
00064c 932f       push r18
00064d e323       ldi r18,'3'
00064e de41       rcall time_set
00064f 912f       pop r18
                 
                  return_On_3_Click:
000650 910f       pop r16
000651 91cf       pop YL
000652 91df       pop YH
000653 911f       pop temp
                 
000654 9478       sei
000655 9bb0       sbis pinb,KBD_1		//wait until button is turned off
000656 cffe       rjmp PC-1
000657 9508       ret
                  //-------On 4 click-----------------------------
                  On_4_click:
000658 931f       push temp
000659 93df       push YH
00065a 93cf       push YL
00065b 930f       push r16
                 
00065c e0d1
00065d e2c1
00065e 9119
00065f 8108
000660 3304
000661 f419
000662 3011
000663 f408
000664 c00f
000665 e010
000666 e304
000667 e0d1
000668 e2c1
000669 9319
00066a 8308       Anti_false_activation '4', return_On_4_Click
                 
00066b e0d1       ldi YH,high(time_set_status)
00066c e2ce       ldi YL,low(time_set_status)
00066d 8118       ld temp,Y
00066e ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
00066f c004       rjmp return_On_4_Click
                 
000670 932f       push r18
000671 e324       ldi r18,'4'
000672 de1d       rcall time_set
000673 912f       pop r18
                 
                  return_On_4_Click:
000674 910f       pop r16
000675 91cf       pop YL
000676 91df       pop YH
000677 911f       pop temp
                 
000678 9478       sei
000679 9bb2       sbis pinb,KBD_3		//wait until button is turned off
00067a cffe       rjmp PC-1
00067b 9508       ret
                  //-------On 5 click-----------------------------
                  On_5_click:
00067c 931f       push temp
00067d 93df       push YH
00067e 93cf       push YL
00067f 930f       push r16
                 
000680 e0d1
000681 e2c1
000682 9119
000683 8108
000684 3305
000685 f419
000686 3011
000687 f408
000688 c01d
000689 e010
00068a e305
00068b e0d1
00068c e2c1
00068d 9319
00068e 8308       Anti_false_activation '5', return_On_5_Click
                  
00068f e0d1       ldi YH,high(time_set_status)
000690 e2ce       ldi YL,low(time_set_status)
000691 8118       ld temp,Y
000692 ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
000693 c005       rjmp sound_On_5_Click_label
                 
000694 932f       push r18
000695 e325       ldi r18,'5'
000696 ddf9       rcall time_set
000697 912f       pop r18
000698 c00d       rjmp return_On_5_Click
                 
                  sound_On_5_Click_label:
000699 e0d1
00069a e2c0
00069b 8118
00069c 3015
00069d f441
00069e e0d1
00069f e2c3
0006a0 8118
0006a1 fd10
0006a2 c002
0006a3 de63
0006a4 c001
0006a5 de73       sound_test return_On_5_Click
                 
                  return_On_5_Click:
0006a6 910f       pop r16
0006a7 91cf       pop YL
0006a8 91df       pop YH
0006a9 911f       pop temp
                  
0006aa 9478       sei
0006ab 9bb1       sbis pinb,KBD_2		//wait until button is turned off
0006ac cffe       rjmp PC-1
0006ad 9508       ret
                  //-------On 6 click-----------------------------
                  On_6_click:
0006ae 931f       push temp
0006af 93df       push YH
0006b0 93cf       push YL
0006b1 930f       push r16
                 
0006b2 e0d1
0006b3 e2c1
0006b4 9119
0006b5 8108
0006b6 3306
0006b7 f419
0006b8 3011
0006b9 f408
0006ba c00f
0006bb e010
0006bc e306
0006bd e0d1
0006be e2c1
0006bf 9319
0006c0 8308       Anti_false_activation '6', return_On_6_Click
                 
0006c1 e0d1       ldi YH,high(time_set_status)
0006c2 e2ce       ldi YL,low(time_set_status)
0006c3 8118       ld temp,Y
0006c4 ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
0006c5 c004       rjmp return_On_6_Click
                 
0006c6 932f       push r18
0006c7 e326       ldi r18,'6'
0006c8 ddc7       rcall time_set
0006c9 912f       pop r18
                 
                  return_On_6_Click:
0006ca 910f       pop r16
0006cb 91cf       pop YL
0006cc 91df       pop YH
0006cd 911f       pop temp
                 
0006ce 9478       sei
0006cf 9bb0       sbis pinb,KBD_1		//wait until button is turned off
0006d0 cffe       rjmp PC-1
0006d1 9508       ret
                  //-------On 7 click-----------------------------
                  On_7_click:
0006d2 931f       push temp
0006d3 93df       push YH
0006d4 93cf       push YL
0006d5 930f       push r16
                 
0006d6 e0d1
0006d7 e2c1
0006d8 9119
0006d9 8108
0006da 3307
0006db f419
0006dc 3011
0006dd f408
0006de c00f
0006df e010
0006e0 e307
0006e1 e0d1
0006e2 e2c1
0006e3 9319
0006e4 8308       Anti_false_activation '7', return_On_7_Click
                 
0006e5 e0d1       ldi YH,high(time_set_status)
0006e6 e2ce       ldi YL,low(time_set_status)
0006e7 8118       ld temp,Y
0006e8 ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
0006e9 c004       rjmp return_On_7_Click
                 
0006ea 932f       push r18
0006eb e327       ldi r18,'7'
0006ec dda3       rcall time_set
0006ed 912f       pop r18
                 
                  return_On_7_Click:
0006ee 910f       pop r16
0006ef 91cf       pop YL
0006f0 91df       pop YH
0006f1 911f       pop temp
                 
0006f2 9478       sei
0006f3 9bb2       sbis pinb,KBD_3		//wait until button is turned off
0006f4 cffe       rjmp PC-1
0006f5 9508       ret
                  //-------On 8 click-----------------------------
                  On_8_click:
0006f6 931f       push temp
0006f7 93df       push YH
0006f8 93cf       push YL
0006f9 930f       push r16
                 
0006fa e0d1
0006fb e2c1
0006fc 9119
0006fd 8108
0006fe 3308
0006ff f419
000700 3011
000701 f408
000702 c09d
000703 e010
000704 e308
000705 e0d1
000706 e2c1
000707 9319
000708 8308       Anti_false_activation '8', return_On_8_Click
                  
000709 e0d1       ldi YH,high(time_set_status)
00070a e2ce       ldi YL,low(time_set_status)
00070b 8118       ld temp,Y
00070c ff17       sbrs temp,time_set_S		//if time set mode on then skip menu navigation
00070d c005       rjmp menu_On_8_Click_label
                 
00070e 932f       push r18
00070f e328       ldi r18,'8'
000710 dd7f       rcall time_set
000711 912f       pop r18
000712 c08d       rjmp return_On_8_Click
                 
                  menu_On_8_Click_label:
000713 932f
000714 93bf
000715 93af
000716 931f
000717 93df
000718 93cf
000719 e0d1
00071a e2c0
00071b 8128
00071c e015
00071d 1321
00071e c001
00071f c07a
000720 9523
000721 e110
000722 9f12
000723 2da0
000724 2db1
000725 e610
000726 0fa1
000727 2711
000728 1fb1
000729 931f
00072a 930f
00072b 931f
00072c 930f
00072d e010
00072e e800
00072f 940e 0030
000731 910f
000732 911f
000733 939f
000734 938f
000735 937f
000736 ef90
000737 e081
000738 e071
000739 940e 0029
00073b 917f
00073c 918f
00073d 919f
00073e 910f
00073f 911f
000740 931f
000741 930f
000742 93af
000743 93bf
000744 933f
000745 e014
000746 e131
000747 910d
000748 940e 0030
00074a 939f
00074b 938f
00074c 937f
00074d ef90
00074e e081
00074f e071
000750 940e 0029
000752 917f
000753 918f
000754 919f
000755 953a
000756 f781
000757 913f
000758 91bf
000759 91af
00075a 910f
00075b 911f
00075c e110
00075d 9f12
00075e 2da0
00075f 2db1
000760 ec10
000761 0fa1
000762 2711
000763 1fb1
000764 931f
000765 930f
000766 931f
000767 930f
000768 e010
000769 ec00
00076a 940e 0030
00076c 910f
00076d 911f
00076e 939f
00076f 938f
000770 937f
000771 ef90
000772 e081
000773 e071
000774 940e 0029
000776 917f
000777 918f
000778 919f
000779 910f
00077a 911f
00077b 931f
00077c 930f
00077d 93af
00077e 93bf
00077f 933f
000780 e014
000781 e131
000782 910d
000783 940e 0030
000785 939f
000786 938f
000787 937f
000788 ef90
000789 e081
00078a e071
00078b 940e 0029
00078d 917f
00078e 918f
00078f 919f
000790 953a
000791 f781
000792 913f
000793 91bf
000794 91af
000795 910f
000796 911f
000797 e0d1
000798 e2c0
000799 8328
00079a 91cf
00079b 91df
00079c 911f
00079d 91af
00079e 91bf
00079f 912f       menu_next
                 
                  return_On_8_Click:
0007a0 910f       pop r16
0007a1 91cf       pop YL
0007a2 91df       pop YH
0007a3 911f       pop temp
                 
0007a4 9478       sei
0007a5 9bb1       sbis pinb,KBD_2		//wait until button is turned off
0007a6 cffe       rjmp PC-1
0007a7 9508       ret
                  //-------On 9 click-----------------------------
                  On_9_click:
0007a8 931f       push temp
0007a9 93df       push YH
0007aa 93cf       push YL
0007ab 930f       push r16
                 
0007ac e0d1
0007ad e2c1
0007ae 9119
0007af 8108
0007b0 3309
0007b1 f419
0007b2 3011
0007b3 f408
0007b4 c00f
0007b5 e010
0007b6 e309
0007b7 e0d1
0007b8 e2c1
0007b9 9319
0007ba 8308       Anti_false_activation '9', return_On_9_Click
                 
0007bb e0d1       ldi YH,high(time_set_status)
0007bc e2ce       ldi YL,low(time_set_status)
0007bd 8118       ld temp,Y
0007be ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
0007bf c004       rjmp return_On_9_Click
                 
0007c0 932f       push r18
0007c1 e329       ldi r18,'9'
0007c2 dccd       rcall time_set
0007c3 912f       pop r18
                 
                  return_On_9_Click:
0007c4 910f       pop r16
0007c5 91cf       pop YL
0007c6 91df       pop YH
0007c7 911f       pop temp
                 
0007c8 9478       sei
0007c9 9bb0       sbis pinb,KBD_1		//wait until button is turned off
0007ca cffe       rjmp PC-1
0007cb 9508       ret
                  //-------On * click-----------------------------
                  On_asterisk_click:
0007cc 931f       push temp
0007cd 93df       push YH
0007ce 93cf       push YL
0007cf 930f       push r16
                 
0007d0 e0d1
0007d1 e2c1
0007d2 9119
0007d3 8108
0007d4 320a
0007d5 f419
0007d6 3011
0007d7 f408
0007d8 c00c
0007d9 e010
0007da e20a
0007db e0d1
0007dc e2c1
0007dd 9319
0007de 8308       Anti_false_activation '*', return_On_asterisk_Click
                 
0007df e0d1       ldi YH,high(menu_location)	//
0007e0 e2c0       ldi YL,low(menu_location)	//read number of current page from SRAM
0007e1 8128       ld menu_loc,Y				//
0007e2 3024       cpi menu_loc,4
0007e3 f409       brne PC+2
0007e4 db7b       rcall time_set_start
                 
                  return_On_asterisk_Click:
0007e5 910f       pop r16
0007e6 91cf       pop YL
0007e7 91df       pop YH
0007e8 911f       pop temp
                 
0007e9 9478       sei
0007ea 9bb2       sbis pinb,KBD_3		//wait until button is turned off
0007eb cffe       rjmp PC-1
0007ec 9508       ret
                  //-------On 0 click-----------------------------
                  On_0_click:
0007ed 931f       push temp
0007ee 93df       push YH
0007ef 93cf       push YL
0007f0 930f       push r16
                 
0007f1 e0d1
0007f2 e2c1
0007f3 9119
0007f4 8108
0007f5 3300
0007f6 f419
0007f7 3011
0007f8 f408
0007f9 c00f
0007fa e010
0007fb e300
0007fc e0d1
0007fd e2c1
0007fe 9319
0007ff 8308       Anti_false_activation '0', return_On_0_Click
                 
000800 e0d1       ldi YH,high(time_set_status)
000801 e2ce       ldi YL,low(time_set_status)
000802 8118       ld temp,Y
000803 ff17       sbrs temp,time_set_S		//if time set mode on then skip sound settings
000804 c004       rjmp return_On_0_Click
                 
000805 932f       push r18
000806 e320       ldi r18,'0'
000807 dc88       rcall time_set
000808 912f       pop r18
                 
                  return_On_0_Click:
000809 910f       pop r16
00080a 91cf       pop YL
00080b 91df       pop YH
00080c 911f       pop temp
                 
00080d 9478       sei
00080e 9bb1       sbis pinb,KBD_2		//wait until button is turned off
00080f cffe       rjmp PC-1
000810 9508       ret
                  //-------On # click-----------------------------
                  On_grid_click:
000811 931f       push temp
000812 93df       push YH
000813 93cf       push YL
000814 930f       push r16
                 
000815 e0d1
000816 e2c1
000817 9119
000818 8108
000819 3203
00081a f419
00081b 3011
00081c f408
00081d c00c
00081e e010
00081f e203
000820 e0d1
000821 e2c1
000822 9319
000823 8308       Anti_false_activation '#', return_On_grid_Click
                  
000824 e0d1       ldi YH,high(menu_location)	//
000825 e2c0       ldi YL,low(menu_location)	//read number of current page from SRAM
000826 8128       ld menu_loc,Y				//
000827 3024       cpi menu_loc,4
000828 f409       brne PC+2
000829 dbda       rcall time_set_set_next_pair
                  
                  return_On_grid_Click:
00082a 910f       pop r16
00082b 91cf       pop YL
00082c 91df       pop YH
00082d 911f       pop temp
                  
00082e 9478       sei
00082f 9bb0       sbis pinb,KBD_1	//wait until button is turned off
000830 cffe       rjmp PC-1
000831 9508       ret
                  //----------------------------------------------
                 //================================================================
                 .include "timers.inc"		//macro and procedures for timer(s)
                 
                  * timers.inc
                  *
                  *  Created: 05.11.2015 0:04:38
                  *   Author: Hogs
                  */ 
                 
                  //==============TIMER 0 (8bit)==============================================
                 
                 		//Timer 0 is reserved for sound generation
                 		//you can see how it works in sound.inc
                 		//all code which using timer 0 is there
                 
                  //==========================================================================
                  //==============TIMER 1 (16-bit)============================================
                 
                  //======MACRO========================
                  //------Timer 1 Init-----------
                  .macro Timer1_Init
                  cli
                  ldi temp, 0 | (1<<OCIE1A) //enable A Match Interrupt and Overflow Interrupt
                  out TIMSK,temp 
                  clr temp
                  out TCCR1A,temp		//Normal Timer Mode
                  ldi temp,0 | (1<<CS12)
                  out TCCR1B,temp		//Set prescaler 1/256
                  ldi r16,0x0C			
                  ldi r17,0x35
                  out OCR1AH,r16			//set A as 3125
                  out OCR1AL,r17			//that mean timer tick is every 0.05sec
                  ldi r16,0x7A			
                  ldi r17,0x12
                  out OCR1BH,r16			//set B as 32500
                  out OCR1BL,r17			//that mean timer tick is every 0.5sec
                  clr temp
                  out TCNT1H,temp		//set current timer/counter as 0
                  out TCNT1L,temp
                  sei
                  .endm
                  //-----------------------------
                  //======INTERRUPTS AND PROC==========
                  //------On Match A Interrupt------
                  Keyboard_check_interrupt:
000832 931f       push temp
000833 93df       push YH
000834 93cf       push YL
                 
000835 e0d1       ldi YH,high(time_set_blink_count)
000836 e4c1       ldi YL,low(time_set_blink_count)
000837 8118       ld temp,Y
000838 9513       inc temp
000839 8318       st Y,temp
                 
00083a 940e 0266  call time_set_blink
                 
00083c b310
00083d 631c
00083e 7f1b
00083f bb12
000840 9bb2
000841 df8a
000842 9bb1
000843 dd3e
000844 9bb0
000845 ddee
000846 b310
000847 631c
000848 7f17
000849 bb12
00084a 9bb2
00084b dd12
00084c 9bb1
00084d de2e
00084e 9bb0
00084f de5e
000850 b310
000851 631c
000852 7e1f
000853 bb12
000854 9bb2
000855 de02
000856 9bb1
000857 de9e
000858 9bb0
000859 df4e
00085a b310
00085b 631c
00085c 7d1f
00085d bb12
00085e 9bb2
00085f de72
000860 9bb1
000861 df8b
000862 9bb0
000863 dfad       keyboard_check
                 
000864 e0d1       ldi YH,high(sound_status)	//
000865 e2c3       ldi YL,low(sound_status)	//get sound status in RAM
000866 8118       ld temp,Y					
000867 ff10       sbrs temp, sound_general_status	//if sound is off then 
000868 c00b       rjmp skip_A_addition				//OCIE1B interrupt will never happen
                 									//for prevent uncorrect timer work
                 									//I skip (OCR1A += 3125) if sound is off
                 
000869 b5ca       in YL, OCR1AL
00086a b5db       in YH, OCR1AH
00086b e315       ldi temp,0x35
00086c 0fc1       add YL,temp		//OCR1A += 3125
00086d e01c       ldi temp, 0x0C		//this need for correct work with keyboard
00086e 1fd1       adc YH,temp		//if sound enable
00086f 94f8       cli
000870 bddb       out OCR1AH,YH
000871 bdca       out OCR1AL,YL
000872 9478       sei
000873 c006       rjmp continue_A_add	//jump over TCNT1 clear, because if sound is on
                 						//TCNT1 must be cleared in OCIE1B interrupt
                 
                  skip_A_addition:
                 
000874 27cc       clr YL
000875 27dd       clr YH
000876 94f8       cli
000877 bddd       out TCNT1H,YH	//clear counter of timer1
000878 bdcc       out TCNT1L,YL
000879 9478       sei
                 
                  continue_A_add:
00087a e0d1       ldi YH,high(tick_count)
00087b e2c1       ldi YL,low(tick_count)
00087c 8118       ld temp,Y				//tick_count++
00087d 9513       inc temp
00087e 8318       st Y,temp	
                 
00087f 91cf       pop YL
000880 91df       pop YH
000881 911f       pop temp
000882 9518       reti
                  //--------------------------------
                 
                 reset:
                 .include "core_init.inc"	//clear sram, registers and stack init
                 
                  * Clear all registers and SRAM
                  * Initialization stack
                  */ 
                 
                 //================SRAM CLEAR=================================
                 RAM_Flush:	
000883 e6e0      LDI	ZL,Low(SRAM_START)
000884 e0f0      LDI	ZH,High(SRAM_START)
000885 2700      CLR	R16
                 Flush:
000886 9301      ST Z+,R16
000887 30f8      CPI	ZH,High(RAMEND+1)
000888 f7e9      BRNE Flush
000889 36e0      CPI	ZL,Low(RAMEND+1)	
00088a f7d9      BRNE Flush 
00088b 27ee      CLR	ZL
00088c 27ff      CLR	ZH
                 //===============REGISTERS CLEAR=============================
00088d e1ee      LDI	ZL, 30			
00088e 27ff      CLR	ZH		
00088f 95ea      DEC	ZL		
000890 83f0      ST Z,ZH		
000891 f7e9      BRNE PC-2		
                 //===============STACK INIT==================================
000892 e50f      LDI R16,Low(RAMEND)		
000893 bf0d      OUT SPL,R16			
000894 e008      LDI R16,High(RAMEND)
000895 bf0e      OUT SPH,R16
                 //-----------Program start-------------------------
                 
000896 94f8
000897 e110
000898 bf19
000899 2711
00089a bd1f
00089b e014
00089c bd1e
00089d e00c
00089e e315
00089f bd0b
0008a0 bd1a
0008a1 e70a
0008a2 e112
0008a3 bd09
0008a4 bd18
0008a5 2711
0008a6 bd1d
0008a7 bd1c
0008a8 9478      Timer1_Init
0008a9 b317
0008aa 7f18
0008ab bb17
0008ac b318
0008ad 6017
0008ae bb18
0008af b311
0008b0 631c
0008b1 bb11      keyboard_init				//initialization of ports for keyboard
0008b2 b314
0008b3 6f1c
0008b4 bb14
0008b5 b315
0008b6 7013
0008b7 bb15
0008b8 939f
0008b9 938f
0008ba 937f
0008bb ef92
0008bc e08f
0008bd e075
0008be 940e 0029
0008c0 917f
0008c1 918f
0008c2 919f
0008c3 e310
0008c4 bb15
0008c5 9aab
0008c6 95c8
0008c7 98ab
0008c8 939f
0008c9 938f
0008ca 937f
0008cb ee95
0008cc e18e
0008cd e079
0008ce 940e 0029
0008d0 917f
0008d1 918f
0008d2 919f
0008d3 9aab
0008d4 95c8
0008d5 98ab
0008d6 939f
0008d7 938f
0008d8 937f
0008d9 ef92
0008da e08f
0008db e075
0008dc 940e 0029
0008de 917f
0008df 918f
0008e0 919f
0008e1 9aab
0008e2 95c8
0008e3 98ab
0008e4 939f
0008e5 938f
0008e6 937f
0008e7 ef92
0008e8 e08f
0008e9 e075
0008ea 940e 0029
0008ec 917f
0008ed 918f
0008ee 919f
0008ef e210
0008f0 bb15
0008f1 9aab
0008f2 95c8
0008f3 98ab
0008f4 939f
0008f5 938f
0008f6 937f
0008f7 ef90
0008f8 e081
0008f9 e071
0008fa 940e 0029
0008fc 917f
0008fd 918f
0008fe 919f
0008ff 931f
000900 930f
000901 e010
000902 e208
000903 940e 0030
000905 910f
000906 911f
000907 939f
000908 938f
000909 937f
00090a ef90
00090b e081
00090c e071
00090d 940e 0029
00090f 917f
000910 918f
000911 919f
000912 931f
000913 930f
000914 e010
000915 e001
000916 940e 0030
000918 910f
000919 911f
00091a 939f
00091b 938f
00091c 937f
00091d e89e
00091e e28a
00091f e071
000920 940e 0029
000922 917f
000923 918f
000924 919f
000925 931f
000926 930f
000927 e010
000928 e00f
000929 940e 0030
00092b 910f
00092c 911f
00092d 939f
00092e 938f
00092f 937f
000930 e89e
000931 e28a
000932 e071
000933 940e 0029
000935 917f
000936 918f
000937 919f
000938 931f
000939 930f
00093a e010
00093b e400
00093c 940e 0030
00093e 910f
00093f 911f
000940 939f
000941 938f
000942 937f
000943 ef90
000944 e081
000945 e071
000946 940e 0029
000948 917f
000949 918f
00094a 919f
00094b 931f
00094c 930f
00094d e014
00094e e000
00094f 940e 0030
000951 910f
000952 911f
000953 939f
000954 938f
000955 937f
000956 ef90
000957 e081
000958 e071
000959 940e 0029
00095b 917f
00095c 918f
00095d 919f
00095e 931f
00095f 930f
000960 e014
000961 e000
000962 940e 0030
000964 910f
000965 911f
000966 939f
000967 938f
000968 937f
000969 ef90
00096a e081
00096b e071
00096c 940e 0029
00096e 917f
00096f 918f
000970 919f
000971 931f
000972 930f
000973 e014
000974 e000
000975 940e 0030
000977 910f
000978 911f
000979 939f
00097a 938f
00097b 937f
00097c ef90
00097d e081
00097e e071
00097f 940e 0029
000981 917f
000982 918f
000983 919f
000984 931f
000985 930f
000986 e014
000987 e000
000988 940e 0030
00098a 910f
00098b 911f
00098c 939f
00098d 938f
00098e 937f
00098f ef90
000990 e081
000991 e071
000992 940e 0029
000994 917f
000995 918f
000996 919f
000997 931f
000998 930f
000999 e014
00099a e004
00099b 940e 0030
00099d 910f
00099e 911f
00099f 939f
0009a0 938f
0009a1 937f
0009a2 ef90
0009a3 e081
0009a4 e071
0009a5 940e 0029
0009a7 917f
0009a8 918f
0009a9 919f
0009aa 931f
0009ab 930f
0009ac e014
0009ad e00e
0009ae 940e 0030
0009b0 910f
0009b1 911f
0009b2 939f
0009b3 938f
0009b4 937f
0009b5 ef90
0009b6 e081
0009b7 e071
0009b8 940e 0029
0009ba 917f
0009bb 918f
0009bc 919f
0009bd 931f
0009be 930f
0009bf e014
0009c0 e10f
0009c1 940e 0030
0009c3 910f
0009c4 911f
0009c5 939f
0009c6 938f
0009c7 937f
0009c8 ef90
0009c9 e081
0009ca e071
0009cb 940e 0029
0009cd 917f
0009ce 918f
0009cf 919f
0009d0 931f
0009d1 930f
0009d2 e014
0009d3 e000
0009d4 940e 0030
0009d6 910f
0009d7 911f
0009d8 939f
0009d9 938f
0009da 937f
0009db ef90
0009dc e081
0009dd e071
0009de 940e 0029
0009e0 917f
0009e1 918f
0009e2 919f
0009e3 931f
0009e4 930f
0009e5 e014
0009e6 e000
0009e7 940e 0030
0009e9 910f
0009ea 911f
0009eb 939f
0009ec 938f
0009ed 937f
0009ee ef90
0009ef e081
0009f0 e071
0009f1 940e 0029
0009f3 917f
0009f4 918f
0009f5 919f
0009f6 931f
0009f7 930f
0009f8 e014
0009f9 e10f
0009fa 940e 0030
0009fc 910f
0009fd 911f
0009fe 939f
0009ff 938f
000a00 937f
000a01 ef90
000a02 e081
000a03 e071
000a04 940e 0029
000a06 917f
000a07 918f
000a08 919f
000a09 931f
000a0a 930f
000a0b e014
000a0c e00e
000a0d 940e 0030
000a0f 910f
000a10 911f
000a11 939f
000a12 938f
000a13 937f
000a14 ef90
000a15 e081
000a16 e071
000a17 940e 0029
000a19 917f
000a1a 918f
000a1b 919f
000a1c 931f
000a1d 930f
000a1e e014
000a1f e004
000a20 940e 0030
000a22 910f
000a23 911f
000a24 939f
000a25 938f
000a26 937f
000a27 ef90
000a28 e081
000a29 e071
000a2a 940e 0029
000a2c 917f
000a2d 918f
000a2e 919f
000a2f 931f
000a30 930f
000a31 e014
000a32 e000
000a33 940e 0030
000a35 910f
000a36 911f
000a37 939f
000a38 938f
000a39 937f
000a3a ef90
000a3b e081
000a3c e071
000a3d 940e 0029
000a3f 917f
000a40 918f
000a41 919f
000a42 931f
000a43 930f
000a44 e014
000a45 e000
000a46 940e 0030
000a48 910f
000a49 911f
000a4a 939f
000a4b 938f
000a4c 937f
000a4d ef90
000a4e e081
000a4f e071
000a50 940e 0029
000a52 917f
000a53 918f
000a54 919f
000a55 931f
000a56 930f
000a57 e014
000a58 e000
000a59 940e 0030
000a5b 910f
000a5c 911f
000a5d 939f
000a5e 938f
000a5f 937f
000a60 ef90
000a61 e081
000a62 e071
000a63 940e 0029
000a65 917f
000a66 918f
000a67 919f
000a68 931f
000a69 930f
000a6a e014
000a6b e000
000a6c 940e 0030
000a6e 910f
000a6f 911f
000a70 939f
000a71 938f
000a72 937f
000a73 ef90
000a74 e081
000a75 e071
000a76 940e 0029
000a78 917f
000a79 918f
000a7a 919f
000a7b 931f
000a7c 930f
000a7d 931f
000a7e 930f
000a7f e010
000a80 e800
000a81 940e 0030
000a83 910f
000a84 911f
000a85 939f
000a86 938f
000a87 937f
000a88 ef90
000a89 e081
000a8a e071
000a8b 940e 0029
000a8d 917f
000a8e 918f
000a8f 919f
000a90 910f
000a91 911f      LCD_init					//LCD initialization
000a92 94f8
000a93 27dd
000a94 e6c0
000a95 27ee
000a96 27ff
000a97 ec31
000a98 940e 0055
000a9a 9309
000a9b 95e3
000a9c 953a
000a9d f7d1
000a9e 9478
000a9f e0d1
000aa0 e2c0
000aa1 e010
000aa2 8318
000aa3 93ff
000aa4 93ef
000aa5 931f
000aa6 930f
000aa7 933f
000aa8 e0f0
000aa9 e6e0
000aaa e014
000aab e131
000aac 9101
000aad 940e 0030
000aaf 939f
000ab0 938f
000ab1 937f
000ab2 ef90
000ab3 e081
000ab4 e071
000ab5 940e 0029
000ab7 917f
000ab8 918f
000ab9 919f
000aba 953a
000abb f781
000abc 913f
000abd 910f
000abe 911f
000abf 91ef
000ac0 91ff
000ac1 931f
000ac2 930f
000ac3 931f
000ac4 930f
000ac5 e010
000ac6 ec00
000ac7 940e 0030
000ac9 910f
000aca 911f
000acb 939f
000acc 938f
000acd 937f
000ace ef90
000acf e081
000ad0 e071
000ad1 940e 0029
000ad3 917f
000ad4 918f
000ad5 919f
000ad6 910f
000ad7 911f
000ad8 93ff
000ad9 93ef
000ada 931f
000adb 930f
000adc 933f
000add e0f0
000ade ece0
000adf e014
000ae0 e131
000ae1 9101
000ae2 940e 0030
000ae4 939f
000ae5 938f
000ae6 937f
000ae7 ef90
000ae8 e081
000ae9 e071
000aea 940e 0029
000aec 917f
000aed 918f
000aee 919f
000aef 953a
000af0 f781
000af1 913f
000af2 910f
000af3 911f
000af4 91ef
000af5 91ff      menu_init
000af6 b311
000af7 6410
000af8 bb11
000af9 b312
000afa 7b1f
000afb bb12
000afc 2711
000afd bf12
000afe e117
000aff bf1c
000b00 b719
000b01 6012
000b02 bf19      sound_init
000b03 e31c
000b04 b910
000b05 e0d1
000b06 e2ca
000b07 ed10
000b08 8318      I2C_Init
000b09 931f
000b0a 93df
000b0b 93cf
000b0c e0d1
000b0d e2cb
000b0e e010
000b0f 8318
000b10 940e 022e
000b12 e0d1
000b13 e2cc
000b14 8118
000b15 fd17
000b16 940e 0246
000b18 e0d1
000b19 e2cb
000b1a e012
000b1b 8318
000b1c 940e 022e
000b1e e0d1
000b1f e2cc
000b20 8118
000b21 fd16
000b22 940e 0256
000b24 91cf
000b25 91df
000b26 911f      I2C_Check_Clock_Settings
000b27 e0d1
000b28 e3c0
000b29 e012
000b2a 9319
000b2b e019
000b2c 9319
000b2d e016
000b2e 9319
000b2f e019
000b30 9319
000b31 e013
000b32 9319
000b33 e019
000b34 9319
000b35 e011
000b36 9319
000b37 e019
000b38 9319
000b39 9319
000b3a 9319
000b3b e0d1
000b3c e3ca
000b3d e118
000b3e 9319
000b3f e31c
000b40 9319
000b41 e11f
000b42 9319
000b43 e01c
000b44 9319
000b45 e613
000b46 9319      time_set_init
                 
                 //-----------MAIN----------------------------------
                 main:
                 
000b47 940e 0176
000b49 940e 01cf 	Refresh_time
000b4b 932f
000b4c 93bf
000b4d 93af
000b4e 931f
000b4f 93df
000b50 93cf
000b51 e0d1
000b52 e2c0
000b53 8128
000b54 e110
000b55 9f12
000b56 2da0
000b57 2db1
000b58 e610
000b59 0fa1
000b5a 2711
000b5b 1fb1
000b5c 931f
000b5d 930f
000b5e 931f
000b5f 930f
000b60 e010
000b61 e800
000b62 940e 0030
000b64 910f
000b65 911f
000b66 939f
000b67 938f
000b68 937f
000b69 ef90
000b6a e081
000b6b e071
000b6c 940e 0029
000b6e 917f
000b6f 918f
000b70 919f
000b71 910f
000b72 911f
000b73 931f
000b74 930f
000b75 93af
000b76 93bf
000b77 933f
000b78 e014
000b79 e131
000b7a 910d
000b7b 940e 0030
000b7d 939f
000b7e 938f
000b7f 937f
000b80 ef90
000b81 e081
000b82 e071
000b83 940e 0029
000b85 917f
000b86 918f
000b87 919f
000b88 953a
000b89 f781
000b8a 913f
000b8b 91bf
000b8c 91af
000b8d 910f
000b8e 911f
000b8f e110
000b90 9f12
000b91 2da0
000b92 2db1
000b93 ec10
000b94 0fa1
000b95 2711
000b96 1fb1
000b97 931f
000b98 930f
000b99 931f
000b9a 930f
000b9b e010
000b9c ec00
000b9d 940e 0030
000b9f 910f
000ba0 911f
000ba1 939f
000ba2 938f
000ba3 937f
000ba4 ef90
000ba5 e081
000ba6 e071
000ba7 940e 0029
000ba9 917f
000baa 918f
000bab 919f
000bac 910f
000bad 911f
000bae 931f
000baf 930f
000bb0 93af
000bb1 93bf
000bb2 933f
000bb3 e014
000bb4 e131
000bb5 910d
000bb6 940e 0030
000bb8 939f
000bb9 938f
000bba 937f
000bbb ef90
000bbc e081
000bbd e071
000bbe 940e 0029
000bc0 917f
000bc1 918f
000bc2 919f
000bc3 953a
000bc4 f781
000bc5 913f
000bc6 91bf
000bc7 91af
000bc8 910f
000bc9 911f
000bca 91cf
000bcb 91df
000bcc 911f
000bcd 91af
000bce 91bf
000bcf 912f      	menu_refresh
                 
                 	
000bd0 e025          ldi  r18, 5
000bd1 ec32          ldi  r19, 194
000bd2 e846          ldi  r20, 134
000bd3 e251          ldi  r21, 33
000bd4 955a      L1: dec  r21
000bd5 f7f1          brne L1
000bd6 954a          dec  r20
000bd7 f7e1          brne L1
000bd8 953a          dec  r19
000bd9 f7d1          brne L1
000bda 952a          dec  r18
000bdb f7c1          brne L1
                 	
000bdc cf6a      rjmp main		
                 //-------------------------------------------------
                 //========EEPROM SEGMENT=================================================
                 .eseg
                 .org 0
000000 4c
000001 65
000002 76
000003 65
000004 6c
000005 20
000006 43
000007 4f
000008 20
000009 20
00000a 20
00000b 20
00000c 20
00000d 20
00000e 20
00000f 20        ee_hello_msg:	.db "Level CO        "
000010 4c
000011 65
000012 76
000013 65
000014 6c
000015 20
000016 43
000017 48
000018 34
000019 20
00001a 20
00001b 20
00001c 20
00001d 20
00001e 20
00001f 00        ee_CH4_msg:		.db "Level CH4      ",0
000020 54
000021 65
000022 6d
000023 70
000024 65
000025 72
000026 61
000027 74
000028 75
000029 72
00002a 65
00002b 20
00002c 20
00002d 20
00002e 20
00002f 00        ee_temp_msg:	.db "Temperature    ",0
000030 43
000031 6f
000032 6f
000033 72
000034 64
000035 69
000036 6e
000037 61
000038 74
000039 65
00003a 73
00003b 20
00003c 20
00003d 20
00003e 20
00003f 00        ee_coords_msg:	.db "Coordinates    ",0
000040 54
000041 69
000042 6d
000043 65
000044 20
000045 20
000046 20
000047 20
000048 20
000049 20
00004a 20
00004b 20
00004c 20
00004d 20
00004e 20
00004f 00        ee_time_msg:	.db "Time           ",0
000050 53
000051 6f
000052 75
000053 6e
000054 64
000055 28
000056 35
000057 2d
000058 4f
000059 6e
00005a 2f
00005b 4f
00005c 66
00005d 66
00005e 29
00005f 00        ee_sound_msg:	.db "Sound(5-On/Off)",0
000060 74
000061 65
000062 73
000063 74
000064 20
000065 73
000066 74
000067 72
000068 20
000069 31
00006a 20
00006b 20
00006c 20
00006d 20
00006e 20
00006f 01        ee_test_msg1:	.db "test str 1     ",1
000070 74
000071 65
000072 73
000073 74
000074 20
000075 73
000076 74
000077 72
000078 20
000079 32
00007a 20
00007b 20
00007c 20
00007d 20
00007e 20
00007f 01        ee_test_msg2:	.db "test str 2     ",1
000080 74
000081 65
000082 73
000083 74
000084 20
000085 73
000086 74
000087 72
000088 20
000089 33
00008a 20
00008b 20
00008c 20
00008d 20
00008e 20
00008f 01        ee_test_msg3:	.db "test str 3     ",1
000090 74
000091 65
000092 73
000093 74
000094 20
000095 73
000096 74
000097 72
000098 20
000099 34
00009a 20
00009b 20
00009c 20
00009d 20
00009e 20
00009f 01        ee_test_msg4:	.db "test str 4     ",1
0000a0 31
0000a1 32
0000a2 3a
0000a3 33
0000a4 34
0000a5 20
0000a6 31
0000a7 34
0000a8 2f
0000a9 31
0000aa 31
0000ab 2f
0000ac 31
0000ad 35
0000ae 20
0000af 01        ee_test_msg5:	.db "12:34 14/11/15 ",1
0000b0 50
0000b1 72
0000b2 65
0000b3 73
0000b4 73
0000b5 20
0000b6 35
0000b7 20
0000b8 74
0000b9 6f
0000ba 20
0000bb 74
0000bc 65
0000bd 73
0000be 74
0000bf 20        ee_test_msg6:	.db "Press 5 to test "
                 //=======================================================================


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32" register use summary:
r0 :  13 r1 :  12 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16: 377 r17: 822 r18:  91 r19:  70 r20:   2 r21:   2 r22:   0 r23: 163 
r24: 163 r25: 163 r26:  66 r27:  66 r28: 239 r29: 239 r30:  29 r31:  28 
x  :  14 y  : 209 z  :  14 
Registers used: 20 out of 35 (57.1%)

"ATmega32" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  25 add   :  36 adiw  :   3 and   :   0 
andi  :  36 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :   7 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   4 brlt  :   0 brmi  :   0 
brne  :  55 brpl  :   1 brsh  :  13 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  : 112 cbi   :   7 cbr   :   0 
clc   :   0 clh   :   0 cli   :  10 cln   :   0 clr   :  50 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   3 cpc   :   0 
cpi   :  52 cpse  :   2 dec   :  25 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  27 inc   :  26 jmp   :   2 
ld    : 121 ldd   :   0 ldi   : 681 lds   :   0 lpm   :  27 lsl   :   0 
lsr   :   0 mov   :  31 movw  :   0 mul   :  13 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   3 ori   :  14 out   :  66 pop   : 543 
push  : 518 rcall :  59 ret   :  32 reti  :  29 rjmp  :  80 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :   8 sbic  :   1 sbis  :  25 
sbiw  :   0 sbr   :   0 sbrc  :   9 sbrs  :  19 sec   :   0 seh   :   0 
sei   :  22 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    : 116 std   :   0 sts   :   0 
sub   :   0 subi  :   7 swap  :   3 tst   :   0 wdr   :   0 
Instructions used: 43 out of 113 (38.1%)

"ATmega32" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0017ba   6038      0   6038   32768  18.4%
[.dseg] 0x000060 0x000142      0    226    226    2048  11.0%
[.eseg] 0x000000 0x0000c0      0    192    192    1024  18.8%

Assembly complete, 0 errors, 0 warnings
